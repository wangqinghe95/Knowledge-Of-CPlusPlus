# 设计模式
## 软件设计原则
1. 开闭原则
    + 软件实体应当对扩展开放，对修改关闭
2. 里氏替换原则
    + 子类可以拓展父类的功能，尽量不要重写父类的方法
3. 依赖倒置原则
    + 面向接口编程，不要面向实现编程
4. 单一职责原则
    + 一个类应该有且仅有一个引起它变化的原因，否则类就应该被拆分
5. 接口隔离原则
    + 客户端不应该被迫依赖它不适应的方法。一个类对另一个类的依赖应该建立在最小的接口上
6. 迪米特原则
    + 如果两个软件实体无需直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。降低类的耦合度，提高模块的相对独立性
7. 合成复用原则
    + 在软件复用时，尽量先使用组合或者聚合等关联关系来实现，其次再考虑使用继承关系实现

## 简单工厂模式
1. 描述：根据传入的不同参数，返回不同的实例
    + 工厂角色负责创建所有实例的内部逻辑
    + 抽象产品角色是所有要创建的所有对象的父类，负责描述所有实例的公共接口
    + 具体产品角色是创建目标，所有创建的对象都是该角色的某个具体类的实例。
2. 实现
    + 根据已经实现的抽象产品类和具体产品类，在工厂类中，根据传入的参数，返回不同的具体产品的类
    
## 策略模式
1. 描述
    + 定义一系列的算法，将他们一一封装起来，并且使他们可相互替换。
2. 实现
    + 抽象算法类在使用类的构造函数中被注册，使用过程中，可以直接先将具体类的实例化在实用类构造时直接作为构造参数传入。

## 装饰模式
1. 描述：
    + 用来给对象增加某些特性或者对被修饰对象进行某些修改
2. 实现
    + 装饰器类继承抽象的对象类，并且具体的装饰器类包含抽象的对象类。
    + 值得注意的是，是装饰的具体类需要一层一层嵌套的，最终嵌套到使用的对象类。并且最终显示使用需要最外层的装饰类来调用
    
## 代理模式
1. 描述：
    + 为其他对象提供一种代理以控制这个对象的访问
2. 实现：
    + 代理类中有一个访问对象类的指针，通过调用代理类的相关接口去使用对象类中的功能

## 工厂模式
1. 描述
    + 工厂父类负责定义创建对象的公共接口，而子类负责生成具体的对象
2. 角色
    + 抽象工厂类：工厂方法模式的核心类，提供创建具体产品的接口，由具体工厂类实现
    + 具体工厂类：继承抽象工厂，实现创建对应具体产品对象的方式
    + 抽象产品类：具体产品继承的父类
    + 具体产品类：具体工厂所创建的对象
2. 实现
    + 一个抽象工厂类，有所有产品的共有的抽象接口
    + 抽象产品类，继承抽象工厂类，具体实现抽象接口
    + 具体工厂类，包含一个抽象的创建工厂接口
    + 具体产品类，实现抽象的创建工厂接口，具体返回对应的抽象产品类对象或者指针

## 模板方法模式
1. 描述
    + 将算法封装到父类中，具体实现放到子类中
2. 实现
    + 一个父类中，定义了算法调用的接口，以及算法的抽象封装接口
    + 定义子类继承父类，并且在子类中重写算法的具体实现
    + 调用中，一个父类指针指向子类的实体，然后指针调用算法的使用接口

## 外观模式

## 建造者模式

## 观察者模式

## 抽象工厂模式

## 状态模式

## 适配器模式

## 备忘录模式

## 组合模式

## 迭代器模式

## 单例模式

## 桥接模式

## 命令模式

## 责任链模式

## 中介者模式

## 享元模式