# DataStruct

## 什么是数据结构（data structure）？C++ 中常见的数据结构有哪些？
+ 数据结构是计算机科学中一种基础概念，它指的是数据对象以及他们之间的关系，包括这些对象之间执行的操作
+ C++ 常见的数据结构有：
    - 数组
    - 链表
    - 栈
    - 队列
    - 树
    - 图

## 解释 C++ 中的时间复杂度和空间复杂度。
+ 时间复杂度和空间复杂度是用来衡量算法效率的两个指标
+ 时间复杂度指的是算法执行所需要的时间，通常以大 O 符号表示法来表示时间的复杂度。常用的时间复杂度量级有常数阶 O(1), 对数阶 O(logn), 线性阶 O(n), 线性对数阶 O(nlogn), 平方阶 O(n^2), 立方阶 O(n^3), K 次方阶 O(n^k), 指数阶 O(2^n)
+ 空间复杂度指的是算法执行所需的内存空间大小，通常用 S(n)=O(f(n)),常见的空间复杂度量级有常数阶 O(1),线性阶 O(n), 平方阶 O(n^2)

### 什么是 O(n)、O(nlogn)、O(n^2) 等时间复杂度表示法？它们分别代表什么含义？
+ 时间复杂度是算法性能的一种度量，它衡算的是算法运行时间与输入规模之间的关系。
+ O(n) 表示算法的运行时间与输入规模 n 成这个正比
+ O(nlogn) 表示算法运行时间与输入规模 n 与 nlogn 成正比
+ O(n^2) 表示算法运行时间与输入规模 n 与 n^2 成正比

##  什么是红黑树（red-black tree）？它有什么作用？
### 红黑树的概念：
1. 它是二叉排序树：
    + 若左子树不空，则左子树上所有节点的值均小于或等于它的根节点的值；
    + 若右子树不空，则右子树上所有节点的值均大于或等于它的根节点的值；
    + 左右子树也分别为二叉排序树；
2. 它满足以下几点要求：
    + 树中所有节点非红即黑；
    + 根节点必为黑节点；
    + 红节点的子节点必为黑（黑节点的子节点可为黑）；
    + 每个红色节点必须有两个黑色子节点
    + 从根到叶节点的任何任何路径上黑节点的点数相同；
3. 增删查改的时间复杂度都是 O(logn)

### 什么是 AVL 树？它有什么作用？
+ AVL 是一个自平衡二叉树，其中任何节点的两棵子树的最大高度差为 1，因此也被称为高度平衡树
+ 查找，插入，和删除的平均和最坏时间复杂度是 O(logn)
+ 性质
    + AVL 树是一颗自平衡二叉树
    + 任何节点的两棵子树的最大高度差为 1，因此也被称为高度平衡树
    + 在 AVL 树中，查找，插入，和删除的平均和最坏时间复杂度是 O(logn)
    + 主要作用是保持树的高度最小，从而树的查找效率最高
+ 缺点
    + 插入和删除都需要进行更多的旋转操作，因此相较于红黑树，AVL 树的实现难度更大
    + AVL 树需要维护每个节点的平衡印子，因此需要更多的空间来存储平衡因子，这会导致 AVL 树的空间开销更大
    + 在频繁插入和删除操作时，AVL 树需要更多的旋转操作来保持平衡，因此相较于红黑树，AVL 树的性能可能会受到影响

### 什么是 B 树？它有什么作用？
+ B 树是一种自平衡多路查找树
+ 可以在磁盘等外部设备存储大量的数据，并且能够快速的进行查找、删除、和插入操作
+ B 树中每个节点可以包含多个键值，每个节点的子节点也可以大于 2，因此 B 树相较于二叉查找树等其他数据结构，具有更高的存储效率和更快的查找效率
+ B 的应用场景是在文件系统和数据库系统中，用于管理大量的数据结构

### 什么是哈希表（hash table）？它有什么作用？
+ hash table 是一种数据结构，通过将关键码映射到表中一个位置来访问记录，以加快查找的速度。
+ 哈希表提供了快速插入操作和查找操作，无论哈希表中有多少条数据，插入和查找的时间复杂度都是 O(1)

## 什么是堆（heap）？它有什么作用？
+ 堆是一种数据结构，它可以快速地进行查找、插入和删除等操作
+ 堆可以用来实现队列，堆排序等算法

## 什么是堆排序（heap sort）？它有什么特点？
+ 一种基于堆的排序算法，将待排序列构造成一个大顶堆，然后将堆顶元素与末尾元素交换位置，再重新调整堆，直到整个序列有序。
+ 特点
    - 是一种不稳定的排序算法
    - 排序时间复杂度为 O(nlogn),最坏的时间复杂度和平均时间复杂度都是 O(nlogn),最好的时间复杂度是 O(n),空间复杂度O(1)
    - 需要额外的空间去存储堆，因此空间开销大

## 什么是拓扑排序（topological sorting）？它有什么作用？
+ 拓扑排序是一种对有向无环图进行排序的算法。它可以解决一些依赖问题，比如编译器中的模块依赖关系、任务调度中的任务依赖关系等
+ 拓扑排序的基本思想是将有向无环图的结点排成一个线性序列，使得对于任何一条有向边(u,v)，都有 u 在 v 前。
    - 如果拓扑排序中存在环，则无法进行拓扑排序
+ 拓扑排序的时间复杂度是  O(|u|+|v|)

## 什么是并查集（union-find set）？它有什么作用？
+ 并查集是一种树形数据结构，主要是处理一些不相交集的合并及查询问题。
+ 并查集的主要作用是求连通分支数。

## 什么是 Trie 树？它有什么作用？
+ 前缀树，也叫字典树，是一种有序树，用于保存关联数组，保存的值通常是字符串
+ 与二叉查找树不同，值不是直接保存在节点中，而是由节点在树中的位置决定
+ 一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。
+ Trie 树可以高效地存储和教唆字符串数据集中的键

##  什么是最短路径算法（shortest path algorithm）
+ 用于计算图中两个节点之间的最短路径算法。
###  Dijkstra 算法
+ 要求图中权值非负
+ 从起始点开始，采用贪心算法的策略，每次遍历到起始点距离最近且没有访问过的顶点的邻接节点，直到扩散到终点为止
+ 时间复杂度 O(|V|^2)

### Bellman-Ford 算法
+ 适应一般情况，即图中边存在负权边的情况
+ 计算带权有向图中单源最短路径
+ 从起点开始，采用贪心算法的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。

### Floyd-Warshall 算法
+ 一种用于计算带权有向图中任意两点之间的最短路径的算法。该算法利用动态规划的思想将计算的时间复杂度降低为 O(v^3)
    + 最短路路径的本质就是比较在两个顶点之间中转点，比较经过与不经过中转点的距离哪个更短
+ 能处理带负权边的图，但是不能处理存在负权边的图

## 什么是最小生成树算法（minimum spanning tree algorithm）？
+ 一种用于计算无向图中的最小生成树的算法。
+ 最小生成树指的是在一个连通的无向图中，找到一颗包含所有节点的生成树，并使得这颗生成树的边权值最小。
### Prim 算法
+ 从顶点的角度出发，每次选择一个离当前生成树最近的顶点，并将其相邻的边加入到生成树中。

### Kruskal 算法
+ 从边的角度出发，每次选择一条权重最小，但是不会形成环的边加入到生成树中

---

## 掌握 C++ 中的排序算法，例如快速排序、归并排序等。
### [快速排序](./quickSort.cpp)
### [归并排序](./mergeSort.cpp)
### [冒泡排序](./bubbleSort.cpp)
### [堆排序](./heapSort.cpp)
### [选择排序](./selectSort.cpp)
### [希尔排序](./shellSort.cpp)
### [插入排序](./insertSort.cpp)

## 掌握 C++ 中的查找算法，例如二分查找、哈希表等。
### [二分查找](./binaryTree.cpp)
### [建树](./createTree.cpp)
### [中序遍历二叉树](./inorderTraversal.cpp)
### [层次遍历二叉树](./levelOrder.cpp)
### [后序遍历二叉树](./postorderTraversal.cpp)
### [先序遍历二叉树](./preorderTraversal.cpp)
### [平衡二叉树](./AVL.cpp)

