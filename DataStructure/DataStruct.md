# DataStruct

## 什么是数据结构（data structure）？C++ 中常见的数据结构有哪些？
+ 数据结构是计算机科学中一种基础概念，它指的是数据对象以及他们之间的关系，包括这些对象之间执行的操作
+ C++ 常见的数据结构有：
    - 数组
    - 链表
    - 栈
    - 队列
    - 树
    - 图

## 解释 C++ 中的时间复杂度和空间复杂度。
+ 时间复杂度和空间复杂度是用来衡量算法效率的两个指标
+ 时间复杂度指的是算法执行所需要的时间，通常以大 O 符号表示法来表示时间的复杂度。常用的时间复杂度量级有常数阶 O(1), 对数阶 O(logn), 线性阶 O(n), 线性对数阶 O(nlogn), 平方阶 O(n^2), 立方阶 O(n^3), K 次方阶 O(n^k), 指数阶 O(2^n)
+ 空间复杂度指的是算法执行所需的内存空间大小，通常用 S(n)=O(f(n)),常见的空间复杂度量级有常数阶 O(1),线性阶 O(n), 平方阶 O(n^2)

### 什么是 O(n)、O(nlogn)、O(n^2) 等时间复杂度表示法？它们分别代表什么含义？
+ 时间复杂度是算法性能的一种度量，它衡算的是算法运行时间与输入规模之间的关系。
+ O(n) 表示算法的运行时间与输入规模 n 成这个正比
+ O(nlogn) 表示算法运行时间与输入规模 n 与 nlogn 成正比
+ O(n^2) 表示算法运行时间与输入规模 n 与 n^2 成正比

### 树相关
##  什么是红黑树（red-black tree）？它有什么作用？
+ 概念
    + 红黑树是一种自平衡的二叉查找树，通过一些性质的定义，将任意节点的左右子树高度差控制在一定范围内，以达到平衡状态。
+ 性质
    + 它是二叉排序树：
        + 若左子树不空，则左子树上所有节点的值均小于或等于它的根节点的值；
        + 若右子树不空，则右子树上所有节点的值均大于或等于它的根节点的值；
        + 左右子树也分别为二叉排序树；
    + 它满足以下几点要求：
        + 树中所有节点非红即黑；
        + 根节点必为黑节点；
        + 红节点的子节点必为黑（黑节点的子节点可为黑）；
        + 每个红色节点必须有两个黑色子节点
        + 从根到叶节点的任何任何路径上黑节点的点数相同；
+ 时间复杂度
    + 增删查改的时间复杂度都是 O(logn)
+ 应用场景
    + C++ STL 的 map、set、multimap 等结构

### 什么是 AVL 树？它有什么作用？
+ 概念
    + AVL 是一个自平衡二叉树，其中任何节点的两棵子树的最大高度差为 1，因此也被称为高度平衡树
+ 时间复杂度
    + 查找，插入，和删除的平均和最坏时间复杂度是 O(logn)
+ 性质
    + AVL 树是一颗自平衡二叉树
    + 任何节点的两棵子树的最大高度差为 1，因此也被称为高度平衡树
    + 在 AVL 树中，查找，插入，和删除的平均和最坏时间复杂度是 O(logn)
    + 主要作用是保持树的高度最小，从而树的查找效率最高
+ 缺点
    + 插入和删除都需要进行更多的旋转操作，因此相较于红黑树，AVL 树的实现难度更大
    + AVL 树需要维护每个节点的平衡印子，因此需要更多的空间来存储平衡因子，这会导致 AVL 树的空间开销更大
    + 在频繁插入和删除操作时，AVL 树需要更多的旋转操作来保持平衡，因此相较于红黑树，AVL 树的性能可能会受到影响
+ 应用场景
    + Windows 对进程地址空间的管理
    + Windows NT 内核

### 红黑树比 AVL 有什么优点
+ 红黑树的平衡性能更好。红黑树的平衡策略更加灵活，可以通过颜色变化来实现平衡，AVL 需要频繁的旋转节点
+ 红黑树的插入和删除操作平均的时间复杂度要小于 AVL 。红黑树和AVL的操作时间复杂度都是 O(logN),所以小于的程度没有大于一个数量级
+ 红黑树更省空间，只需要一个额外的 bit 来存储颜色信息。
+ 读取操作比较频繁，而插入删除操作比较少的场景下，使用 AVL 树，否则使用红黑树。

### 什么是 B 树？它有什么作用？
+ 介绍
    + B 树是一种自平衡多路查找树，也被称为 B- 树
+ 定义
    + 一个 M 阶 B 树，是一棵平衡的 m 路搜索树，它或者是空树，或者满足下列性质的树
        1. 根节点至少有两个子女；
        2. 每个根节点所包含的关键字个数 j 满足：m/2 - 1 <= j <= m-1 (m/2 取上限)
        3. 出根节点以外的所有节点（不包括叶子节点）的度数正好是关键字总数加一，故内部子树个数 k 满足： m/2 <= k <= m (m/2 取上限) 
        4. 所有叶子节点都位于同一层
+ 特性
    1. 关键字集合分布在整棵树中
    2. 任何一个关键字出现且只出现在一个节点中
    3. 搜索有可能在非叶子节点结束
    4. 其搜索性能等价于在关键字全集内做一次二分查找
    5. 自动层次控制
+ 应用场景
    + 用于磁盘文件组织，数据索引，和数据库索引

### 什么是 B+ 树
+ 介绍
    + B+ 树是一个基于 B- 树的 n 叉树的树数据结构，每个节点通常包含跟节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上的节点
+ 定义
    1. 有 n 棵子树的节点中含有 n 个关键字，每个关键字不保存数据，只用来索引，所有的数据都保存在叶子节点中
    2. 所有的叶子节点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子节点本身依关键字的大小，自小而大顺序链接
    3. 所有的非终端节点可以看成索引部分，节点中仅含子树（根节点）中最大（或最小）关键字
    4. 通常 B+ 树上有两个头指针，一个指向根节点，一个指向关键字最小的叶子节点
+ 性质
    + 能够保持数据的稳定有序，其插入与修改拥有较稳定的对数时间复杂度。
    + B+ 树中的所有数据都保存在叶子节点中，而且跟根节点和内部节点均只是充当控制查找的媒介，本身不代表数据。
    + B+ 树的非叶子节点不存储数据，仅仅存储索引
+ 应用场景
    + 用于磁盘文件组织，数据索引，和数据库索引

### B 树和 B+ 树有什么区别
+ B+ 树的平衡性质很好，

### 什么是 Trie 树？它有什么作用？
+ 介绍
    + 前缀树，也叫字典树，是一种有序树，用于保存关联数组，保存的值通常是字符串
+ 性质
    + 与二叉查找树不同，值不是直接保存在节点中，而是由节点在树中的位置决定
    + 一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。
    + Trie 树可以高效地存储字符串数据集中的键
+ 应用场景
    + 用于统计和排序大量字符串，如自动机

## 什么是哈希表（hash table）？它有什么作用？
+ hash table 是一种数据结构，通过将关键码映射到表中一个位置来访问记录，以加快查找的速度。
+ 哈希表提供了快速插入操作和查找操作，无论哈希表中有多少条数据，插入和查找的时间复杂度都是 O(1)

## 什么是堆（heap）？它有什么作用？
+ 堆是一种数据结构，它可以快速地进行查找、插入和删除等操作
+ 堆可以用来实现队列，堆排序等算法

## 什么是堆排序（heap sort）？它有什么特点？
+ 一种基于堆的排序算法，将待排序列构造成一个大顶堆，然后将堆顶元素与末尾元素交换位置，再重新调整堆，直到整个序列有序。
+ 特点
    - 是一种不稳定的排序算法
    - 排序时间复杂度为 O(nlogn),最坏的时间复杂度和平均时间复杂度都是 O(nlogn),最好的时间复杂度是 O(n),空间复杂度O(1)
    - 需要额外的空间去存储堆，因此空间开销大

## 什么是拓扑排序（topological sorting）？它有什么作用？
+ 拓扑排序是一种对有向无环图进行排序的算法。它可以解决一些依赖问题，比如编译器中的模块依赖关系、任务调度中的任务依赖关系等
+ 拓扑排序的基本思想是将有向无环图的结点排成一个线性序列，使得对于任何一条有向边(u,v)，都有 u 在 v 前。
    - 如果拓扑排序中存在环，则无法进行拓扑排序
+ 拓扑排序的时间复杂度是  O(|u|+|v|)

## 什么是并查集（union-find set）？它有什么作用？
+ 并查集是一种树形数据结构，主要是处理一些不相交集的合并及查询问题。
+ 并查集的主要作用是求连通分支数。

##  什么是最短路径算法（shortest path algorithm）
+ 用于计算图中两个节点之间的最短路径算法。
###  Dijkstra 算法
+ 要求图中权值非负
+ 从起始点开始，采用贪心算法的策略，每次遍历到起始点距离最近且没有访问过的顶点的邻接节点，直到扩散到终点为止
+ 时间复杂度 O(|V|^2)

### Bellman-Ford 算法
+ 适应一般情况，即图中边存在负权边的情况
+ 计算带权有向图中单源最短路径
+ 从起点开始，采用贪心算法的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。

### Floyd-Warshall 算法
+ 一种用于计算带权有向图中任意两点之间的最短路径的算法。该算法利用动态规划的思想将计算的时间复杂度降低为 O(v^3)
    + 最短路路径的本质就是比较在两个顶点之间中转点，比较经过与不经过中转点的距离哪个更短
+ 能处理带负权边的图，但是不能处理存在负权边的图

## 什么是最小生成树算法（minimum spanning tree algorithm）？
+ 一种用于计算无向图中的最小生成树的算法。
+ 最小生成树指的是在一个连通的无向图中，找到一颗包含所有节点的生成树，并使得这颗生成树的边权值最小。
### Prim 算法
+ 从顶点的角度出发，每次选择一个离当前生成树最近的顶点，并将其相邻的边加入到生成树中。

### Kruskal 算法
+ 从边的角度出发，每次选择一条权重最小，但是不会形成环的边加入到生成树中

---

## 掌握 C++ 中的排序算法，例如快速排序、归并排序等。
### [快速排序](./quickSort.cpp)
### [归并排序](./mergeSort.cpp)
### [冒泡排序](./bubbleSort.cpp)
### [堆排序](./heapSort.cpp)
### [选择排序](./selectSort.cpp)
### [希尔排序](./shellSort.cpp)
### [插入排序](./insertSort.cpp)

## 掌握 C++ 中的查找算法，例如二分查找、哈希表等。
### [二分查找](./binaryTree.cpp)
### [建树](./createTree.cpp)
### [中序遍历二叉树](./inorderTraversal.cpp)
### [层次遍历二叉树](./levelOrder.cpp)
### [后序遍历二叉树](./postorderTraversal.cpp)
### [先序遍历二叉树](./preorderTraversal.cpp)
### [平衡二叉树](./AVL.cpp)

