# DataStruct

## 数据结构
### 什么是数据结构（data structure）？C++ 中常见的数据结构有哪些？
+ 数据结构是计算机科学中一种基础概念，它指的是数据对象以及他们之间的关系，包括这些对象之间执行的操作
+ C++ 常见的数据结构有：数组、链表、哈希表、栈、队列、树、图

### 时间复杂度和空间复杂度
#### 解释 C++ 中的时间复杂度和空间复杂度。
+ 时间复杂度和空间复杂度是用来衡量算法效率的两个指标
+ 时间复杂度指的是算法执行所需要的时间，通常以大 O 符号表示法来表示时间的复杂度。常用的时间复杂度量级有常数阶 O(1), 对数阶 O(logn), 线性阶 O(n), 线性对数阶 O(nlogn), 平方阶 O(n^2), 立方阶 O(n^3), K 次方阶 O(n^k), 指数阶 O(2^n)
+ 空间复杂度指的是算法执行所需的内存空间大小，通常用 S(n)=O(f(n)),常见的空间复杂度量级有常数阶 O(1),线性阶 O(n), 平方阶 O(n^2)

#### 什么是 O(n)、O(nlogn)、O(n^2) 等时间复杂度表示法？它们分别代表什么含义？
+ 时间复杂度是算法性能的一种度量，它衡算的是算法运行时间与输入规模之间的关系。
+ O(n) 表示算法的运行时间与输入规模 n 成这个正比
+ O(nlogn) 表示算法运行时间与输入规模 n 与 nlogn 成正比
+ O(n^2) 表示算法运行时间与输入规模 n 与 n^2 成正比

## 数组


## 链表

### 链表反转

### 单链表反转，删除指定的链表的一个节点

### 单链表如何判断有环

## 哈希表
### hash 用在什么地方，解决 hash 冲突几种方法？负载因子是什么？

### 什么是哈希表（hash table）？它有什么作用？
+ hash table 是一种数据结构，通过将关键码映射到表中一个位置来访问记录，以加快查找的速度。
+ 哈希表提供了快速插入操作和查找操作，无论哈希表中有多少条数据，插入和查找的时间复杂度都是 O(1)

### hashtable 中解决冲突的方法？
+ 线性探测法：使用 hash 函数计算出的位置如果已经被占用了，则向后依次寻找，找到表尾则回表头，直到寻找到一个空位；
+ 开链法：每个表格维护一个 list， 如果hash 函数计算出的格子相同，就按顺序方法放到 list 中；
+ 再散列：发生冲突时使用另一种 hash 函数再计算一个地址出来，直至不冲突为止；
+ 二次探测：发生冲突后按照 步长的平方数距离依次寻找空位；
+ 公共溢出区：发生冲突后把数据放到该区中；

## 栈

## 队列

### 实现一个循环队列

## 树

### 搜索二叉搜索树的的增删改查
// TODO

### 求一个树的最大距离

### n 个节点的二叉树的所有不同构的个数

### 二叉树的公共祖先，排序二叉树的公共祖先

### 把一个二叉树原地变成一个双向链表

### 找出二叉树的所有路径

### 二叉树中寻找每一层中最大值

### 求树的最大深度，最小深度，是否是平衡树

### 二叉树中叶子节点个数

### 交换左右孩子、二叉树镜像

### 两个二叉树是否相等

### 是否为完全二叉树

### 是否为对称二叉树

### 判断 B 是否是 A 的子树

### 二叉树创建

### 二叉树搜索

### 平衡二叉树

### huffman （哈夫曼）编码、构建 huffman 树

### 什么是红黑树（red-black tree）？它有什么作用？
+ 概念
    + 红黑树是一种自平衡的二叉查找树，通过一些性质的定义，将任意节点的左右子树高度差控制在一定范围内，以达到平衡状态。
+ 性质
    + 它是二叉排序树：
        + 若左子树不空，则左子树上所有节点的值均小于或等于它的根节点的值；
        + 若右子树不空，则右子树上所有节点的值均大于或等于它的根节点的值；
        + 左右子树也分别为二叉排序树；
    + 它满足以下几点要求：
        + 树中所有节点非红即黑；
        + 根节点必为黑节点；
        + 红节点的子节点必为黑（黑节点的子节点可为黑）；
        + 每个红色节点必须有两个黑色子节点
        + 从根到叶节点的任何任何路径上黑节点的点数相同；
+ 时间复杂度
    + 增删查改的时间复杂度都是 O(logn)
+ 应用场景
    + C++ STL 的 map、set、multimap 等结构

### 什么是 AVL 树？它有什么作用？
+ 概念
    + AVL 是一个自平衡二叉树，其中任何节点的两棵子树的最大高度差为 1，因此也被称为高度平衡树
+ 时间复杂度
    + 查找，插入，和删除的平均和最坏时间复杂度是 O(logn)
+ 性质
    + AVL 树是一颗自平衡二叉树
    + 任何节点的两棵子树的最大高度差为 1，因此也被称为高度平衡树
    + 在 AVL 树中，查找，插入，和删除的平均和最坏时间复杂度是 O(logn)
    + 主要作用是保持树的高度最小，从而树的查找效率最高
+ 缺点
    + 插入和删除都需要进行更多的旋转操作，因此相较于红黑树，AVL 树的实现难度更大
    + AVL 树需要维护每个节点的平衡印子，因此需要更多的空间来存储平衡因子，这会导致 AVL 树的空间开销更大
    + 在频繁插入和删除操作时，AVL 树需要更多的旋转操作来保持平衡，因此相较于红黑树，AVL 树的性能可能会受到影响
+ 应用场景
    + Windows 对进程地址空间的管理
    + Windows NT 内核

### 红黑树比 AVL 有什么优点
+ 红黑树的平衡性能更好。红黑树的平衡策略更加灵活，可以通过颜色变化来实现平衡，AVL 需要频繁的旋转节点
+ 红黑树的插入和删除操作平均的时间复杂度要小于 AVL 。红黑树和AVL的操作时间复杂度都是 O(logN),所以小于的程度没有大于一个数量级
+ 红黑树更省空间，只需要一个额外的 bit 来存储颜色信息。
+ 读取操作比较频繁，而插入删除操作比较少的场景下，使用 AVL 树，否则使用红黑树。

### 什么是 B 树？它有什么作用？
+ 介绍
    + B 树是一种自平衡多路查找树，也被称为 B- 树
+ 定义
    + 一个 M 阶 B 树，是一棵平衡的 m 路搜索树，它或者是空树，或者满足下列性质的树
        1. 根节点至少有两个子女；
        2. 每个根节点所包含的关键字个数 j 满足：m/2 - 1 <= j <= m-1 (m/2 取上限)
        3. 出根节点以外的所有节点（不包括叶子节点）的度数正好是关键字总数加一，故内部子树个数 k 满足： m/2 <= k <= m (m/2 取上限) 
        4. 所有叶子节点都位于同一层
+ 特性
    1. 关键字集合分布在整棵树中
    2. 任何一个关键字出现且只出现在一个节点中
    3. 搜索有可能在非叶子节点结束
    4. 其搜索性能等价于在关键字全集内做一次二分查找
    5. 自动层次控制
+ 应用场景
    + 用于磁盘文件组织，数据索引，和数据库索引

### 什么是 B+ 树
+ 介绍
    + B+ 树是一个基于 B- 树的 n 叉树的树数据结构，每个节点通常包含跟节点、内部节点和叶子节点。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上的节点
+ 定义
    1. 有 n 棵子树的节点中含有 n 个关键字，每个关键字不保存数据，只用来索引，所有的数据都保存在叶子节点中
    2. 所有的叶子节点中包含了全部关键字的信息，及指向含这些关键字记录的指针，且叶子节点本身依关键字的大小，自小而大顺序链接
    3. 所有的非终端节点可以看成索引部分，节点中仅含子树（根节点）中最大（或最小）关键字
    4. 通常 B+ 树上有两个头指针，一个指向根节点，一个指向关键字最小的叶子节点
+ 性质
    + 能够保持数据的稳定有序，其插入与修改拥有较稳定的对数时间复杂度。
    + B+ 树中的所有数据都保存在叶子节点中，而且跟根节点和内部节点均只是充当控制查找的媒介，本身不代表数据。
    + B+ 树的非叶子节点不存储数据，仅仅存储索引
+ 应用场景
    + 用于磁盘文件组织，数据索引，和数据库索引

### B 树和 B+ 树有什么区别
+ B+ 树的平衡性质很好，

### 什么是 Trie 树？它有什么作用？
+ 介绍
    + 前缀树，也叫字典树，是一种有序树，用于保存关联数组，保存的值通常是字符串
+ 性质
    + 与二叉查找树不同，值不是直接保存在节点中，而是由节点在树中的位置决定
    + 一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。
    + Trie 树可以高效地存储字符串数据集中的键
+ 应用场景
    + 用于统计和排序大量字符串，如自动机

### 什么是堆（heap）？它有什么作用？
+ 堆是一种树形数据结构，它可以快速地进行查找、插入和删除等操作
+ 堆可以用来实现队列，堆排序等算法

### 什么是堆排序（heap sort）？它有什么特点？
+ 一种基于堆的排序算法，将待排序列构造成一个大顶堆，然后将堆顶元素与末尾元素交换位置，再重新调整堆，直到整个序列有序。
+ 特点
    - 是一种不稳定的排序算法
    - 排序时间复杂度为 O(nlogn),最坏的时间复杂度和平均时间复杂度都是 O(nlogn),最好的时间复杂度是 O(n),空间复杂度O(1)
    - 需要额外的空间去存储堆，因此空间开销大

### 什么是并查集（union-find set）？它有什么作用？
+ 并查集是一种树形数据结构，主要是处理一些不相交集的合并及查询问题。
+ 并查集的主要作用是求连通分支数。


## 图

### 如何判断一个图是否联通

### 什么是拓扑排序（topological sorting）？它有什么作用？
+ 拓扑排序是一种对有向无环图进行排序的算法。它可以解决一些依赖问题，比如编译器中的模块依赖关系、任务调度中的任务依赖关系等
+ 拓扑排序的基本思想是将有向无环图的结点排成一个线性序列，使得对于任何一条有向边(u,v)，都有 u 在 v 前。
    - 如果拓扑排序中存在环，则无法进行拓扑排序
+ 拓扑排序的时间复杂度是  O(|u|+|v|)


###  什么是最短路径算法（shortest path algorithm）
+ 用于计算图中两个节点之间的最短路径算法。

### 深度优先遍历

### 宽度优先遍历

### Dijkstra 算法
+ 要求图中权值非负
+ 从起始点开始，采用贪心算法的策略，每次遍历到起始点距离最近且没有访问过的顶点的邻接节点，直到扩散到终点为止
+ 时间复杂度 O(|V|^2)

### Bellman-Ford 算法
+ 适应一般情况，即图中边存在负权边的情况
+ 计算带权有向图中单源最短路径
+ 从起点开始，采用贪心算法的策略，每次遍历到始点距离最近且未访问过的顶点的邻接节点，直到扩展到终点为止。

### Floyd-Warshall 算法
+ 一种用于计算带权有向图中任意两点之间的最短路径的算法。该算法利用动态规划的思想将计算的时间复杂度降低为 O(v^3)
    + 最短路路径的本质就是比较在两个顶点之间中转点，比较经过与不经过中转点的距离哪个更短
+ 能处理带负权边的图，但是不能处理存在负权边的图

### 什么是最小生成树算法（minimum spanning tree algorithm）？
+ 一种用于计算无向图中的最小生成树的算法。
+ 最小生成树指的是在一个连通的无向图中，找到一颗包含所有节点的生成树，并使得这颗生成树的边权值最小。
#### Prim 算法
+ 从顶点的角度出发，每次选择一个离当前生成树最近的顶点，并将其相邻的边加入到生成树中。

#### Kruskal 算法
+ 从边的角度出发，每次选择一条权重最小，但是不会形成环的边加入到生成树中


## C++ 中的排序算法
### 快速排序
### 归并排序
### 冒泡排序
### 堆排序
### 选择排序
### 希尔排序
### 插入排序

## C++ 中的查找算法
### 顺序查找
### 二分查找
### 插值查找
### 斐波那契查找
### 数表查找
### 分开查找
### 哈希查找

## 算法问题
### TopK 问题
### 求逆序对
### 海量数据的 bitmap 使用原理
+ BitMap 解决海量数据寻找丢失、判断个别元素是否在海量数据当中的问题；
+ 40 个亿 int 占 （40*10^9 * 4 / 1024(KB)/1024(MB)/1024()GB） 约 14.9G，很显然内存放不下这么大的数据。但是用位图为表示即，用一位来表示一个int值需要 40亿/8/1024/1024 约为 476.83MB

### 最长公共子序列（动态规划）

### 分治与递归（归并算法的两种实现）

### 背包问题（贪心算法）

### 回文字符串（动态规划）

### 字符串匹配（KMP 算法）

### 求一个数开根号（二分）

### 万个数找到第20个大的数（堆排序）

### 字符串最长不重复字串

### 求 1-n 的子集
    + 123，有 1，2，3，12，13，23，123
