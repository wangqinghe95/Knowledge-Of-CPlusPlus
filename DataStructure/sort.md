# 常见的排序算法

1. 冒泡排序
    + 过程：遍历若干次要排序的数组，每次遍历时会从前往后依次比较相邻的两个数大小；如果这两个数的顺序不符合要求则交换他们的位置，每次遍历都可以将一个遍历的范围中最值放到数组最后
    + 时间复杂度：
        - 最差：O（N^2)
        - 平均：O（N^2)
    + 空间复杂度：
        - O(1)
    + 稳定性：
        - 稳定算法

---

2. 快速排序
    + 过程：每次选择一个元素并且将整个数组以选择的元素为基点分成两个部分。小于该元素的放在左边，大于该元素的放在右边；
    + 时间复杂度：
        - 最差：O(N^2)
        - 平均：O（NlogN）
    + 空间复杂度：
        - O（logN）~O(n)
    + 稳定性：
        - 稳定算法

---

3. 插入排序
    + 插入排序:每一步将一个待排序的数据插入到前面已经拍好序的有序序列中，直到插完所有元素为止；
    + 时间复杂度：
        - 最差：O(N^2)
        - 平均：O(N^2)
    + 空间复杂度：
        - O(1)
    + 稳定性：
        - 稳定算法

---

4. 希尔排序
    + 过程：将待排序的数组元素按下标的一定增量分组，分为多个子序列；然后对各个子序列进行直接插入排序； 然后依次缩减增量再进行排序，直至增量为 1 时，进行最后一次直接插入排序；
    + 时间复杂度：
        - 最坏：O(NlogN)~O(N^2);取决于增量序列
        - 平均：O(NlogN)
    + 空间复杂度：
        - O(1)
    + 稳定性：
        -不稳定算法

---

5. 选择排序
    + 选择排序：每次从待排序的集合中选择最小（大）的元素放到已排序的序列末尾，直至排序结束；
    + 时间复杂度：
        - 最坏：O(N^2)
        - 平均：O(N^2)
    - 空间复杂度：
        - O(1)
    + 稳定性：
        - 不稳定

---

6. 堆排序
    + 算法思想：
        1. 将待排序的序列构造成一个大顶堆，根据大顶堆性质，当前堆的根结点（堆顶）就是序列中最大的元素；
        2. 将堆顶元素和最后一个元素交换，再将剩下的结点重新构造成一个大顶堆；
        3. 重复上述步骤，每一次构建大顶堆都可以获取到一个最大值，将它放到尾部，就可以获取到一个有序序列了；
    + 时间复杂度：
        - 最坏：O（NlogN）
        - 平均：O(NlogN)
    + 空间复杂度：
        - O(1)
    + 稳定性：
        - 不稳定

---

7. 归并排序
    + 归并排序：先递归分解数组将数组分成若干个子数组，然后再对子数组进行排序，合并，最终完成对整个数组的排序；
    + 时间复杂度：
        - 最坏：O(N^2)
        - 平均：O（NlogN）
    + 空间复杂度：
        - O(n)
    + 稳定性：
        - 稳定

---

8. 基数排序
    
9. 桶排序

# 代码实现：