# 动态绑定和静态绑定
+ 多态的实现原理：
    + C++编译器为每个含虚函数的类提供一个虚表，虚表用来记录虚函数的地址，即虚表中的指针指向虚函数的地址。当子类继承父类时，并且子类重写父类虚函数，虚表中的虚函数地址会更新为子类中的虚函数地址，虚表地址指向子类虚函数，通过父类指针调用子类重写的虚函数时，以此实现多态。
+ 多态的实现
    1. 每个有虚函数（有虚函数的类的派生类）的类都有一个虚函数表，该的任何对象中都放着该虚函数表的指针。
    2. 虚函数表是编译器生成的，程序运行时被载入内存，一个类的虚函数表中列出了该类的所有虚函数地址。

```
class A
{
public:
    virtual void func() {}
    virtual void func2() {}
};

class B : class A
{
public:
    void func() {}
};

int main() {
    A* pa = new A;
    pa->func();
    A* pb = new B;
    pb->func();
}
```

+ 虚函数调用过程：
    1. 取出 pa 指针所指位置的前4个字节（64位系统取前 8 位），即对象所属类的虚函数表的地址。pa 指向的类A的虚函数表地址，而pb指向的是类B的对象，那么这个地址就是类B的虚函数表地址。
    2. 根据虚函数表的地址找到虚函数表，在其中查找要调用的虚函数的位置。

+ 虚函数内存分布：
    1. 虚函数指针位于类实例中的最前面位置（前4个字节，或8个字节）；
    2. 虚函数按照其声明顺序放于表中；父类的虚函数在子类的虚函数之前；
    3. 在虚函数无重写的情况下，子类和父类共用一个虚表，在多重继承中子类和第一个父类共享；
    4. 虚函数指针的在类的构造函数中会被编译器隐式地做个赋值操作。虚函数表是在编译时期就已经指定好了存储位置，存储的位置是只读数据段(.rodata)
    5. 当调用虚函数时，首先通过栈区的实例化指针找到堆区的类的实例地址，然后再通过实例内存开头的虚函数指针找到位于 .rodata 段的虚函数表，再根据偏移量找到想要调用的虚函数地址，最后跳转到代码段的函数地址执行目标函数。

+ 虚函数的问题：
    1. 任何妄图使用父类指针想调用子类中未覆盖父类的函数成员的行为都会被编译器视为非法。
    2. 如果父类的虚函数是 private 或者 protected，但是这些非 public 的虚函数仍然会存在于虚函数表中，我们可以使用访问虚函数表的方式来访问这些非 public 的虚函数。
[](http://c.biancheng.net/view/267.html)

# 引用能否实现动态绑定，为什么可以实现
+ 可以，引用在创建的时候必须要初始化，在访问虚函数时，编译器会根据所绑定的对象类型决定要调用哪个函数。主要只能调用虚函数

```
#include<iostream>
using namespace std;

class Base{
    public:
        virtual void fun(){
            cout << "base::func()" << endl;
        }
};

class Son:public Base{
    public:
        virtual void fun(){
            cout << "son::func" << endl;
        }
        void func(){
            cout << "son:: not virtual function" << endl;
        }
};

int main(){
    Son s;
    Base& b = s;
    s.fun();    //son::func
    b.fun();    //son::func
    return 0;
}
```

**说明：**实际上还是虚函数具有的动态绑定，虚函数的动态绑定延迟到运行期赋值给引用