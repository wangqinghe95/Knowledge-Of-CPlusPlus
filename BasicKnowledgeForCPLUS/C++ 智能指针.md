<!--
 * @Description:
 * @Version: 2.0
 * @Autor: wanghao
 * @Date: 2021-09-24 11:12:18
 * @LastEditors: wanghao
 * @LastEditTime: 2021-09-28 10:24:27
-->
## 智能指针的作用
+ 为了方便管理堆内存，C++11 引入了智能指针的概念；
+ shared_ptr：多个指针指向相同的对象：shared_ptr 使用引用计数，每个shared_ptr 的拷贝都指向相同的内存，每使用一次，内部的引用计数就加一，每析构一次，引用次数就减一。减为零时，自动删除所指向的堆内存。shared_ptr 内部的引用计数是线程安全的，但是对象的读取都是需要加锁的；
+ 初始化：智能指针是一个模板类，可以指定类型，传入指针通过构造函数初始化，也可以使用 make_shared 函数初始化。不能直接将指针赋值给一个智能指针。
+ 拷贝和赋值：拷贝使得对象的引用计数加一，赋值使得原对象引用计数减一，当计数为零时，自动释放内存，后来指向的对象引用计数加以，指向后来的对象；
+ unique_ptr：唯一拥有其所指对象，同一时刻只能有一个 unique_ptr 指向给定对象（通过禁止拷贝语义，只有移动语义来实现）。相比于原始指针 unique_ptr 用于其 RAII 的特性，使得在出现异常的情况下，动态资源能得到释放。unique_ptr 指针本身的生命周期：从 unique_ptr 指针创建时开始，直到离开作用域。离开作用域时，若其指向对象，则将其所指对象销毁（默认使用 delete 操作符，用户可指定其他操作），unique_ptr 指针与所指对象的关系：在智能指针生命周期内，可以改变智能指针所指对象，如创建智能指针时通过构造函数指定，通过 reset 方法重新指定、通过 release 方法释放所有权、通过移动语义转移所有权。
+ 智能指针将一个计数器与类指向的对象关联，引用计数跟踪该类有多少个对象共享同一指针。每次创建类的新对象时，初始化指针并将引用计数置一；当对象作为另一对象的副本而创建时，拷贝构造函数指针并增加与之对应的引用计数；对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数减至零，则删除对象），并增加右操作数所指对象的引用计数；调用析构函数时，构造函数减少引用计数（如果引用计数减至零，则删除基础对象）；
+ weak_ptr 是一种不控制对象生命周期的智能指针，它指向一个 shared_ptr 管理的对象，进行该对象的内存管理是那个强引用的 shared_ptr 。weak_ptr 只是提供了对管理对象的一个访问手段。weadk_ptr 设计的目的就是为了配合 shared_ptr 而引入的一种智能指针协助 shared_ptr 工作，它只可以从一个 shared_ptr 或另一个 weak_ptr 对象构造，它的析构和构造函数不会引起计数的增加或减少；

---

# 智能指针的原理
+ 原理：智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏，动态分配的资源交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源；

# 常用的智能指针
1. shared_ptr
    + 实现原理：采用引用计数的方法，允许多个智能指针指向同一个对象，每当多一个智能指针指向该对象时，指向该对象的所有智能指针内存的引用计数加一，每当减少一个智能指针指向对象时，引用计数减一，当计数为零时，自动释放动态分配的资源；
    + 实现过程：
        1. 智能指针将一个计数器与类指向的对象相关联，引用计数器跟踪共有多少个类对象共享同一指针；
        2. 没创建类的新对象时，初始化新指针并将引用计数置为1；
        3. 每当对象作为另一对象的副本而创建时，拷贝构造函数指针指针并增加与之对应的引用计数；
        4. 对一个对象进行赋值时，赋值操作数减少左操作数所指对象的引用计数（如果引用计数减至0，则删除对象），并增加右操作数所指对象的引用计数；
        5. 调用析构函数时，构造函数减少引用计数（如果引用计数减至零，则删除基础对象）；
2. unique_ptr：
    + unique_ptr 采用的是独享所有权语义，一个非空的 unique_ptr 总是拥有它所指向的资源。转移一个 unique_ptr 将会把所有权全部从源指针转移给目标指针，源指针被置空；所以 unique_ptr 不支持普通的拷贝和赋值操作，不能用在 STL 标准容器中；局部变量的返回值除外（因为编译器知道要返回的对象将被销毁）；如果你拷贝一个 unique_ptr，那么拷贝结束后，这两个 unique_ptr 都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致内存崩溃；
3. weak_ptr：弱引用
    + 引用计数有一个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。需要使用 weak_ptr 打破环形引用。weak_ptr 是一个弱引用，它是为了配合 shared_ptr 而引入的一种智能指针，它只引用不计数，如果一块内存被 shared_ptr 和 weak_ptr 同时引用，当所有 shared_ptr 析构了之后，不管 weak_ptr 是否还引用该内存，内存也会被释放。所以 weak_ptr 不保证它所指向的内存一定是有效的，在使用之前使用函数 lock() 检查 weak_ptr 是否为空指针；
4. auto_ptr：主要为了解决“有异常抛出时而发生内存泄漏”问题，因为发生异常而无法正常释放内存；
 
auto_ptr 有拷贝语义，拷贝后源对象变得无效，这可能引发很严重的问题；而 unique_ptr 则无拷贝语义，但提供了移动语义，这样的错误不再可能发生，因为很明显必须使用 std::move() 进行转移。auto_ptr 不支持拷贝和赋值操作，不能在STL标准容器中。STL容器中的元素经常要支持拷贝、复制操作，在这过程中auto_ptr会传递所有权，所以不能在STL中使用；

# 补充：2021/10/14

+ weak_ptr：
    + 原理：它指向的是一个 shared_ptr 管理的对象，只能从 share_ptr 和另外一个 weak_ptr 对象构造，它的构造和析构不会引起引用计数的增加和减少；
    + 使用：weak_ptr 没有重载 * 和 -> 符号，所以 weak_ptr 使用只能使用 . 获取成员数据。但是可以使用 lock 来获得一个可用的 shared_ptr 对象。

+ 注：
    1. 在指针操作中，& 是取地址符号，* 是间接寻址运算符
    2. 指针取数据 A->b  ; 结构体变量取值 A.b
