# 数组名和指向数组首地址指针的区别

## 数组名和指针
+ 二者都可以通过增减偏移量来访问数组中的元素；
+ 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增自减的操作；
+ 当数组名当作形参传递给调用函数后，就退化成了一般指针了，也就有了自增自减的操作了。但sizeof运算符不能再得到原数组的大小了；

## 区别
1. 类型
    + 数组名是一个常量，代表的是该数组第一个元素在内存中的地址
    + 而数组首地址指针是一个变量，存储的数据是该数组第一个元素在内存中的地址
2. 运算
    + 数组名是常量，不能进行数值运算
    + 数组首地址是变量，可以进行数值运算
        - 进行的数值运算就是访问该数组不同的元素地址
3. 数值访问
    + 对于数组元素的访问，数组名可以以 `arr[i]` 或者 `*(a+i)` 格式访问，也支持赋值 `pointer* p = &arr[index]`
    + 数值首地址访问数组元素只能以 `*(p+[index])` 访问 arr[index] 处的元素
    ```

## 代码
+ 代码
```

#include<cstdio>

int main(){
    int a[10];
    printf("a:\t%p\n",a);
    printf("&a:\t%p\n",&a);
    printf("a+1:\t%p\n",a+1);
    printf("&a+1:\t%p\n",&a+1);
    
    return 0;
}
```

+ 运行结果：
```    
a:      0x7ffcbf68b6f0
&a:     0x7ffcbf68b6f0
a+1:    0x7ffcbf68b6f4
&a+1:   0x7ffcbf68b718
```

+ 分析
    1. a 是数组名，&a 是指向数组首地址的指针，他们的值是一样的
    2. 但是 a+1 增加 4（一个 int 大小的距离），(&a + 1) 则增加了 40 个字节（10个 int 大小的距离）

+ 总结：
    + a 和 &a 都是数组的首元素地址，但是他们的类型不一样；
    + a 表示 &a[0]:即对数组首地址取地址，(a+1) 表示(首地址 + sizeof(元素类型))
    + &a 虽然值为数组首元素地址，但是它的类型为：(类型(*)[数组元素个数]), 所以(&a+1)大小为（首地址+sizeof(a)）

## 数组和指针的区别
+ 数组在内存中是连续存放的，开辟一块连续的内存空间；数组所占存储空间是 sizeof(数组名)；数组大小：sizeof(数组名)/sizeof(数组元素数据类型)；
+ 用运算符 sizeof 可以计算出数组的容量(字节数)。对于指针，使用 sizeof 得到的一个指针变量的字节数，不是指针所指的内存容量；
+ 编译器为了简化对数组的支持，实际上是利用指针实现了对指针的支持，具体来说，就是将表达式的数组元素引用转换成为指针加偏移量的引用；
+ 在向函数传递参数时，如果实参是一个数组，那么用于接收的形参为对应的指针，也就是传递过去的是数组的首地址而不是整个数组，能够提高效率；
+ 在使用下标的时候，两则的用法相同，都是原地址加上下标值，不过数组的原地址就是数组首元素的地址是固定的，指针的原地址就不是固定的。