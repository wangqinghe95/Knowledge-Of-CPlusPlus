# C++ 多态性

## 虚函数
### 虚函数
1. 定义
    + 使用 virtual 关键字修饰的类成员函数。
2. 作用
    + 允许使用基类指针来调用子类的函数，从而实现多态
3. virtual
    + virtual 关键字会被隐式继承，所以当一个成员函数被声明为虚函数以后，其派生类的重写的基类函数都会被默认为虚函数
    + 派生类重写 virtual 修饰的基类函数，需要相同的函数名加上相同的形参列表

### 纯虚函数
1. 定义
    + 在虚函数声明的结尾加上一个 <=0>，表明此函数为纯虚函数
    + 纯虚函数没有函数体，只有函数声明
2. 介绍
    + 纯虚函数的函数指针也会被存到虚函数表中，但是函数指针的值是 0，而具体的虚函数的函数指针的值在虚函数表中是具体的地址值
    + 声明了纯虚函数的类是一个抽象类，这种类无法实例化
    + 如果派生类中没有对基类的纯虚函数进行重写，则该函数在派生类中仍然是纯虚函数
3. 作用
    + 为了实现一个接口，起到一个规范的作用，规范继承这个类必须实现这个函数
    + 在基类中为派生类保留一个函数的名字，以便派生类根据需要对它进行定义和重写

### 虚函数表
1. 定义
    + 每个包含虚函数的类都有一个虚函数表，该类所有实例化对象的内存中都放着一个指向虚函数表的指针 vptr
2. 介绍
+ 虚函数表生成时间
    + 虚函数表是编译器在编译期间生成的，其中虚函数替换也是发生在这个期间；
+ 虚函数表内容
    + 虚函数表，是存储类成员函数指针的数据结构；
+ 虚函数表大小
    + 虚函数个数在编译时期就可以确定，所以虚函数表大小也是可以在编译时期确定；
+ 虚函数表存储地址
    + 虚函数表位于只读数据段，也就是 C++ 内存模型中的常量区；虚函数代码位于代码区
+ 虚指针初始化时间
    + 虚指针会在含有虚函数的类的构造函数执行时初始化，位于对象内存布局的最前面

## C++ 多态
### 多态定义
+ 在基类的函数前加上 virtual 关键字，在派生类中重写该函数，运行时会根据对象的实际类型来调用对应的函数。
    + 当父类指针（引用）指向父类对象时，调用父类中定义的虚函数
    + 当父类指针（引用）指向子类对象时，调用子类中定义的虚函数

### 多态的条件
1. 要有继承
2. 要有虚函数在子类中被重写
3. 父类指针或者引用指向子类

### 多态的实现
1. 实现原理 
    + C++ 编译器为每个含虚函数的类实例生成一个虚表，虚表用来记录该实例对应的类中虚函数的地址，即虚表中的指针指向虚函数的地址。当子类继承父类时，子类回重写父类的虚函数，虚函数表中的虚函数地址也会更新为子类的虚函数地址，通过父类指针调用子类重写的虚函数时，就实现了多态。
2. 实例代码
+ C++ 多态代码示例：
```
class A
{
public:
    virtual void func() {}
    virtual void func2() {}
};

class B : class A
{
public:
    void func() {}
};

int main() {
    A* pa = new A;
    pa->func();
    A* pb = new B;
    pb->func();
}

```

+ C 模拟 C++ 多态实现
```
#include<stdio.h>

typedef void (*FUN)();

typedef struct _A
{
    FUN _fun;
    int _a;
}A;

typedef struct _B
{
    A _a_;
    int _b;
}B;

void _fA()
{
    printf("_A:_func()\n");
}

void _fB()
{
    printf("_B:_func()\n");
}

void test()
{
    A a;
    B b;
    a._fun = _fA;
    b._a_._fun = _fB;

    A* pA = &a;
    pA->_fun();
    pA = (A*)&b;
    pA->_fun();
}

int main()
{
    test();

    return 0;
}

```

3. 虚函数调用过程
+ 虚函数调用过程：
    1. 取出 pa 指针所指位置的前4个字节（64位系统取前 8 位），即对象所属类的虚函数表的地址。pa 指向的类A的虚函数表地址，而pb指向的是类B的对象，那么这个地址就是类B的虚函数表地址。
    2. 根据虚函数表的地址找到虚函数表，在其中查找要调用的虚函数的位置。
+ 虚函数内存分布：
    1. 虚函数指针位于类实例中的最前面位置（前4个字节，或8个字节）；
    2. 虚函数按照其声明顺序放于表中；父类的虚函数在子类的虚函数之前；
    3. 在虚函数无重写的情况下，子类和父类共用一个虚表，在多重继承中子类和第一个父类共享；
    4. 虚函数指针的在类的构造函数中会被编译器隐式地做个赋值操作。虚函数表是在编译时期就已经指定好了存储位置，存储的位置是只读数据段(.rodata)
    5. 当调用虚函数时，首先通过栈区的实例化指针找到堆区的类的实例地址，然后再通过实例内存开头的虚函数指针找到位于 .rodata 段的虚函数表，再根据偏移量找到想要调用的虚函数地址，最后跳转到代码段的函数地址执行目标函数。


### 静态多态和动态动态
1. 静态多态
    + 在编译时期，编译器会根据实参类型决定去调用合适的函数，如果没有合适的函数，就会发出警告或者报错
    + 如重载，非虚函数重写
2. 动态多态
    + 在程序运行时根据基类的引用或者指针指向的对象来确定具体需要调用哪一个类的虚函数
    + 虚函数重写，switch/if语句

### 虚析构函数
1. 定义
    + 用 virtual 关键词修饰析构函数，称为虚析构函数
2. 意义
    + 当父类指针指向子类对象时，通过父类指针去释放所有子类的内存空间，防止内存泄露

## 虚函数相关
1. 构造函数可以声明为虚函数吗
+ 不能，因为虚函数表指针的初始化时间是在构造函数执行完之后

2. 析构函数时候可以声明为虚函数？
+ 可以，并且建议将含有虚函数的基类的析构函数都声明为虚函数，防止在 delete 指向子类对象的父类指针时，产生资源泄露

3. 构造函数中可以调用虚函数吗，如果可以，会发生多态吗
+ 构造函数中可以调用虚函数，但是不推荐，因为在构造函数期间，对象的虚函数表指针未完全初始化，调用虚函数可能会导致未定义的行为
+ 如果调用了一个虚函数，那么它会以静态绑定的方式调用，即它将调用构造函数所属类的版本，而不是派生类的版本。所以不会发生多态行为。

4. 析构函数中可以调用虚函数吗，如果可以，会发生多态吗？
+ 不能调用，且不会发生多态
+ 析构函数执行时，虚函数表指针已经被销毁了。

5. 类继承中，构造函数和析构函数调用顺序
+ 构造时，先调用父类的构造函数，在调用子类的构造函数
+ 析构时，先调用子类的析构函数，再调用子类的析构函数

## C++ 多态是如何实现的？
1. 编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一个虚表，该表是一个一维数组，虚表中保存了虚函数的入口地址；
2. 编译器会在每个对象的前四个字节保存一个虚表指针，即 vptr,指向对象所属类的虚表。在构造时根据对象的类型区初始化虚指针 vptr，从而让 vptr 指向正确的虚表，从而在调用虚函数时，能找到正确的函数；
3. 所谓的合适时机就是在派生类定义对象时，程序会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时编译器只能找到父类，并为父类对象初始化虚表指针，令它指向父类的虚表，当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表；
4. 当派生类没有对基类的虚函数重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加到后面；
5. 这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写的情况进行动态的调用，从而实现多态性。