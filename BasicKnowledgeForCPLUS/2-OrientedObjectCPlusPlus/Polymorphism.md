# C++ 多态性

## 虚函数
### 虚函数
1. 定义
    + 使用 virtual 关键字修饰的类成员函数。
2. 作用
    + 允许使用基类指针来调用子类的函数，从而实现多态
3. virtual
    + virtual 关键字会被隐式继承，所以当一个成员函数被声明为虚函数以后，其派生类的重写的基类函数都会被默认为虚函数
    + 派生类重写 virtual 修饰的基类函数，需要相同的函数名加上相同的形参列表

### 纯虚函数
1. 定义
    + 在虚函数声明的结尾加上一个 <=0>，表明此函数为纯虚函数
    + 纯虚函数没有函数体，只有函数声明
2. 介绍
    + 纯虚函数的函数指针也会被存到虚函数表中，但是函数指针的值是 0，而具体的虚函数的函数指针的值在虚函数表中是具体的地址值
    + 声明了纯虚函数的类是一个抽象类，这种类无法实例化
    + 如果派生类中没有对基类的纯虚函数进行重写，则该函数在派生类中仍然是纯虚函数
3. 作用
    + 为了实现一个接口，起到一个规范的作用，规范继承这个类必须实现这个函数
    + 在基类中为派生类保留一个函数的名字，以便派生类根据需要对它进行定义和重写

### 虚函数表
1. 定义
    + 每个包含虚函数的类都有一个虚函数表，该类所有实例化对象的内存中都放着一个指向虚函数表的指针 vptr
2. 介绍
+ 虚函数表生成时间
    + 虚函数表是编译器在编译期间生成的，其中虚函数替换也是发生在这个期间；
+ 虚函数表内容
    + 虚函数表，是存储类成员函数指针的数据结构；
+ 虚函数表大小
    + 虚函数个数在编译时期就可以确定，所以虚函数表大小也是可以在编译时期确定；
+ 虚函数表存储地址
    + 虚函数表位于只读数据段，也就是 C++ 内存模型中的常量区；虚函数代码位于代码区
+ 虚指针初始化时间
    + 虚指针会在含有虚函数的类的构造函数执行时初始化，位于对象内存布局的最前面

## C++ 多态

### 多态定义
+ 在基类的函数前加上 virtual 关键字，在派生类中重写该函数，运行时会根据对象的实际类型来调用对应的函数。
    + 当父类指针（引用）指向父类对象时，调用父类中定义的虚函数
    + 当父类指针（引用）指向子类对象时，调用子类中定义的虚函数

### 多态的条件
1. 要有继承
2. 要有虚函数在子类中被重写
3. 父类指针或者引用指向子类

### 多态的实现
1. 实现原理 
    + C++ 编译器为每个含虚函数的类实例生成一个虚表，虚表用来记录该实例对应的类中虚函数的地址，即虚表中的指针指向虚函数的地址。当子类继承父类时，子类回重写父类的虚函数，虚函数表中的虚函数地址也会更新为子类的虚函数地址，通过父类指针调用子类重写的虚函数时，就实现了多态。

2. 多态实现过程
    1. 在 C++ 代码编译时期，当 C++ 编译器发现一个类有虚函数，会为该类生成一个隐藏的虚函数指针，排在所有类成员的第一位，就会将在 .rdata 段生成一个虚函数表，该表本质是一个一维数组，按照虚函数声明的顺序存放该类的所有的虚函数地址。
    2. 当 C++ 编译器发现一个类继承了一个有虚函数的父类，并且重写了某些虚函数，那么在生成自己的虚函数表时先继承所有的父类的虚函数，然后再将虚函数表中的被重写的虚函数地址替换成自己虚函数地址。同时也会生成一个虚函数指针。
    3. 当 C++ 程序被加载到内存中运行时，先去生成父类对象，给父类的成员函数分配内存空间，进入父类的构造函数，先初始化父类的虚函数指针，执行父类的构造函数。然后给子类做同样的初始化步骤。这样子类对象的虚函数指针就指向子类的虚函数表指针。
    4. 父类指针指向子类对象，即一个栈地址中，保存了一个指针，该指针类型是一个父类对象，该指针的值是子类对象的内存地址。当该指针调用一个虚函数时，CPU 先根据该指针所指向的地址找到对象地址，该对象地址的第一个指针就是虚函数指针，根据调用的函数，找到虚函数的偏移地址，如果该虚函数被子类重写，那么虚函数表中对应的虚函数地址就是子类的虚函数地址，如果没有被重写，那么调用的就是父类的虚函数。
    5. 按照上面描述，如果一个子类指针指向一个子类对象，该子类指针调用未重写的父类虚函数，其实也调用到了父类对象的函数中。

3. 实例代码
+ C++ 多态代码示例：
```
class A
{
public:
    virtual void func() {}
    virtual void func2() {}
};

class B : class A
{
public:
    void func() {}
};

int main() {
    A* pa = new A;
    pa->func();
    A* pb = new B;
    pb->func();
}

```

+ C 模拟 C++ 多态实现
```
#include<stdio.h>

typedef void (*FUN)();

typedef struct _A
{
    FUN _fun;
    int _a;
}A;

typedef struct _B
{
    A _a_;
    int _b;
}B;

void _fA()
{
    printf("_A:_func()\n");
}

void _fB()
{
    printf("_B:_func()\n");
}

void test()
{
    A a;
    B b;
    a._fun = _fA;
    b._a_._fun = _fB;

    A* pA = &a;
    pA->_fun();
    pA = (A*)&b;
    pA->_fun();
}

int main()
{
    test();

    return 0;
}

```

4. 虚函数调用过程
+ 虚函数调用过程：
    1. 取出 pa 指针所指位置的前4个字节（64位系统取前 8 位），即对象所属类的虚函数表的地址。pa 指向的类A的虚函数表地址，而pb指向的是类B的对象，那么这个地址就是类B的虚函数表地址。
    2. 根据虚函数表的地址找到虚函数表，在其中查找要调用的虚函数的位置。
+ 虚函数内存分布：
    1. 虚函数指针位于类实例中的最前面位置（前4个字节，或8个字节）；
    2. 虚函数按照其声明顺序放于表中；父类的虚函数在子类的虚函数之前；
    3. 在虚函数无重写的情况下，子类和父类共用一个虚表，在多重继承中子类和第一个父类共享；
    4. 虚函数指针的在类的构造函数中会被编译器隐式地做个赋值操作。虚函数表是在编译时期就已经指定好了存储位置，存储的位置是只读数据段(.rodata)
    5. 当调用虚函数时，首先通过栈区的实例化指针找到堆区的类的实例地址，然后再通过实例内存开头的虚函数指针找到位于 .rodata 段的虚函数表，再根据偏移量找到想要调用的虚函数地址，最后跳转到代码段的函数地址执行目标函数。


### 静态多态和动态动态
1. 静态多态
    + 在编译时期，编译器会根据实参类型决定去调用合适的函数，如果没有合适的函数，就会发出警告或者报错
    + 如重载，非虚函数重写
2. 动态多态
    + 在程序运行时根据基类的引用或者指针指向的对象来确定具体需要调用哪一个类的虚函数
    + 虚函数重写，switch/if语句

### 虚析构函数
1. 定义
    + 用 virtual 关键词修饰析构函数，称为虚析构函数
2. 意义
    + 当父类指针指向子类对象时，通过父类指针去释放所有子类的内存空间，防止内存泄露

## 虚函数相关
1. 构造函数可以声明为虚函数吗
+ 不能，因为虚函数表指针的初始化时间是在构造函数执行完之后

2. 析构函数时候可以声明为虚函数？
+ 可以，并且建议将含有虚函数的基类的析构函数都声明为虚函数，防止在 delete 指向子类对象的父类指针时，产生资源泄露

3. 构造函数中可以调用虚函数吗，如果可以，会发生多态吗
+ 构造函数中可以调用虚函数，但是不推荐，因为在构造函数期间，对象的虚函数表指针未完全初始化，调用虚函数可能会导致未定义的行为
+ 如果调用了一个虚函数，那么它会以静态绑定的方式调用，即它将调用构造函数所属类的版本，而不是派生类的版本。所以不会发生多态行为。

4. 析构函数中可以调用虚函数吗，如果可以，会发生多态吗？
+ 不能调用，且不会发生多态
+ 析构函数执行时，虚函数表指针已经被销毁了。

5. 类继承中，构造函数和析构函数调用顺序
+ 构造时，先调用父类的构造函数，在调用子类的构造函数
+ 析构时，先调用子类的析构函数，再调用父类的析构函数

6. delete 调用析构函数的过程
+ 当一个指针被 delete 时，该关键字会去调用该类型对应的析构函数。
+ 如果一个基类的析构函数被声明为虚函数，那么 delete 会先调用派生类的析构函数，再调用基类的析构函数
+ 如果一个基类的析构函数没有声明为虚函数，那么 delete 一个派生类对象时，就只会调用与指针类型相关的析构函数，这可能会导致派生类的部分成员没有正确析构，从而引起内存泄漏等问题。

## C++ 多态是如何实现的？
1. 编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一个虚表，该表是一个一维数组，虚表中保存了虚函数的入口地址；
2. 编译器会在每个对象的前四个字节保存一个虚表指针，即 vptr,指向对象所属类的虚表。在构造时根据对象的类型区初始化虚指针 vptr，从而让 vptr 指向正确的虚表，从而在调用虚函数时，能找到正确的函数；
3. 所谓的合适时机就是在派生类定义对象时，程序会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时编译器只能找到父类，并为父类对象初始化虚表指针，令它指向父类的虚表，当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表；
4. 当派生类没有对基类的虚函数重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加到后面；
5. 这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写的情况进行动态的调用，从而实现多态性。