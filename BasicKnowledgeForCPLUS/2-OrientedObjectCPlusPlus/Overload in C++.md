# C++ 重载

## 重载定义
+ C++ 允许同一个作用域中对某个函数或者运算符指定多个定义，即函数重载，运算符重载。
+ 重载声明：指定义一个在该定义域中已经声明过的函数名，但是它们的参数列表和实现不相同。
+ 重载决策：编译器会自动根据函数的参数类型，顺序，以及个数，来决定调用哪个最合适的重载函数或重载运算符。

## 函数重载
+ 在同一定义域中，可声明几个功能相似的同名函数，要求是它们的形参个数、类型或顺序必须不同。

## 运算符重载
+ C++ 大多数的内置运算符都可以重定义或重载。重载的运算符是带有特殊名称的函数
+ 函数的关键字 operator 和后面紧跟着的运算符符号组成，与函数重载一样，重载运算符有返回类型和参数列表。

### 类成员函数重载格式
```
Box operator+(const Box&);   // 类的成员函数，可以用 this 指针省却一个参数
Box operator+(const Box&, const Box&);  // 类的非成员函数
```

### 注意事项
1. 运算符重载不可以改变语法结构
2. 运算符重载不可以改变操作数个数
3. 运算符重载不可以改变优先级
4. 运算符重载不可以改变结合性

### 可重载的运算符
1. 算术运算符：+（加）、-（减）、*（乘）、/（除）、%（取模）
2. 关系运算符：==（等于）、!=（不等于）、<（小于）、>（大于）、<=（小于等于）、>=（大于等于）
3. 逻辑运算符：||（逻辑或）、&&（逻辑与）、!（逻辑非）
4. 单目运算符：+（正）、-（负）、*（指针）、&（取地址）
5. 自增自减运算符： ++(自增)、 --(自减)
6. 位运算符： |(按位或)、 &(按位与)、 ~(按位取反)、 ^(按位异或)、 <<(左移)、 >>(右移)
7. 赋值运算符：=, +=, -=, *=, /=, %=, &=, |=, ^=, <<=, >>=
8. 空间申请与释放： new, delete, new[], delete[]
9. 其他运算符：()(函数调用)、 ->(成员访问)、 ,(逗号)、 [](下标)

### 不可重载的运算符
1. 成员访问运算符
2. 成员指针访问运算符
3. 域运算符
4. 长度运算符
5. 条件运算符
6. 预处理运算符

## 类重载，重写，隐藏的区别
1. 重载是同一个类中同名函数之间的关系。要求同名函数的形参列表的类型，顺序，和数量不完全一样
2. 重写是父类和子类的同名函数之间的关系，主要是子类重新实现父类的被 virtual 修饰的函数，要求函数的返回值，函数名，参数列表都保持一致
3. 隐藏就是子类重新实现父类的同名函数，只要是同名的，父类非虚函数都会隐藏

### 代码
```
#include<iostream>
using namespace std;

class A{
    public:
        virtual void func(int a){
            cout << "A:: virtual " << a << endl;
        }
        void func2(int a){
            cout << "A:: no virtual " << a << endl;
        }
};

class B : public A{
    public:
        void func(int a){
            cout << "B:: override " << a << endl;
        }
        void func2(int a){
            cout << "B:: no override " << a << endl;
        }       
};  

int main(){
    A a;
    a.func(10);
    a.func2(20);

    B b;
    b.func(30);
    b.func2(40);

    A* c = &b;
    c->func(50);
    c->func2(60);

    A* e = nullptr;
    B* d = dynamic_cast<B*>(&a);
    if (nullptr == d){
        cout << "dynamic_cast is nullptr" << endl;
    }
    else
    {
        d->func(70);
        d->func2(80);
    }

    return 0;    
}

```

### 代码分析
1. 当派生类重写基类没有被 virtual 修饰的函数时，基类指针指向派生类对象时，此时该对象调用的函数是基类的函数
2. 当派生类重写基类被 virtual 修饰的函数时，基类指针指向派生类对象时，此时该对象调用的函数是派生类的函数
