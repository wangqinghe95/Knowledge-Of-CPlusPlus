# C++ 多态性

## 虚函数
### 虚函数
1. 定义
    + 使用 virtual 关键字修饰的类成员函数。
2. 作用
    + 允许使用基类指针来调用子类的函数，从而实现多态
3. virtual
    + virtual 关键字会被隐式继承，所以当一个成员函数被声明为虚函数以后，其派生类的重写的基类函数都会被默认为虚函数
    + 派生类重写 virtual 修饰的基类函数，需要相同的函数名加上相同的形参列表

### 纯虚函数
1. 定义
    + 在虚函数声明的结尾加上一个 <=0>，表明此函数为纯虚函数
    + 纯虚函数没有函数体，只有函数声明
2. 介绍
    + 纯虚函数的函数指针也会被存到虚函数表中，但是函数指针的值是 0，而具体的虚函数的函数指针的值在虚函数表中是具体的地址值
    + 声明了纯虚函数的类是一个抽象类，这种类无法实例化
    + 如果派生类中没有对基类的纯虚函数进行重写，则该函数在派生类中仍然是纯虚函数
3. 作用
    + 为了实现一个接口，起到一个规范的作用，规范继承这个类必须实现这个函数
    + 在基类中为派生类保留一个函数的名字，以便派生类根据需要对它进行定义和重写

### 虚函数表
1. 定义
    + 每个包含虚函数的类都有一个虚函数表，该类所有实例化对象的内存中都放着一个指向虚函数表的指针 vptr
2. 介绍
+ 虚函数表生成时间
    + 虚函数表是编译器在编译期间生成的，其中虚函数替换也是发生在这个期间；
+ 虚函数表内容
    + 虚函数表，是存储类成员函数指针的数据结构；
+ 虚函数表大小
    + 虚函数个数在编译时期就可以确定，所以虚函数表大小也是可以在编译时期确定；
+ 虚函数表存储地址
    + 虚函数表位于只读数据段，也就是 C++ 内存模型中的常量区；虚函数代码位于代码区
+ 虚指针初始化时间
    + 虚指针会在含有虚函数的类的构造函数执行时初始化，位于对象内存布局的最前面

## C++ 多态
### 多态定义
+ 在基类的函数前加上 virtual 关键字，在派生类中重写该函数，运行时会根据对象的实际类型来调用对应的函数。
    + 当父类指针（引用）指向父类对象时，调用父类中定义的虚函数
    + 当父类指针（引用）指向子类对象时，调用子类中定义的虚函数

### 多态的条件
1. 要有继承
2. 要有虚函数在子类中被重写
3. 父类指针或者引用指向子类

### 静态多态和动态动态
1. 静态多态
    + 在编译时期，编译器会根据实参类型决定去调用合适的函数，如果没有合适的函数，就会发出警告或者报错
    + 如重载，非虚函数重写
2. 动态多态
    + 在程序运行时根据基类的引用或者指针指向的对象来确定具体需要调用哪一个类的虚函数
    + 虚函数重写，switch/if语句

### 虚析构函数
1. 定义
    + 用 virtual 关键词修饰析构函数，称为虚析构函数
2. 意义
    + 当父类指针指向子类对象时，通过父类指针去释放所有子类的内存空间，防止内存泄露

## 虚函数相关
1. 构造函数可以声明为虚函数吗
+ 不能，因为虚函数表指针的初始化时间是在构造函数执行完之后

2. 析构函数时候可以声明为虚函数？
+ 可以，并且建议将含有虚函数的基类的析构函数都声明为虚函数，防止在 delete 指向子类对象的父类指针时，产生资源泄露

3. 构造函数中可以调用虚函数吗，如果可以，会发生多态吗
+ 构造函数中可以调用虚函数，但是不推荐，因为在构造函数期间，对象的虚函数表指针未完全初始化，调用虚函数可能会导致未定义的行为
+ 如果调用了一个虚函数，那么它会以静态绑定的方式调用，即它将调用构造函数所属类的版本，而不是派生类的版本。所以不会发生多态行为。

4. 析构函数中可以调用虚函数吗，如果可以，会发生多态吗？
+ 不能调用，且不会发生多态
+ 析构函数执行时，虚函数表指针已经被销毁了。

5. 类继承中，构造函数和析构函数调用顺序
+ 构造时，先调用父类的构造函数，在调用子类的构造函数
+ 析构时，先调用子类的析构函数，再调用子类的析构函数