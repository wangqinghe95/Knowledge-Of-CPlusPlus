# malloc 和 free 的实现原理

1. 在标准 C 库里，提供了 malloc/free 函数分配和释放内存，这两个函数的底层是由 brk、mmap、munmap 这些系统调用实现的；
2. brk 是将数据段(.data)的最高地址指针 _edata 往高地址推， mmap 是在进程的虚拟地址空间中(堆和栈中间，称为文件映射区域的地方)找一块空间的虚拟内存，这两种方式分配的都是虚拟内存，没有分配物理内存，在第一次访问已分配的虚拟地址空间的时候，发生缺页中断，操作系统负责分配物理内存，然后建立物理内存和虚拟内存直接的映射关系；
3. malloc 小于 128k 的内存直接由 brk 来分配，将 _edata 往高地址推，malloc 大于 128k 的内存，使用 mmap 分配内存，在堆和栈之间找一块空闲内存分配，brk 分配的内存需要等到高地址内存释放以后才能释放，而 mmap 分配的内存可以单独释放。当高地址空间的空闲内存超过 128k （可由M_TRIM_THRESHOLD 选项调节）时执行内紧缩操作(trim)，在上一个步骤 free 时候，发现最高地址空闲内存超过 128k 时，于是内存紧缩。
4. malloc 是从堆中申请内存，也就是函数返回的指针是指向堆里面的一块内存，操作系统有一个记录空闲内存地址的链表，当操作系统收到程序的申请时，就会遍历该链表，然后寻找第一个空间大于所申请空间的堆节点，然后就将该节点从空闲节点链表中删除，并将该节点的空间分配给程序；

# new 和 delete 实现原理

## new 
+ 对于基础数据类型 new[] 计算好类型大小后调用 operator new 分配内存；
+ 对于复杂数组类型（类的数组），new[] 先调用 operator new[] 分配内存，然后在指针的前四个字节写入数组大小 n，然后再调用 n 次构造函数，针对复杂类型，new[] 会额外存储数组大小；

## new 的实现过程
    1. new 表达式调用 operator new(operator new[]) 函数，分配一块足够大的、原始的、未命名的内存空间；
    2. 编译器运行相应的构造函数去构造这些对象，并为其传入初始值；
    3. 对象被分配了空间并构造完成，返回一个指向该对象的指针；

## delete
+ delete 简单数据类型只调用 free 函数；复杂类型先调用析构函数再调用 operator delete；针对简单类型，delete 和 delete[] 等同。假设指针 p 指向 new[] 分配的内存，因为要 4 字节存储数组大小，实际分配的内存地址为 [p-4],系统记录的也是这个地址。 delete[] 实际释放的是 p-4 指向的内存，而 delete 会直接释放 p 所指向的内存，这个内存没有被系统记录，会直接崩溃；

## delete 如何知道释放内存大小的
    new[] 一个对象数组时，会保存数组的维度，C++编译器 会在分配数组空间时多分配 4 个字节的大小，专门用来保存数组大小，在 delete[] 时取出这个保存的数组，就知道需要调用析构函数多少次了。

## delete 和 delete[] 的区别
    + delete 只会调用一次析构函数；
    + delete[] 会调用数组中每个元素的析构函数；