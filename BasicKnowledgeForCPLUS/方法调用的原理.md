# 方法调用原理
    1. 机器用来栈来传递过程参数、存储返回信息、保存寄存器用于以后恢复，以及本地存储。而为单个过程分配的那部分栈成为帧栈；帧栈可以认为是程序栈的一段，它有两个端点，一个标识起始位置，用指针 ebp 表示，一个标识结束位置，用指针 esp 表示；
    2. 由一系列栈帧构成，每个栈帧都对应一个过程，而且每个栈指针 +4 的位置存储函数返回地址；每个栈帧都建立在调用者下方，当被调用者执行完毕时，该段栈帧就会被释放。由于栈帧是向地址递减的方向延伸，因此如果我们将栈指针减去一定的值，就相对于给栈帧分配了一定的空间内存。如果将栈指针加上一定的值，也就是向上移动，就相当于压缩了栈帧的长度，也就是说内存被释放了。
    3. 实现过程
        + 备份原来的帧指针，调整当前的栈帧指针到栈指针位置；
        + 建立起来的栈帧就是为被调用者准备的，当调用者使用栈帧时，需要给临时变量分配预留内存；
        + 使用建立好的栈帧，比如读取和写入，一般使用 mov，push，以及 pop 指令等等；
        + 恢复被调用者寄存器当中的值，这一过程其实就是从栈帧中将备份的值再恢复到寄存器中，不过此时这些值可能已经不再栈顶了；
        + 释放调用者的栈帧，恢复其实就是调整栈帧的两端，使得当前栈的区域又回到了原始的位置；
        + 弹出返回地址，跳出当前位置，继续执行调用者的代码。
    4. 调用过程中的返回指令
        + call 指令
        + leave 指令
        + ret 指令

# 方法调用过程
    1. 调用者函数把被调用函数需要的参数按照与被调函数形参顺序相反的顺序押入栈中，即：从右向左依次把被调用函数所需要的参数压栈；
    2. 调用者函数使用 call 指令调用被调函数，并把 call 指令的下一条指令的地址当作返回地址压入栈中（压栈指令操作隐含在 call 指令中）；
    3. 在被调函数中，被调函数会先保存调用者函数的栈底地址（push ebp），然后再保存调用者函数的栈定地址，即：当前被调函数的栈底地址(mov ebp，esp)；
    4. 在被调函数中，从 ebp 的位置处开始存放被调函数中局部变量和临时变量，并且这些变量的地址按照定义时的顺序依次减小，即：这些变量的地址是按照栈的延伸方向排列的，先定义的变量先入栈，后定义的变量后入栈；