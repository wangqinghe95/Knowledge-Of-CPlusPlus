# C和C++的区别

**类、对象、继承**


## 在成员函数中 delete this 会出现什么问题？对象还可以使用吗？
+ 在类对象的内存空间中，只有数据成员和虚函数表指针，并不包含代码所有内容，类的成员函数单独放在代码段。在调用成员函数时，隐含传递一个 this 指针，让成员函数知道当前是哪个对象再调用它。当调用 delete this 时，类对象内存空间被释放。在 delete this 之后进行的其他任何函数调用，只要不涉及到 this 指针的内容，都能够正常运行。一旦涉及到 this 指针，如操作数据成员，调用虚函数等，就会出现不可预期的问题；
+ 为什么是不可预期的问题？(待补充)
+ 如果在类的析构函数中调用 delete this，会发生什么？。
    - 会导致堆栈溢出。delete 本质是“未将被释放的内存调用一个或多个析构函数，然后释放内存”，于是 delete this 回去调用析构函数，析构函数中又去调用 delete this，形成无限递归，造成堆栈溢出，系统崩溃；

---

## this 指针调用成员变量时，堆栈会发生变化吗?
    + 当在类的非静态成员函数中访问类的非静态成员，编译器会自动将对象的地址作为隐含参数传递给函数，这个隐含参数就是 this 指针。
    + 对于类中个成员的访问都是通过 this 指针去调用的。
    + 当 this 指针调用成员变量时，该变量会入栈（C++的main函数也是一个函数调用，在堆栈中）。

---

## 什么是虚拟继承？
    + 由于 C++ 支持多继承，除了公有继承、保护继承、私有继承三种方式以外，还支持虚拟继承；
    + 在虚拟继承的情况下，无论基类被继承多少次，都是只存在一个实体，虚拟继承基类的子类中，子类会在增加某种形式的指针，或者指向虚基类子对象，或者指向一个相关的表格；表格中存放的不是虚基类子对象的地址，就是其偏移量，此类指针被成为 bptr。如果既继承 vptr,又继承 bptr，某些编译器会将其优化成一个指针；

---

## 类是如何实现只能静态分配和动态分配的？
+ 静态分配：把 new/delete 运算符重载设为 private 属性。
+ 动态分配：把构造函数、析构函数设为 protected 权限，再用在类来动态创建；

---

## 如果想将某个类作为一个基类，为什么该类必须定义而非声明？
+ 派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么

---

## 什么情况会自动生成默认构造函数？
1. 带有默认构造函数的类成员函数，如果一个类没有任何构造函数，但它含有一个成员对象，而后者有默认构造函数，那么编译器就为该为该类合成一个默认构造函数。该合成函数只有在构造函数真正被需要的时候才会发生；如果一个类中有多个成员类对象的话，那么该类的每一个构造函数必须调用每一个成员对象的默认构造函数并且必须按照类对象在该类中的声明顺序进行；
2. 带有默认构造函数的基类，如果一个没有构造函数的派生类派生自一个带有默认构造函数基类，那么该派生类会合成一个古朴造函数调用上一层基类的默认构造函数；
3. 带有一个虚函数的类；
4. 带有一个虚基类的类；
5. 合成的默认构造函数中，只有基类子对象和成员类对象会被初始化。所有其他的非静态数据成员都不会被初始化。

---

## 抽象基类为什么不能创建对象？
+ 在面向对象程序设计中，很多情况下基类本身生成对象是不合理的，并且为了实现多态，需要在基类中定义虚函数。为了解决这个联动问题，就引入了纯虚函数；
+ 将函数定义为纯虚函数后，该类就被成为抽象类，在该类中就无法创建对象了。
+ 所以说不是抽象基类不能创建对象，而是我们定义一个不能创建对象的类，取名为抽象基类；

---

## 继承机制中对象直接如何转换？指针和引用之间如何转换？
+ 向上类型转换：将派生类指针或引用转换为基类的指针或引用称为向上类型转换，向上类型转换会自动进行，并且向上类型转换是安全的；
+ 向下类型转换：将基类指针或引用转换为派生类指针或引用被称为乡下类型转换，向下类型转换不会自动进行，因为一个基类对应几个派生类，所以向下转换时不知道对应哪个派生类，所以在向下类型转换时必须加上动态类型时别技术。
+ RTTI 技术，用 dynamic_cast 进行向下类型转换；

---

## C++ 的组合和继承有什么区别和优缺点？
+ 继承：
    + 优点：子类可以重写父类的方法来方便地实现对父类函数进行扩展；
    + 缺点：
        1. 父类的内部细节对子类是可见的；
        2. 子类从父类继承的方法在编译时就确定下来了，所以无法在运行期改变从父类继承的方法的行为；
        3. 如果对父类的方法做了修改的话，则子类必须作出相应的修改，所以说子类和父类是一种高耦合，违背了面向对象的思想；
+ 组合：设计类时把组合的类加入到该类中作为自己的成员变量
    + 优点：
        1. 当前对象只能通过所包含的那个对象区调用其方法，所以所包含的对象的内部细节对当前对象是不可见的；
        2. 当前对象与包含的对象是一个低耦合关系，如果修改所包含对象的类中代码不需要修改当前对象类的代码；
        3. 当前对象可以在运行时动态的绑定所包含的对象，可以通过 set 方法给所包含的对象赋值；
    + 缺点：
        1. 容易产生过多的对象
        2. 为了组合多个对象，必须仔细对借口进行定义

---

## 静态成员和普通成员是什么？
+ 生命周期：静态成员变量从类加载开始到类被卸载，一直存在；普通成员只有在类创建对象后才开始存在，对象结束生命周期结束；
+ 共享方式：静态成员变量是全类共享；普通成员变量是每个对象单独享有；
+ 定义位置：普通成员定义在栈或堆中，而静态成员定义在静态全局区；
+ 初始化位置：普通成员变量在类中初始化，静态成员在类外初始化；
+ 默认实参：可以使用静态成员变量作为默认实参；

---

## 虚继承？
+ 为了解决多继承时命名冲突和冗余数据问题，产生了虚继承，使得派生类中只保留一份间接基类的成员；
+ 在继承方式前面加上 virtual 关键字就是虚继承；
+ 虚继承的目的就是为了让某个类做出声明，承诺愿意共享它的基类，其中这个被共享的基类就是虚基类。
---

## 虚函数内存结构，棱形继承的虚函数内存结构呢？
+ 虚函数内存结构（当基类有虚函数时）：
    1. 每个类都有虚函数和虚表；
    2. 如果不是虚继承，那么子类将父类的虚指针继承下来，并指向自身的虚表（发生在对象构造时期），有多少个虚函数。虚表里面的项就有多少，多重继承时，可能存在多个基类虚表和虚指针；
    3. 如果是虚继承，那么子类会有两份虚指针，一份是指向自己的虚表，另一份指向虚基表，多重继承时虚继承与虚基表指针有且只有一份；

---

## 多继承的优缺点，作为一个开发者如何看待多继承？
+ C++ 运行一个派生类指定多个基类，这样的继承结构被称为多重继承；
+ 多重继承的优点很明显，就是对象可以调用多个基类中的接口；
+ 如果派生类所继承的多个基类有相同的基类，而派生类的对象需要调用这个祖先类的接口方法，就会容易出现二义性；
+ 加上全局符确定调用哪一份拷贝；
+ 使用虚拟继承，使得多重继承类可以只拥有虚基类的一份拷贝；

---

## 如果有一个空类，它会默认添加什么函数？
+ 默认构造函数；
+ 默认拷贝构造函数；
+ 默认析构函数；
+ 重载赋值运算符函数；

---

## 拷贝构造函数为什么必须引用而不能传值？
1. 拷贝构造函数的作用就是用来复制对象的，在使用这个的对象的实例来初始化这个对象的一个新的实例；
2. 参数过程：将地址传递和值传递统一起来，归根结底传递的是“值”（地址也是值，只不过通过它可以找到另一个值）
    - 值传递：对于内置数据类型的传递，直接复制拷贝到形参（注意形参是函数内部局部变量）；
    - 对于类类型的传递，首先要调用拷贝构造函数来初始化形参（局部变量）；
    - 引用传递：无论是内置类型还是类类型，传递引用或指针最终都是传递的地址值，而地址总是指针类型（属于简单类型），显然参数传递时，按简单类型的赋值拷贝，而不会有拷贝构造函数的调用（对于类类型）
**注意：当拷贝构造函数采用值传递时，会调用类的拷贝构造函数来初始化形参，会产生无限递归调用，造成内存溢出）**

---

## 如何设计一个类来计算子类的个数？
1. 为类设计一个 static 静态变量 count 作为计数器；
2. 类定义结束后初始化 count；
3. 在构造函数中对 count + 1；
4. 设计拷贝构造函数，在进行拷贝构造函数中进行 count + 1；
5. 设计复制构造函数，在进行复制函数中对 count + 1；
6. 在析构函数中对 count - 1；

---

## 什么时候合成构造函数？
1. 如果一个类没有任何构造函数，但它含有一个有默认构造函数的成员对象，编译器会为该类合成一个默认构造函数，因为不合成一个默认构造函数那么该成员对象的构造函数不能调用；
2. 没有任何构造函数的类派生自一个带有默认构造函数的基类，那么需要给该派生类合成一个构造函数，只有这样的基类的构造函数才能被调用；
3. 带有虚函数的类，虚函数的引入需要进入虚表，指向虚表的指针，该指针在构造函数中初始化，所以没有构造函数的话该指针无法被初始化；
4. 带有一个虚基类的类；
**注意：**
1. 并不是任何没有构造函数的类都会合成一个构造函数；
2. 编译器合成出来的构造函数并不会显示设定类内的每一个成员变量；

---

## 什么时候需要合成拷贝构造函数？
+ 有三种情况会以一个对象的内容作为另一个对象的初始：
    1. 当一个对象用等号做显示的初始化操作；
    2. 当对象被当作参数交给某个函数时；
    3. 当函数传回一个类对象时；
+ 如果一个类没有拷贝构造函数，但是有一个含有拷贝构造函数的类类型成员变量，那么此时编译器需要为该类合成一个拷贝构造函数；
+ 如果一个类没有拷贝构造函数，但是该类继承含有拷贝构造函数的基类，那么编译器会为该类合成一个拷贝构造函数；
+ 如果一个类没有拷贝构造函数，但是该类声明或继承了虚函数，此时编译器会为该类合成了一个拷贝构造函数；
+ 如果一个类没有拷贝构造函数，但是该类含有虚基类，此时编译器会为该类合成一个拷贝构造函数；

---

## 成员初始化列表会在什么时候用到？它的调用过程是什么？
1. 当初始化一个引用成员变量时；
2. 初始化一个 const 成员变量时；
3. 当调用一个基类的构造函数，而构造函数拥有一组参数时；
4. 当调用一个成员类的构造函数，而它拥有一组参数时；

5. 调用过程：编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码前，列表中项目顺序是由类中的成员声明顺序决定的，而不是初始化列表中的排列顺序决定的；

---

## 构造函数的执行顺序是什么？
1. 在派生类构造函数中，所有的虚基类以及上一层基类的构造函数调用；
2. 对象 vptr 被初始化；
3. 如果有成员初始化列表，将在构造函数体内扩展开来，这必须在 vptr 被设定以后才做；
4. 执行程序提供的代码；

---

## 一个类中的全部构造函数的扩展过程是什么？
1. 记录在成员初始化列表中的数据成员初始化操作会被放在构造函数的函数体内，并与成员的声明顺序为顺序；
2. 如果一个成员并没有出现在成员初始化列表中，但它有一个默认构造函数，那么这个默认构造函数必须被调用；
3. 如果类中有虚表，那么它必须被设定初值；
4. 所有上一层的基类构造函数必须被调用；
5. 所有虚基类的构造函数必须被调用；

---

## 哪些函数不能是虚函数?
1. 构造函数：构造函数初始化对象，派生类必须知道基类函数做了什么，才能进行构造；当有虚函数时，每个类有一个虚表，每个对象有一个虚表指针，虚表指针在构造函数中初始化；
2. 内联函数：内联函数表示在编译阶段进行函数体的替换，而虚函数意味着在运行期间进行类型确认，所以内联函数不能是虚函数；
3. 静态函数，静态函数不属于对象，属于类，静态成员函数没有 this 指针，因此静态函数被设置为虚函数是没有意义的；
4. 友元函数：友元函数不属于类的成员函数，不能被继承，对于没有继承特性的函数来说没有虚函数的说法；
5. 普通函数：普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数一说；

--
 
## 如何阻止一个类被实例化的方法？
1. 把类定义为抽象类
2. 将构造函数声明为 private；

---

## 如何禁止程序自动生成拷贝构造函数？
+ 为了阻止编译器默认生成拷贝构造函数和拷贝复制函数，我们需要手动去重写这两个函数，某些情况下，为了避免调用拷贝构造函数和拷贝赋值函数，我们需要把他们设置为 private，防止被调用；
+ 类的成员函数和友元函数还是可以调用 private 函数，如果这个 private 只声明不定义，则会产生一个链接错误；
+ 针对上述两种情况，我们可以定义一个 base 类，在 base 类中将拷贝构造函数和拷贝赋值函数设置成 private，那么派生类中编译器就不会自动生成这两个函数，且由于 base 类中该函数是私有的，因此派生类将阻止编译器执行相关的操作；

---

## 成员函数中 memset(this, 0, sizeof(this)) 会发生什么？
1. 有时候类里面定义了很多 C 语言类型的变量，我们希望在构造函数中将他们初始化为 0， 可以使用 memset(this, 0 ,sizeof(this))，将整个对象的内存全部置为 0，但是在以下几种情况下不能这么使用：
    + 类中含有虚函数表：这样做会破坏虚函数表，后续对虚函数表调用会出现问题；
    + 类中含有 C++ 对象成员：如果对象成员的构造函数中分配了内存，这样做会破坏对象的内存；

---

## 为什么友元函数必须在内部声明？
+ 因为编译器需要在编译阶段知道哪些数据或者函数能够访问类的私有成员；

---

# 独立特性（范式编程，异常机制、元编程、STL标准库）

## 迭代器失效的情况？
+ 迭代器失效就是原本可以访问到容器内迭代器的元素在插入或删除的操作后无法再继续访问到了
+ 插入元素：
    - 尾后插入：size < capacity 时，尾迭代器失效（未重新分配空间）；size == capacity 时，所有迭代器均失效（需要重新分配空间）
    - 中间插入：size < capacity 时，插入元素之后的所有迭代器失效； size == capacity 时，所有迭代均失效；
+ 删除元素：
    - 尾后删除：只有尾迭代器失效；
    - 中间删除：删除位置之后所有迭代器失效；
    - list 链表删除节点后只有当前迭代器失效，erase 返回下一个有效迭代器；
    - map/set 等关联容器底层是红黑树，删除节点不会影响其他节点的迭代器，使用递增方式获取到下一个迭代器(mmp.erase(iter++));

---

## C++ 异常处理方法？（C++ 是如何处理多个异常的）
+ 程序执行时由于程序员疏忽或者系统资源紧张等因素都有可能导致异常，常见的异常有 数组下标越界，除法计算时除数为 0，动态分配空间不足；如果不及时对这些异常进行处理，程序多数情况下会崩溃；
+ try、throw、catch 关键字；
+ 函数的异常声明列表：有时候程序员在定义函数的时候知道函数可能发生的异常，可以在函数声明和定义时，指出所能抛出异常列表；
+ C++ 标准异常类 exception；

---

## C/C++ 类型安全？
+ C 的类型安全：C 只在局部上文表现出类型安全，比如两个不同结构体指针相互转换时，编译器会报错，除非使用显示类型转换；
+ C++ 类型安全：C++ 提供一些新的机制来保证类型安全：
    + 操作符 new 返回的指针类型严格与对象匹配，而不是 void*；
    + C 中很多以 void* 为参数的函数可以改写为 C++ 模板函数，而模板是支持类型检查的；
    + 引入 const 关键代替 #define constans，它是有类型，有作用域的，而 #define constants 只是简单的文本替换；
    + 一些 #define 宏可被改写成 inline 函数，结合函数的重载，可在类型安全的前提下支持多种类型，当然改写成模板也能保证类型安全；
    + C++ 提供 dynamic_cast 关键字，使得转换过程更加安全，因为 dynamic_cast 比 static_cast 涉及更多的类型检查；

---

## C++ 模板是什么，底层是如何实现的？
+ 编译器并不是把函数模板处理成能够处理任意类的函数；编译器从函数模板通过具体类型产生不同的函数；编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译；
+ 这是因为模板函数要被实例化以后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件只有声明，没有定义，则编译器无法实例化该模板，最终导致链接错误；

---

## 模板函数和模板类的用法（模板类和模板函数的区别）？（待修改）
+ 函数模板的实例化是由编译程序在处理函数调用时自动完成的，而类模板的实例化必须由程序员在程序中显示地指定，即函数模板允许隐式调用和显示调用，而类模板只能显示调用。在使用时，类模板必须加，而函数模板不必；

---

## 智能指针的作用
+ 普通指针容易造成堆内存泄漏，（忘记释放）二次释放，程序发生异常时内存泄漏等问题；使用智能指针对堆内存的管理会更加严谨；

---

## 智能指针的原理、常用的智能指针及实现？
+ 原理：智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏，动态分配的资源交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源；
+ shared_ptr：
+ unique_ptr:
+ weak_ptr:
+ auto_ptr:

---

## auto_ptr 作用（待修改）？
1. auto_ptr 的出现，主要是为了解决“有抛出异常时发生的内存泄漏”问题；抛出异常，将导致指针所指向的位置得不到释放而导致内存泄漏；
2. auto_ptr 构造时取得某个对象的控制权，在析构时释放该对象。实际上是创建一个 auto_ptr 类型的局部变量，在局部对象析构时，会将自身所拥有的指针空间释放，所以不会有内存泄漏；
3. auto_ptr 的构造函数是 explicit ，阻止了一般指针隐式转换为 auto_ptr 的构造，所以不能直接将一般指针赋值给 auto_ptr 类型的对象，必须用 auto_ptr 的构造对象创建对象；
4. 由于 auto_ptr 对象析构时会删除它所用的指针，所以使用时避免多个 auto_ptr 对象管理同一个指针；
5. auto_ptr 内部实现，析构函数删除对象用的是 delete 而不是 delete[]，所以 auto_ptr 不能管理数组；
6. auto_ptr 支持所拥有的指针类型之间的隐式转换；
7. 可以通过 * 和 -> 运算符对 auto_ptr 所使用的指针进行提领操作；
8. T* get():获得 auto_ptr 所拥有的指针； T* release()：释放 auto_ptr 的所有权，并将所使用的指针返回；

---

## 智能指针的循环引用？
+ 循环引用指的是使用多个智能指针 shared_ptr 时，出现了指针之间的相互指向，从而形成环的情况，类似于死锁现象，在这种情况下智能指针往往不能正常调用对象的析构函数，从而造成内存泄漏；

---

## 智能指针出现循环引用怎么解决？
+ 弱指针专门用来解决 shared_ptr 循环引用的问题，weak_ptr 不会修改引用计数，即其存在与否不影响对象的引用计数器；
+ 循环引用就是两个对象互相使用一个 shared_ptr 成员变量指向对方。弱引用并不对对象的内存进行管理，在功能上类似于普通指针；
+ 弱引用能检测到所管理的对象是否已经被释放，从而避免访问非法内存；

---

## 智能指针管理内存资源，RAII是什么？
+ RAII 全程为 “Resource Acqusition is Initialization”, 直译过来就是 资源获取即初始化，也就是说在构造函数中申请分配资源，在析构函数中释放资源；
+ C++ 语言机制把保证了当一个对象创建的时候，自动调用构造函数，当对象超出了作用域的时候会自动调用析构函数，所以在 RAII 的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定；
+ 智能指针(std::shared_ptr 和 std::unique_ptr)即 RAII 最具代表的实现，使用智能指针，可以实现自动的动态管理。

---

## 手写实现智能指针类？
+ 智能指针是一个数据类型，一般使用模板实现，模拟指针行为的同时还提供自动垃圾回收机制。它会自动基类 smartPointer<T*>对象的引用计数，一旦T类型对象的引用计数为0，就释放该对象；
+ 除了指针对象以外，我们还需要一个引用计数的指针设定对象的值，并将引用计数计为1，需要一个构造函数，新增对象还需要一个构造函数，析构函数负责引用计数减少和释放内存；
+ 通过复写赋值运算符，才能将一个旧的智能指针赋值给另外一个指针，同时旧的引用计数减1，新的引用加1；
+ 一个构造函数、拷贝构造函数、复制构造函数、析构哈桑纳湖、移走函数；

---

## C++ 11 有哪些新特性？
+ nullptr 代替 NULL；
+ 引用了 auto/decltype 两个关键字实现了类型推导；
+ 基于范围的 for 循环 for(auto &i : res){};
+ 类和结构体中的初始化列表；
+ lambda 表达式（匿名函数）；
+ std:forward_list 单向链表；
+ 右值引用和 move 语义；

---

## 为什么模板类一般都放在一个 .h 文件中？
+ 模板定义特殊：由 template<...> 处理的任何东西都意味着编译器在当时不为它分配空间，它一致处于等待状态，直到被一个模板实例告知。在编译器和链接器的某一处，有一机制能去掉指定模板的多重定义；所以为了容易使用，几乎总是在头文件中防止全部的模板声明和定义；
+ 在分离式编译的环境下，编译器编译某一个 .cpp 文件时，并不知道另一个 .cpp 文件的存在，也不会去查找，（当遇到未决符号时，它会寄希望于链接器）。这种模式在没有模板的情况下运行良好，但遇到模板时就无法起作用了，因为模板仅在需要的时候才会实例化；
+ 所以当编译器只看到模板声明时，它不能实例化该模板，只能创建一个具有外部链接的符号并期待链接器能够将符号的地址决议出来；
+ 然而当实现该模板的 .cpp 文件中没有用到模板的实例时，编译器不回去是咯话，所以整个工程的 .obj 文件中就找不到一行模板实例的二进制代码，于是链接器也没用了。

---

## 模板和实现可不可以不写一个文件中？为什么？（待补充）

## 迭代器 ++it、it++ 哪个好，为什么？
+ 前置返回一个引用，后置返回一个对象；
+ 前置不会产生临时对象，后置必须产生临时对象，临时对象会导致效率降低；

---

## C++ 中标准库是什么？
+ C++ 标准库分为两部分：
    - 标准函数库：这个库是通用的、独立的、不属于任何类的函数组成，函数库继承自 C 语言；
    - 面向对象库类：这个库是类及其相关函数的集合；
+ 输入/输入 IO、字符串和字符处理、数学、时间、日期和本地化、动态分配、其他、宽字符函数
+ 标准的 C++ IO 类，String 类、数值类、STL 容器类、STL函数对象、STL迭代器、STL分配器、本地化库、异常处理类、杂项支持类；

---

## 写一个比较大小的模板？
```
#include<iostream>
using namespace std;

template<typename type1, typename type2>
type1 Max(type1 a, type2 b){
    return a > b ? a : b;
}

int main(){
    cout << "Max = " << Max(5.5, 'a') << endl;
    return 0;
}
```

---

## STL 的 hashtable 实现
+ hashtable 使用的是开链法解决冲突的；
+ hashtable 中使用的是自定义的 hashtable_node 数据结构组成的表；
+ 内置了28个质数作为初始时的长度；

---

## STL 的 traits 技法？（待补充）

## STL 的两级空间配置器？（一级配置器，二级配置器，一级分配器，二级分配器）（待完善）
+ 为了避免频繁的在堆上开辟释放内存，造成外部碎片浪费内存空间，设置了二级空间配置器；
+ 当开辟空间 <= 128bytes 时，则视为开辟小块内存，则调用二级空间配置器；

---

## vector 和 list 的区别与应用，怎么找到某 vector 和 list 的倒数第二个元素?
+ vector 数据结构：
    - vector 拥有一块连续的内存空间，并且起始位置不变，因此可以高效的进行随即存取，时间复杂度为O（1）；
    - 插入和删除时会造成内存块的拷贝，时间复杂度为O（n）；
    - 数组内存空间不够时，会重新申请一块空间进行内存拷贝；
    - vector 可以实现动态增长，支持对数组高效率的访问和在数组尾部删除和插入操作，在中间和头部删除和插入不易；
    - 和数组最大的区别在于不需要使用者去考虑容量问题，包括在扩容的时候；
+ list 数据结构:
    - list 是由双向链表实现的，内存不连续，只能通过指针访问数据，所以随即存储没有效率，时间复杂度为 O(n);
    - 链表支持高效的插入和删除；
    - list 是一个双链表结构，支持对链表的双向遍历。每个节点包括三个信息：元素本身，指向前一个元素的节点和指向后一个元素的节点。可以高效的对元素任意位置进行访问和插入删除等操作；
    - 由于涉及到对额外指针的维护，开销较大；
+ 区别：
    - vector随即访问效率高，但删除和插入时（不包括尾部）需要挪动数据，不易操作。list访问需要遍历整个链表，随即访问效率低，但是对数据的插入和删除操作比较方便；
    - list 是单向的，vector 是双向的，vector迭代器在使用后就失效了，而 list 的迭代器在使用后还可以继续使用；
+ 访问倒数第二个元素：
    - vector: `int mySize = vec.size(); vec.at(mySize-2);`
    - list: 双指针，相距两个位置，遍历一边走完，慢指针的位置就是到处第二个元素的位置；

---

## STL 中 vector 删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？
+ size() 函数返回已用空间大小；capacity() 返回宗空间大小；capacity()-size()则是剩余的可用空间大小。但size()和capacity()相等时，说明 vector 目前的空间已被用完，如果再添元素的话，则会引起 vector 空间的动态增长；
+ 由于动态增长会引起重新分配内存空间、拷贝原空间、释放原空间，这些过程会降低程序效率。因此可以使用 reserve(n) 预先分配一块较大的指定大小的内存空间，这样当指定大小的内存空间未使用完时，是不会重新分配内存空间的，这样可以提升效率，只有当 n > capacity 时，调用 reserve(n) 才会改变 vector 的容量；
+ resize() 成员函数只改变了元素的数目，不改变 vector 的容量；

**总结：**
1. 空的 vector 对象，size() 和 capacity() 都为 0；
2. 当空间大小不足时，新分配的空间大小是原空间大小的两倍；
3. 使用 reserve() 预分配一块内存后，在空间未满的情况下，不会引起重新分配，从而提升了效率；
4. 当 reserve() 分配的空间比原空间小时，是不会引起重新分配的；
5. resize() 函数只改变容器的元素数目，未改变容器大小；
6. 用 reserve(size_type) 只是扩大了 capacity 的值，这些内存空间还可能是'野'的，如果此时使用'[]'来访问，则可能越界，而 resize(size_type new_size) 会真正使容器具有 new_size 个对象；

+ 两倍扩容是因为每次扩展的新尺寸必然刚好大于之前分配的总和，也就是说之前分配的内存空间不可能被使用，这样对内存不友好，最好把增长因子设定在（1，2）；对比可以发现采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定指定大小的容量只能达到 O(n) 的时间复杂度，因此使用成倍的扩容方式；

---
 
## STL 容器内部删除一个元素？
1. 顺序容器：erase迭代器不仅使所指向的被删除的迭代器失效，而且使被删除元素之后的所有迭代器失效（list除外），所以不能使用 erase(it++)的方式，但是 erase 的返回值是下一个有效迭代器; `it = c.erase(it);`
2. 关联容器：erase迭代器只是被删除元素的待迭起失效，但返回值是 void,所以要采用 erase(it++) 的方式删除迭代器；

---

## STL 迭代器如何实现？
+ 迭代器是一种抽象的设计理念，通过迭代器可以在不了解容器内部原来的情况下，遍历该容器，除此之外 STL 中的迭代器一个最重要的作用就是作为容器与 STL 算法的粘合剂；
+ 迭代器的作用就是提供一个遍历容器内部所有元素的接口，因此迭代器内部必须保存一个与容器相关联的指针，然后重载各种运算操作来遍历，其中最重要的就是 * 和 -> 运算符，以及 ++ 、-- 等可能需要重载的运算符重载。
+ 最常见的迭代器相应类型有五种：value type、difference type、pointer、reference、iterator catagoly；

---

## map、set 如何实现的，红黑树是怎么能够同时使用这两种容器的？为什么使用红黑树？
+ 他们的底层都是以红黑书的结构实现的，因此插入删除等操作都在 O(logn)时间内完成的，因此可以完成高效的插入删除操作；
+ 定义一个模板参数，根据参数的不同决定它是哪种容器。
+ map 和 set 需要自动排序，红黑树能实现且时间复杂度低；

---

## 如何在共享内存中使用 STL 标准库？（待补充）

## map 插入有几种方式？
+ 用 insert 函数插入 pair 数据
    ```
    mapData.insert(pair<int,string>(1,"one"));
    ```
+ 用 insert 函数插入 value_type 数据
    ```
    mapData.insert(map<int,string>::value_type (1,"one"));
    ```
+ 用 insert 函数插入 make_pair 数据
    ```
    mapData.insert(make_pair(1,"one"));
    ```
+ 用数组插入数据：
    ```
    mapData[1] = "one";
    ```

---

## STL 的 unordered_map(hash_map) 和 map 的区别？hash_map 如何解决冲突和扩容？
+ 区别是 unordered_map 底层是用 hash 实现的， map 是用红黑树实现的，所以表现出现的不同是 unordered_map 存储元素是无序的，而 map 是有序的，但是因为排序是需要消耗时间的，所以 map 消耗的资源平均要大一些；
+ hash_map 底层使用的是 hash_table ，而 hash_table 使用的开链法避免冲突的；
+ 当向容器内部添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值，即当前数组的长度乘以加载因子的值的时候，就自动扩容了；

---

## vector 越界访问下标，map 越界访问下标？ vector 删除元素会不会释放空间？
+ 通过下标访问 vector 中的元素是不会做边界检查的，即使下标越界，程序也不会报错，而是返回这个地址存储的值；如果想要在访问 vector 数组时进行边界检查，可以使用 at 函数；
+ map 的 下标运算符 [] 作用是：将 key 作为下标去执行查找，并返回相应的值，如果不存在这个 key，就将一个具有该 key 和 value 的节点插入到 map 中；
+ erase() 函数，只能删除内容，不能改变容量大小
    - erase成员函数，它删除了itVect 迭代器指向的元素，并且返回要被删除的 itVect 之后的迭代器，迭代器相当于一个智能指针；
    - clear() 函数，只能清空内容，也不能改变容量的大小；

---

## map 中的 [] 和 find 有什么区别？
+ 下标运算符 []：将关键码作为下标去执行查找，并返回相应的值，如果不存在这个关键码，就将一个具有该关键码和值类型的默认值的项插入到 map 中；
+ find 函数：用关键码执行查找，找到了返回该位置的迭代器；如果不存在这个关键码，就返回尾迭代器；

---

## STL 中的 list 和 queue 区别？
+ list 不能够像 vector 一样以普通指针作为迭代器，因为其节点不保证在存储空间中的连续存在；
+ list 插入操作和删除操作都不会造成原有 list 迭代器失效；
+ list 不仅是一个双向链表，还是一个环状双向链表，所以它只需要一个指针；
+ list 不会有容量扩充的操作，所以插入前的所有迭代器在插入操作后仍然有效；
+ deque 是一种双向的连续线性空间，可以在头尾两端分别做元素的插入和删除操作，
+ deque 和 vector 最大的差异在于 deque 可以在常数时间内对头尾做元素的插入和删除操作，二是 deque 是动态的以分段连续空间组合而成，不必有重新分配空间的设计；

---

## STL 的 allocator，deallocator
+ 第一级配置器直接使用 malloc()、free()、relloc()，第二级配置器视情况采用不同的策略：当配置区块超过 128bytes 时，视为足够大，调用第一级配置器；当配置器区块小于 128bytes 时，为了降低额外负担，使用复杂的内存池整理方式，而不再使用一级配置器；
+ 第二级配置器主动将任何小额区块的内存需求量上调至 8 的倍数，并维护 16 个 free-list，各自管理大小为 8~128bytes 的小额区块；
+ 空间配置函数 allocate()，首先判断区块大小，大于 128 直接调用第一级配置器，小于 128 就检查对应的 free-list。如果 free-list 之内有可用区块，就直接拿过来用，如果没有可用区块就将区块大小调整为 8 的倍数，然后调用 refill()，为 free-list 重新分配空间；
+ 空间释放函数 deallocate()，该函数首先判断区块大小，大于 128byetes 时直接调用一级配置器，小于 128bytes 时就找到对应的 free-list 然后释放内存；

---

## STL 的 hash_map 扩容发生了什么？
+ hash table 表格内的元素被称为桶，而由桶所链接的元素被称为节点，其中存入桶元素的容器是vector容器。
+ 向前操作：首先尝试从目前所指的节点出发，前进一个位置，由于节点被安置在 list 内，所以利用节点的 next 指针即可轻易的完成向前操作，如果目前正巧是 list 尾端，就调至下一个bucket身上，那正是指向下一个 list 的头部节点；

---

## 常见的容器性质总结？
1. vecotr：底层数据结构为数组，支持快速随机访问；
2. list：底层数据结构为双向链表，支持快速增删；
3. deque：底层数据结构为一个中央控制器和多个缓冲区，支持首尾快速增删，也支持随即访问；双向队列；
4. stack：底层一般使用 list 或 deque 实现，封闭头部即可；适配器，对容器的再封装
5. queue：底层一般使用 list 或者 deque 实现，等比头部即可；适配器，对容器的再封装
6. priority_queue：底层数据结构一般为 vector 容器，堆 heap 为处理规则实现底层容器管理；
7. set：底层结构为红黑树，有序，不重复；
8. multiset：底层结构为红黑树，有序，可重复；
9. map：底层结构为红黑树，有序，不重复；
10. multimap：底层数据结构为红黑树，有序，可重复；
11. unordered_set：底层数据结构为 hash 表，无序，不重复；
12. unordered_multiset：底层数据结构为 hahs 表，无序，可重复；
13. unordered_map：底层数据结构为 hash 表，无序，不重复；
14. unordered_multimap：底层数据结构为 hash 表，无序，不重复；

---

## vector 的增加删除是怎么做到的，为什么是 1.5 或者是 2？
1. 新增元素：vector 通过一个连续的数组存放元素，如果集合已满，则在新增数据的时候，就要分配一块更大的内存，将原来的数据复制过来，释放之前的数据，再插入新数据；
2. 对 vector 的任何操作，一旦引起空间重新分配，指向原 vector 的所有迭代器都失效了；
3. 初始时刻 vector 的capacity 为 0，塞入第一个元素后 capacity 增加 1；
4. 不同的编译器实现扩容的方式不一样， vs2015 是以1.5倍扩容，GCC 是以 2 倍扩容；

对比可以发现采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此采用成倍的方式扩容
对于扩容的考虑：
1. 考虑可能产生的对空间的浪费，成倍增长倍数不能太大，使用较为广泛的扩容方式就只有两种，2倍和1.5倍；
2. 以2倍的方式扩容，导致下一次申请的内存必然会大于之前分配的内存的总和，导致之前分配的内存不能再被使用，所以增长倍数因子最好再(1,2)；
3. 向量容器 vector 的成员函数 pop_back() 可以删除最后一个元素；
4. 而函数 erase() 可以删除由一个 iterator 指出的元素，也可以删除一个指定范围的元素；
5. 还可以采用通用算法 remove() 来删除 vector 容器中的元素；
6. 不同的是 remove 一般情况下不会改变容器的大小，而 pop_back 和 erase 等成员函数会改变容器的大小；

---

+ 说一下 STL 每种容器对于的迭代器？

+ STL 的 vector 实现

+ STL 的 slist 实现

+ STL 的 list 实现

+ STL 的 deque 实现

+ STL 的 stack 和 queue 实现

+ STL 的 heap 实现

+ STL 的 priority_queue 实现

+ STL 的 set 实现

+ STL 的 map 实现

## set 和 map 的区别，multimap 和 multiset 的区别？
1. set 只提供数据接口，但是会将这个元素分配到 key 和 value，而且它的 compare_function 用的是 identity() 函数，这个函数输入什么输出什么，这样就实现了 set 的机制，set 的 key 和 value 是一样的，其实它保存了两份元素。
2. map 则提供了两种数据类型的接口，分别放在 key 和 value 的位置上，它的比较函数 function 采用的是红黑树的 compare_function()， 保存的确实时两份元素；
3. 它们两个的 insert 都是采用红黑树的 insert_unique() 独一无二的插入；
4. multimap 和 map 的唯一区别：multimap 调用的是红黑树的 insert_equal(),可以重复插入，而 map 调用的是独一无二的 insert_unique(), multiset 和 set 也一样，底层实现都是一样的，只是在插入的时候调用的方法不一样；

---

## STL 的 unordered_map 和 map 的区别和应用场景？
+ map 支持键值的自动排序，底层机制是红黑树，红黑树的查询和维护信息时间复杂度均为 O(logn)，但是空间占用比较大，因为每个节点都要保持父节点、子节点以及颜色的信息；
+ unordered_map 底层机制是哈希表，通过 hash 函数计算元素的位置，其查询的时间复杂度为 O(1),维护时间与bucket桶所维护的list长度有关，但是建立 hash 表耗时较长；
+ 从两者的底层机制和特点可以看出：map 适用于有序数据的应用场景，unordered_map 适用于高效查询的引用场景；

---
