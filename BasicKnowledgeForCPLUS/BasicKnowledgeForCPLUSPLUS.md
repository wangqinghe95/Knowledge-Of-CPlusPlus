# Basic Knowledege for C/C++

<!------------ Basic C++ from C --------------------->
## Basic C && C++

### C 和 C++ 的区别
1. 设计思想或者说是应用场景的区别
    + C 是基于内存占用和执行效率的考虑使它更趋近于底层，特点是越精简越高效，注重逻辑实现，也就是面向过程。多用于操作系统和驱动内核。
    + C++ 诞生的目的之一就是抽象和精简 C 的实现过程，注重程序的整体设计。适合做大型软件。
2. 由设计思想的不同，由此引申出来的种种实现和细节的不同，如C++比C多出来的关键，C++多出来的虚函数，重载的概念和实现。面向对象设计的核心类，甚至再往上完全和 C 没有任何关系的范式编程，元编程。都是两者具体上的差别。

### C++ 中 const 关键字
1. C++ const 是一个关键字，用于来声明所修饰的对象不要修改
2. 它可以修饰变量，指针，指针地址，函数参数，函数返回值，类成员函数，类对象等
3. 它的作用是防止修饰的对象被修改，有利于提高代码的可读性和可维护性，并减少错误的发生

### C++ 中指针和引用的区别
1. 引用在编译时会被解释成常指针，编译器完成取地址解引用的过程，在编译之后，两者在汇编层面上一样。
2. 在上层使用中，就是常指针和普通指针的区别

### 解释区间（range）和范围（span）。
+ 都表示一段连续的内存空间
+ 区间通常指的是左闭右开的区间。
+ 范围一般指的是左闭右闭的区间。

### 什么是强制内联（forced inline）？它与普通内联（normal inline）有什么区别？
+ 内联是 C++ 编辑器一种优化技术，它可以将函数的代码直接插到调用函数的地方去，从而避免了函数调用的开销。内联函数适用于代码比较少的函数，比如访问器函数，操作符重载函数等
+ 普通内联是由编辑器自主决定是否要进行内联优化，而强制内联是通过在函数声明前加上关键字 inline 和 __foreceinline 修饰符实现，强制内联会强制编译器对该函数进行内联优化，即使编译器认为这并不是最优选择
+ 需要注意的是强制内联可能会导致代码体积增大，从而影响程序的性能，所以应该谨慎使用强制内联，并在必要时进行性能测试和优化。

### static 关键字作用
+ static 修饰的变量存放在全局数据区的静态变量区中。这种变量的作用域受限在定义处的区域中，且该区域的变量生存周期是整个程序的运行周期
+ static 修饰的全局变量叫做静态全局变量
    - 只能本文件所见，不能被其他文件访问；
- static 修饰的局部变量被称为静态局部变量
    - 生存周期拉长到整个程序的生存周期，作用域是声明处的局部范围；
- static 修饰的类成员和类成员函数，被称为类的静态成员
    - 类的静态成员属于类本身，不属于类对象
    - 无需实例化就可以直接通过类名直接访问
- static 修饰函数，被称为静态函数
    - 只能本文件所见，不能被其他文件访问；

### 解释 C++ 中的强制类型转换（type casting）
+ static_cast：用于基础类型之间的转换
    - 如果用于基类和派生类之间的转换，那么在运行时是没有类型检查来保证转换的安全性的
+ dynamic_cast：主要用于类层次之间的上行转化或者下行转换
    - 上行转换时，效果等同于 static_cast
    - 下行转换时，dynamic_cast 有类型检查的功能
+ reinterpret_cast
    - 整数和指针之间相互转换，不安全，不推荐使用
+ const_cast
    - 用来修改表达式的 const 和 volatile 属性

### static_cast 比 C 中的强制转换有什么优势？
1. 更加安全，static_cast 在编译时会进行编译检查，如果类型转换不合法会报错，避免了类型转换错误的发生
2. 更加直观，能够清楚的看出代码中转换的类型，可读性更强

### C++ nullptr 和 NULL 有什么区别？
+ NULL 整型 0
+ nullptr 指针 0

### malloc 和 free 实现的原理？
1. 基于内存池实现
    + 内存池是一块预先分配好的内存区域，由大小相等的内存块组成
    + 当调用 malloc 时，程序会从内存池中找到一块足够大的内存块，将其标记为已用，分配给程序。
    + 当调用 free 时，将该块内存标记为未使用，并将其返回给内存池
2. 基于堆实现
    + 堆是一块动态分配的内存区域，有多个大小不等的内存块组成
    + 当调用 malloc 时，程序会在堆上找到一个足够大的空闲区域，并将其标记为已使用。
    + 当调用 free 时，程序会将该内存块标记为未使用，并将其合并到相邻的空闲区域中

### malloc、realloc、calloc 的区别
1. malloc 在堆上额分配指定指定字节数的存储区，该存储区的初始值不确定，需要 memset 处理
2. realloc 更改之前分配区的长度，可以对给定的指针所指的空间进行扩大或者缩小，原有内存内容保持不变
3. calloc 分配指定字节大小的存储区，会初始化分配的内存空间为零

### new/delete 和 malloc/free 的区别？
1. 类型不同：new 是操作符，需要编译器支持，malloc 是库函数，需要标准库支持
2. 参数不同，new 无需指定需要分配的内存大小，编译器会自己根据类型信息计算的的得出，malloc 是显式的指出申请所需的内存的大小
3. 返回值不同：new 申请内存成功后返回所指对象类型的指针，malloc 申请成功后返回的是 void*，根据需要再做强转
4. 申请失败后返回结果不同：new 抛出异常，malloc 返回一个 NULL
5. 申请自定义用户类型过程不同：new 申请内存后会自动调用自定义用户类型的构造函数，malloc 只会申请内存

### C++ 有几种类型 new？
+ plain new ： 常用的 new,在空间分配失败时抛出异常 std::bad_alloc 而不是返回 NULL
+ nothrow new ： 在空间分配失败情况下，不抛出异常而是返回 NULL
+ placement new ： 在一块已经分配成功的内存上重新构造对象或对象数组

### malloc 和 free 实现的原理？

### struct 和 class 的区别
+ C++ 中两者的区别是成员访问权限和继承方式不同
+ C struct 和 C++ struct 区别在于
    1. C++ 的 struct 是一种抽象数据类型，支持成员函数，支持访问权限，能够继承
    2. C 的 struct 只是用户自定义数据类型，是一些变量的集合体

### 判断两个结构体是否相等
1. 重写比较操作符
2. 对结构体变量一一比较
3. 对结构体指针指向的内容一一进行比较

### 形参和实参的区别
1. 形参是函数定义时用于接受参数的变量，是函数头部声明的变量，用于在函数内部用于进行计算和操作，在函数调用时才被会赋值
2. 实参是函数调用时传递给函数的参数，这个参数是一个值，在内存中有地址。
3. 形参和实参的功能是数据传送，发生函数调用时，主调用函数把实参的值传送给被调用函数的形参，从而实现从主调函数向被调函数的数据传输。


### 值传递、指针传递、引用传递的区别和效率？
+ 值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象，或是大的结构体对象，将耗费一定的时间和空间。（传值）
+ 指针传递：同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为 4 字节的地址。（传值，传递的是地址值）
+ 引用传递：同样有上述数据的拷贝过程，但是针对的地址，相当于为该数据所在的地址起了一个别名
+ 从效率上说，指针传递和引用传递的效率要比值传递的效率要高，一般主张使用引用传递，代码逻辑上更加紧凑，清晰；

### 将引用作为函数参数的好处是什么？
1. 节省内存空间，引用作为一个别名，不需要暂用额外的内存空间，编译器会自动将其视为原始变量的别名，并将其替换为原始变量的地址
2. 提高程序执行效率，直接操作原始变量地址，避免变量复制拷贝操作，而且可以作为传出参数使用
3. 代码阅读性好

### 指针参数传递和引用参数传递有什么区别？底层原理是什么？
1. 没有很大的区别，引用底层就是常量指针。
2. 指针参数传递传过去了一个数值，这个数值是一个内存地址。引用传递传过去的实参的地址。

### 什么时候用指针当参数，什么时候用引用当参数，为什么？
1. 传递数组用指针
2. 传递类对象，用指针或者引用
3. 内置数据都行
4. 如果可以区分会不会修改传入的参数的值，可以用 const 标识，以提高程序运行效率

### 深拷贝和浅拷贝
+ 浅拷贝只复制指向某个对象的指针的值，而不复制指向的对象本身，新旧对象共享同一块内存。
+ 深拷贝会重新开辟空间，将指针指向的对象的内容递归的拷贝复制一份。

### 数组名和指针（数组首地址指针）区别？
+ 二者都可以通过增减偏移量来访问数组中的元素；
+ 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增自减的操作；
+ 当数组名当作形参传递给调用函数后，就退化成了一般指针了，也就有了自增自减的操作了。但sizeof运算符不能再得到原数组的大小了；

### 数组和指针的区别
1. 数组是在内存中开辟的一块连续的空间，而指针是一种数据类型，该数据类型的数值是是一块保存指定类型数据的内存的地址

### 野指针和悬空指针的区别？
+ 都是指向无效（无效是指“不安全不可控”的）内存区域的指针，访问行为将会导致为定义行为;
+ 野指针指的是没有初始化的指针；悬空指针是指向的区域已经被释放了的指针;
+ 解决方案：
    - 野指针：定义指针变量要及时初始化，要么置空；
    - 悬空指针：指针释放操作后要及时置空；

### 函数指针
+ 指向函数的指针，可以像一般函数一样用于调用函数，传递参数。
+ 作用就是想要在在同一函数中使用相同的形参在不同时间内传入不同的实参产生不一样的结果
+ 使用场景：排序函数中传入不同的比较算法，线程池

### 全局变量和局部变量有什么区别？
1. 生命周期不同
2. 作用域不同
3. 内存分配区域不同

### 全局变量和静态全局变量区别？
1. 作用域不同：全局变量作用域是整个源程序，静态全局变量作用域是当前文件作用域

### cout 和 printf 有什么区别？
1. printf 是 C 语言输出函数，cout 是 C++ 语言的输出流
2. printf 使用格式化字符串来输出数据，cout 使用插入运算符输出数据
3. cout 可以自动进行类型转换，printf 需要手动指定输出数据的类型
4. printf 是变参函数，没有类型检查不安全，cout 是通过运算符重载实现，安全
5. cout 输出方式更加安全，因为它不会出现格式化字符串中转义字符或格式化指示符类型错误的问题，并且参数的传递更加直观和易于维护

### ifdef、endif 有什么作用？
+ ifdef、endif 预处理指令，用于避免重复定义和包含，实现条件编译；
+ 使用 #define、#ifndef、#ifdef、#endif 避免头文件的重定义

### strcpy 、strncpy 、memcpy 的区别？
1. 复制内容不同。strcpy，strncpy 只能复制字符串，而 memcpy 复制的是一段内存区域的数据，这块内存区域可以是字符数组，整型，结构体，类
2. 复制的方法不同。strcpy 不需要指定长度，它遇到'\0'时自动结束，容易产生溢出；strncpy 复制指定数量的字符，而 memcpy 根据第三个参数决定复制的长度；
3. 用途不同。复制字符串时一般使用 strcpy，strncpy，复制其他类型时使用 memcpy；

### printf、sprintf、ssprintf 的区别
1. printf 将格式化的数据输出到标准输出流中，并返回输出的字符数
2. spritnf 将格式化的数据输出到字符串缓冲区中，并返回写入缓冲区的字符数
3. ssprintf 同 sprintf，但是它需要指定要写入缓冲区的最大字符数，避免缓冲区溢出

### strlen 和 sizeof 的区别？
1. sizeof 是运算符，在编译时就获得了结果；strlen 是字符处理的库函数；
2. sizeof 的参数可以是任何数据的类型或任何数据（sizeof参数不退化）；strlen 的参数只能是字符指针且结尾是 '\0' 的字符串；
3. 因为 sizeof 值在编译时就已经得到了，所以它不能用来得到动态分配存储空间的大小；

### extern"C" 的用法？
+ extern "C" 是 C++ 的一个关键字，用来指示编译器按照 C 语言的方式进行编译，实现 C/C++ 混编。
+ C++ 为了支持重载功能，C++ 编译器在编译阶段会对函数名进行“再次重命名”
    + 由原有的函数名和各个参数的数据类型构成一个新的函数名；
    + 但是 C 的编译器不支持重载，也就没有了这步额外的步骤；
    + 这个结果也就意味着在 C 和 C++ 进行混合编译时，会造成编译器在程序链接阶段无法找到函数具体的实现，导致链接失败。

### define 和 typedef、const、函数、内联函数四者的区别
+ define 是预编译指令，发生在预编译阶段，本质是文本替换，无类型检查
+ typedef 是重命名一个数据类型，发生在编译阶段，会有类型检查
+ const 是一个常量数据类型，编译会有类型检查，会分配内存，会将复杂的表达式计算出结果放入常量表中
+ 函数是调用时会执行函数调用流程，没有直接插入代码执行的快，有参数检查，数据类型返回等
+ 内联函数本质是个函数，在编译时进行替换，且会进行类型检查

### volatile 关键字用法
1. C++ 的一个类型修饰符，告诉编译器不再对指定变量的访问方式提供优化，即提供该变量的稳定访问。即每次使用该变量时必须从它所在的内存中读取地址。
2. 使用场景有：
    1. 中断服务程序：中断服务程序修改的供其他程序检测的变量需要加 volatile
    2. 多任务环境下：各个任务之间共享的标志应该加上 volatile
    3. 存储器映射的硬件寄存器：通常需要添加 volatile 说明，因为每次对它的读写可能都有不同意义


<!------------ Oriented Object C++ --------------------->


## Oriented Object C++

### 对象模型
+ C++ 对象模型是 C++ 语言中实现面向对象编程的机制之一。
+ 它包含了语言中直接支持面向对象程序设计的部分，如构造函数，析构函数，多态，虚函数等等，以及对于各种支持的底层实现机制
+ 对象模型的底层实现机制并没有标准化，不同的编译器有一定的自由度来设计对象模型的实现细节

### 解释 C++ 多态性和继承性
1. C++ 继承性
+ 继承是面向对象的三大特性之一，允许一个类继承另一个类的成员函数和成员变量
+ 通过派生的的机制来实现对已存在的类和模块的拓展，从而实现代码的服用

2. C++ 多态性
+ 通过虚函数，C++ 能实现相同对象在收到不同的消息或者同个对象收到相同消息产生不同的表现
+ C++ 有两种形式，一种是静态多态，一种是动态多态
    1. 静态多态指的是在编译时期就能确定函数的调用
    2. 动态多态指的是在程序实际运行时才能确定具体函数的调用

### 解释虚函数和纯虚函数
+ 用关键字 virtual 修饰的函数就是虚函数，虚函数用来实现 C++ 多态
+ 纯虚函数是虚函数后加 =0 声明，纯虚函数只有只有声明，实现是由继承的类来完成。纯虚函数用来抽象和规划修饰的函数接口的。

### 什么是虚函数表（virtual function table）？它在 C++ 中有什么作用？
+ 虚函数表是 C++ 实现多态的机制之一，它是一个指针数组，存储了一个类的虚函数地址。
+ 如果一个类中有虚函数，那么它就会自带虚函数表，它实例化的对象也会相应的含有一个指向虚函数表的指针，用于类对象在调用类虚函数表时的寻址
+ 当一个类被继承时，子类会继承父类的虚函数表，并且可以重写父类的虚函数。在运行时，如果子类对象调用了重写的虚函数，那么它回调用子类中的版本，而不是父类中的版本。

### 什么是 vtable 和 vptr？它们在 C++中有什么作用？
+ 虚函数表和虚函数是 C++ 实现多态的机制之一
+ 虚函数表是一个指针数组，存储量一个类的虚函数地址
+ 虚函数指针是带有虚函数表实例化对象拥有的指向虚函数表的指针，用来调用虚函数表中的虚函数。
    - 虚函数指针在内存结构中一般存储在类的对象的起始地址

### 什么是动态绑定，它的使用场景是什么？
1. 动态绑定指的是在程序实际运行时根据对象的实际类型来选择调用的方法和函数。
2. 在 C++ 中，虚函数重写，switch 语句和 if 语句会使用到动态绑定

### 解释编译时（compile-time）和运行时（run-time）多态（polymorphism），它们有什么区别？
+ 编译时多态指的是编译器对源程序编译时就可以确定所调用的是哪个函数了
+ 运行时多态指的是在程序之前无法根据函数名和函数参数来确定应该调用哪个函数，必须在程序执行时根据具体的代码动态确定执行哪个函数
+ 编译时多态性是通过函数的重载和重载操作符实现；动态时编译主要是通过虚函数实现；

### 解释 C++ 中的静态多态（static polymorphism）和动态多态（dynamic polymorphism）。
+ 静态多态指的是在编译时间就能确定函数的调用地址，并生成代码，通常通过函数重载，模板等机制实现。优点是效率高，缺点是灵活性差，只能处理已知类型的对象
+ 动态多态是指在运行时根据基类的引用指向的对象来确定调用哪一个虚函数。动态多态通常是通过虚函数、继承等机制实现。优点是灵活性高，缺点是效率低。

### 什么是 RAII 技术
+ RAII 是一种编程思想，它代表资源获取即初始化，是一种在 C++ 中管理资源的重要技术，这种思想和技术的目的可以确保在使用资源时，他们在不需要时能够被正确释放。
+ RAII 的实现方式是通过在对象构造函数中获取资源并在对象的析构函数中释放资源。这样当对象超出范围时，它的析构函数将会自动调用，从而释放资源。从而避免内存泄露和其他资源管理问题。
+ RAII 应用场景在内存管理，文件操作，线程同步等

### C++ 有哪些内存管理方式
+ RAII 技术
+ 智能指针
+ 容器类
+ 自定义资源管理类：可以根据具体需求实现资源的获取和释放逻辑

### 介绍智能指针和其作用
1. 概述
    + C++ 智能指针是一个之类，用来自动管理内存。它封装一个指针，并且提供了指针的内存管理方法
2. 类型
    1. unique_ptr：用于管理独占所有权的资源，它在确保不再需要时自动释放资源，并且不能共享所有权
    2. shared_ptr：用于管理共享所有权的资源，它可以跟踪有多少个指针共享同一个资源，并在不需要时自动释放资源
    3. weak_ptr：用于解决 shared_ptr 循环引用问题。它允许创建一个不增加引用计数的指针，便于观察 shared_ptr 指向的资源

### 什么是拷贝构造函数，赋值构造函数，赋值操作符
+ 拷贝构造函数是一种特殊的构造函数，用来创建一个新对象并将其初始化为与现有对象相同的值
+ 赋值构造函数也是一种特殊的构造函数，用来将一个已经存在的对象的值复制给另一个已经存在的对象
+ 赋值操作符是一个二元运算符，用来将右侧操作数的值复制给左侧操作数
    + C++ 的类中可以重写该操作符，完成类的复制

### fianl 和 override
+ final 和 override 关键字在 C++ 中对类继承和函数重写行为做了额外的限制
+ final 可以保护基类不被修改，防止滥用继承
+ override 关键字可以明确标识派生类对基类的虚函数进行重写，并在编译时进行类型检查

<!--------------- Generic ------------------>

## Generic

### 什么是模板（template）？它的优缺点？
+ 概念
    + 模板是 C++ 一种变成语言的特性，允许程序员编写通用代码，以便在不同数据类型上进行操作。
+ 优点：
    - 灵活性，可重用性，以及扩展性
    - 模板可以把同一个算法适用于不同类型的数据，在编译时确定具体的数据类型
    - 模板模拟多态要比 C++ 继承实现多态效率要高，无虚函数，无继承
+ 缺点
    - 模板代码通常要比非模板代码要更难阅读和理解
    - 模板代码可能会导致编译时间变慢
    - 模板代码可能会导致代码膨胀，从而增加可执行文件的大小

### 什么是元编程
+ 元编程是一种编程范式，它允许程序员便携通用代码，以便在不同数据类型上操作
+ 元编程中，程序本身是动态的，程序运行也是动态的。元编程将程序作为数据来对待，从而赋予变成语言更加强大的表达能力

### 元编程和模板的联系与区别
+ 联系
    + 两者都是 C++ 非常有用的特性，能够通过编写通用代码，达到代码复用的目的
+ 区别
    + 元编程更注重程序本身的动态性和灵活性，模板更注重通用代码的灵活性和可重用性

### [什么是模板特化](https://www.cnblogs.com/wanghao-boke/p/17750991.html)
+ 模板特化是指在模板的基础上，针对某些特定的值，提供一种特殊的实现方式，模板特化分为两种，类模板特化和函数模板特化
+ 类模板特化指的是在类模板上，针对某些特定的类型和值，提供一种特殊的实现方式。类模板特化分为全特化和偏特化两种。
    - 全特化是指将模板参数列表中的所有参数都确定化；
    - 偏特化是指模板参数列表的一部分参数确定化
+ 函数模板特化指的是在函数模板的基础上，针对某些特定的类型或值，提供一种特殊的实现方式。函数模板特化分为全特化和偏特化两种：
    - 全特化是指将函数模板中所有参数都确定化；
    - 偏特化是指将函数模板中的一部分参数确定化

### C++ 中的模板参数包（template parameter pack）是什么？它有什么作用？
+ 模板参数包是一种模板元编程技术，允许模板函数或者模板类接受可变数据的参数，这些参数被称为参数包。分为模板参数包和函数参数包
    - 模板参数包表示零个或多个模板参数
    - 函数参数包表示零个或多个函数参数。
+ 省略号用于指示一个模板参数包或函数参数包，在函数调用时，编译器会将这些参数打包成一个对象，以便在函数中使用

### 解释函数模板和类模板之间的区别
+ 函数模板和类模板都是 C++ 中的模板，区别是应用场景不同
+ 函数模板是一种可以用于多种不同类型的函数，而类模板则可以产生多个具有相同结构但是不同类型的类
+ 实例化也有所不同。模板函数在实例化时会根据传入的参数类型自动推导出类型，而类模板则需要显示地指定类型

### 什么是 SFINAE（Substitution Failure Is Not An Error）？
+ 在 C++ 中，当一个函数模板或者类模板实例化时，如果模板参数无法匹配，则编译器会尝试从其他可行的模板中选择一个，如果一个可选的模板都没有，那么编译则会报错。
+ 如果某个模板参数无法匹配是由于某种原因导致的编译错误，而不是模板本身的点问题，则编译不会报错，而是将模板从候选列表中删除，这种情况称之为 SFINAE
+ SFINAE 机制常用于模板元编程中，一边根据类型特征选择正确的函数或类模板。

### 什么是模板元编程（TMP）？它有什么应用场景
+ 模板元编程是一种 C++ 模板进行元编程的技术。他可以在编译时生成代码，而这些代码最终和普通代码一起编译执行。
+ 模板元编程的应用场景是：
    - 编译时计算
    - 补充类型系统
        - 模板提供了参数化的类型，给 C++ 补充自带的类型提供的方式，使得类型系统更加智能和完备
    - Domain Specific Language
        - 是一种针对特定应用领域进行设计的编程语言。与通用编程语言不同的是，DSL 更加专注于解决某个特定领域的问题，因此他们通常具有更高的抽象层次和更好的阅读性

### 解释 C++ 中的模板元编程（TMP）和泛型编程（generic programming）之间的区别
+ 泛型编程和模板元编程是两种不同的概念
    - 泛型编程主要是为了实现代码的重用和通用型
    - TMP 则是为了实现程序的自动生成和性能优化
+ 泛型编程是一种编程范式，目的是实现代码的重用。
    - 在泛型编程中，可以通过编程与数据类型无关的代码，从而实现代码的通用型。
    - 模板就是一种范式编程技术，可以通过它编写与数据类型无关的代码
+ 模板元编程是一种使用 C++ 模板来进行元编程的技术。
    - 元编程指的是在程序执行之前，通过编写程序来生成程序。在 TMP 中，可以使用模板来生成代码，从而实现程序的自动生成。
    - TMP 可以在编译期间进行计算，从而提高程序的性能


<!--------------- STL ------------------------>

## STL

### C++ 中的 STL 是什么？它包含哪些常用的容器类和算法？
1. STL 是标准模板库，提供常用的基本数据结构和算法
2. 容器类的由 vector，list，queue，deque，set，map
3. 算法类的有 sort，find，copy，for_each



<!--------------- C++ 11 --------------------->

## C++ 11 

### 函数对象
+ 顾名思义，就是对象可以像函数一样调用。一个重载 () 操作符的类的实例化对象可以像函数一样调用。
+ 优点
    - 一是该对象在多次调用中可以共享一个状态，如果是普通的话，需要一个全局变量实现该功能；
    - 二是函数对象可以有自己的特性，该特性在 STL 使用时很有用。

### lambda
+ C++ 引入的新特性，能够方便的定义和创建一个匿名函数，作用是帮助开发者在保持代码精简的同时不需要添加新的函数类
+ 捕获列表，参数列表，可选的修饰符，如 mutable，exception，返回值类型声明，结构体

### 异常
+ 异常指的是程序在执行过程中出了问题，无法继续执行下去的情况。比如除零操作，段错误，内存溢出等
+ C++ 提供 throw，try，catch 机制来处理程序执行过程中遇到了异常的情况。try 块中放置可能出现的异常的代码，catch 用来捕获异常，throw 用来抛出异常
+ C++ 提供了一系列的标准异常，定义在 <exception> 头文件中

### RTTI
+ 运行阶段类型识别，为了在程序运行时能确定某个对象的实际类型
+ RTTI 机制只适用于含有虚函数的类，主要是用在将多态指针转换成它指向的对象实际类型
+ C++ 有三个用来实现 RTTI 机制的元素，分别是 typeid，dynamic_cast，type_info
    + typeid：获取指针或引用所指的实际类型
    + dynamic_cast：安全地将基类指针或引用转换成派生类的指针和引用
    + type_info：存储了特定类型的对象信息

### C++ 左值和右值
1. 左值：表示可以获取地址的变量
2. 右值：表示无法获取地址的对象，有常量值、函数返回值、lambda 表达式等

### C++ 右值引用（rvalue reference）和左值引用（lvalue reference）
1. 左值引用：绑定一个有地址的对象，且不允许修改该对象，传统的 C++ 引用就是左值引用
2. 右值引用：绑定一个临时对象上去，即右值，且允许修改该临时对象。

### 右值引用？与左值引用有什么区别？
+ 绑定的对象不同
    - 右值引用是对不能取地址的值进行绑定，左值相反，只能绑定有地址的值，不能取地址的值只能绑定到常量引用去
+ 持续时间不同
    - 右值只能绑定到临时对象，所引用的对象将要销毁或该对象没有其他用户；而左值引用的变量都是持久性变量
+ 引用的目的不同
    - 右值引用为了支持移动构造，而左值引用是为了给变量起个别名，使用左值引用更安全

### C++11 中的移动语义（move semantics）是什么？它有什么作用？
+ 移动语义就是转移指定对象的内存所有权。能够在不需要拷贝操作的场合中执行数据转移。
+ 主要是为了解决 C++ 拷贝带来的资源消耗问题。通过移动语义，充分利用临时对象的构造来减少对象的构造和析构操作以达到提高效率的目的。

### 解释完美转发（perfect forwarding）。
+ 由万能引用 + 引用折叠 + std::forward() 来实现将函数模板中接受的参数的左右值属性和数值一同完美地传递给下一个调用函数

### 什么是 noexcept 关键字？它有什么作用？
+ 指定修饰的函数不会抛出异常
+ 编译器会在编译时期确定该函数是否会抛出异常，如果确实不会，编译器会对该函数进行优化，提升性能。
+ 如果修饰的函数在运行时抛出了异常，程序会终止，提升了程序的健壮性

### 解释 C++11 中的原子操作（atomic operation）和 std::atomic 类型。
1. 原子操作保证描述的操作是原子级别的，也就是同一时间只能有一个线程执行该操作
2. atomic 是 C++11 一种同步进制，它确保修饰的对象在被访问时是互斥的

### auto、decltype 和 decltype(auto) 的用法？
1. auto
    + 用于变量声明、函数返回值类型声明和模板参数声明
    + 用于变量初始化表达式的类型推导变量的类型，从而省略了显式类型声明
    + 用于函数返回值推导
    + 用于模板函数参数声明
2. decltype
    + 用于变量声明、表达式类型查询和函数返回值类型查询
    + 用于表达式推导出表达式的类型，并将其作为变量或者函数返回值类型的声明
    + 用于表达式类型查询
    + 用于函数返回值类型查询
3. decltype(auto): C++14 引入的关键字
    + 根据表达式推导处表达式的类型，并将其变量或函数返回值类型的声明
    + 用于函数返回值类型的推导

<!------------------------- C++ 11 End --------------------->

<!--------------------- Code test Start--------------------------->

## C++ Code test
### 什么是代码覆盖率（code coverage）
+ 是一种通过计算测试过程中被执行的源代码占全部源代码的比例，进而间接度量软件质量的方法。
    - 能在保证测试质量的同时，也潜在保证实际产品的质量。
+ 代码覆盖率测试一般细分为语句覆盖，判定覆盖，条件覆盖，条件判定组合覆盖，路径覆盖，多条件覆盖和修正条件覆盖等
    - 语句覆盖：度量被测代码中每个可执行语句是否被执行到
    - 判定覆盖：度量程序中的每一个判定的分支是否都被测试到
    - 条件覆盖：报告每一个子表达式的结果的是 true 和 false 是否被测试到
    - 修正条件覆盖：要求在一个程序中每一种输入输出至少得出现一次，在程序中的每一个条件必须产生所有可能的输出结果至少一次
        - 每一个判定中的每一个条件必须能够独立影响一个判断的输出
+ 代码覆盖率指标的设定需要考虑代码失效的成本，测试相关资源，可测行设计和开发迭代状态等
    - 一般而言 70%~80% 覆盖率比较合理

###  C++ 中的测试框架，例如 Google Test 和 Boost.Test。
+ [gtest](https://zhuanlan.zhihu.com/p/369466622)

### 在 C++ 中应该遵循哪些代码规范？

<!--------------------- Code test End--------------------------->