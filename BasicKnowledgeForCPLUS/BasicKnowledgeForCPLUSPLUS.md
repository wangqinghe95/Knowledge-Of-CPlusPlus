# Basic Knowledege for C/C++

<!------------ Basic C++ from C --------------------->
## 1、Basic C && C++

### C 和 C++ 的区别
1. 设计思想或者说是应用场景的区别
    + C 是基于内存占用和执行效率的考虑使它更趋近于底层，特点是越精简越高效，注重逻辑实现，也就是面向过程。多用于操作系统和驱动内核。
    + C++ 诞生的目的之一就是抽象和精简 C 的实现过程，注重程序的整体设计。适合做大型软件。
2. 由设计思想的不同，由此引申出来的种种实现和细节的不同，如C++比C多出来的关键，C++多出来的虚函数，重载的概念和实现。面向对象设计的核心类，甚至再往上完全和 C 没有任何关系的范式编程，元编程。都是两者具体上的差别。

### C++ 中 const 关键字
1. C++ const 是一个关键字，用于来声明所修饰的对象不要修改
2. 它可以修饰变量，指针，指针地址，函数参数，函数返回值，类成员函数，类对象等
3. 它的作用是防止修饰的对象被修改，有利于提高代码的可读性和可维护性，并减少错误的发生

### C++ 中指针和引用的区别
1. 引用在编译时会被解释成常指针，编译器完成取地址解引用的过程，在编译之后，两者在汇编层面上一样。
2. 在上层使用中，就是常指针和普通指针的区别

### 解释区间（range）和范围（span）。
+ 都表示一段连续的内存空间
+ 区间通常指的是左闭右开的区间。
+ 范围一般指的是左闭右闭的区间。

### 什么是强制内联（forced inline）？它与普通内联（normal inline）有什么区别？
+ 内联是 C++ 编辑器一种优化技术，它可以将函数的代码直接插到调用函数的地方去，从而避免了函数调用的开销。内联函数适用于代码比较少的函数，比如访问器函数，操作符重载函数等
+ 普通内联是由编辑器自主决定是否要进行内联优化，而强制内联是通过在函数声明前加上关键字 inline 和 __foreceinline 修饰符实现，强制内联会强制编译器对该函数进行内联优化，即使编译器认为这并不是最优选择
+ 需要注意的是强制内联可能会导致代码体积增大，从而影响程序的性能，所以应该谨慎使用强制内联，并在必要时进行性能测试和优化。

### static 关键字作用
+ static 修饰的变量存放在全局数据区的静态变量区中。这种变量的作用域受限在定义处的区域中，且该区域的变量生存周期是整个程序的运行周期
+ static 修饰的全局变量叫做静态全局变量
    - 只能本文件所见，不能被其他文件访问；
- static 修饰的局部变量被称为静态局部变量
    - 生存周期拉长到整个程序的生存周期，作用域是声明处的局部范围；
- static 修饰的类成员和类成员函数，被称为类的静态成员
    - 类的静态成员属于类本身，不属于类对象
    - 无需实例化就可以直接通过类名直接访问
- static 修饰函数，被称为静态函数
    - 只能本文件所见，不能被其他文件访问；

### 解释 C++ 中的强制类型转换（type casting）
+ static_cast：用于基础类型之间的转换
    - 如果用于基类和派生类之间的转换，那么在运行时是没有类型检查来保证转换的安全性的
+ dynamic_cast：主要用于类层次之间的上行转化或者下行转换
    - 上行转换时，效果等同于 static_cast
    - 下行转换时，dynamic_cast 有类型检查的功能
+ reinterpret_cast
    - 整数和指针之间相互转换，不安全，不推荐使用
+ const_cast
    - 用来修改表达式的 const 和 volatile 属性

### static_cast 比 C 中的强制转换有什么优势？
1. 更加安全，static_cast 在编译时会进行编译检查，如果类型转换不合法会报错，避免了类型转换错误的发生
2. 更加直观，能够清楚的看出代码中转换的类型，可读性更强

### C++ nullptr 和 NULL 有什么区别？
+ NULL 整型 0
+ nullptr 指针 0

### malloc 和 free 实现的原理？
1. 基于内存池实现
    + 内存池是一块预先分配好的内存区域，由大小相等的内存块组成
    + 当调用 malloc 时，程序会从内存池中找到一块足够大的内存块，将其标记为已用，分配给程序。
    + 当调用 free 时，将该块内存标记为未使用，并将其返回给内存池
2. 基于堆实现
    + 堆是一块动态分配的内存区域，有多个大小不等的内存块组成
    + 当调用 malloc 时，程序会在堆上找到一个足够大的空闲区域，并将其标记为已使用。
    + 当调用 free 时，程序会将该内存块标记为未使用，并将其合并到相邻的空闲区域中

### malloc、realloc、calloc 的区别
1. malloc 在堆上额分配指定指定字节数的存储区，该存储区的初始值不确定，需要 memset 处理
2. realloc 更改之前分配区的长度，可以对给定的指针所指的空间进行扩大或者缩小，原有内存内容保持不变
3. calloc 分配指定字节大小的存储区，会初始化分配的内存空间为零

### new/delete 和 malloc/free 的区别？
1. 类型不同：new 是操作符，需要编译器支持，malloc 是库函数，需要标准库支持
2. 参数不同，new 无需指定需要分配的内存大小，编译器会自己根据类型信息计算的的得出，malloc 是显式的指出申请所需的内存的大小
3. 返回值不同：new 申请内存成功后返回所指对象类型的指针，malloc 申请成功后返回的是 void*，根据需要再做强转
4. 申请失败后返回结果不同：new 抛出异常，malloc 返回一个 NULL
5. 申请自定义用户类型过程不同：new 申请内存后会自动调用自定义用户类型的构造函数，malloc 只会申请内存

### C++ 有几种类型 new？
+ plain new ： 常用的 new,在空间分配失败时抛出异常 std::bad_alloc 而不是返回 NULL
+ nothrow new ： 在空间分配失败情况下，不抛出异常而是返回 NULL
+ placement new ： 在一块已经分配成功的内存上重新构造对象或对象数组

### struct 和 class 的区别
+ C++ 中两者的区别是成员访问权限和继承方式不同
+ C struct 和 C++ struct 区别在于
    1. C++ 的 struct 是一种抽象数据类型，支持成员函数，支持访问权限，能够继承
    2. C 的 struct 只是用户自定义数据类型，是一些变量的集合体

### 判断两个结构体是否相等
1. 重写比较操作符
2. 对结构体变量一一比较
3. 对结构体指针指向的内容一一进行比较

### 形参和实参的区别
1. 形参是函数定义时用于接受参数的变量，是函数头部声明的变量，用于在函数内部用于进行计算和操作，在函数调用时才被会赋值
2. 实参是函数调用时传递给函数的参数，这个参数是一个值，在内存中有地址。
3. 形参和实参的功能是数据传送，发生函数调用时，主调用函数把实参的值传送给被调用函数的形参，从而实现从主调函数向被调函数的数据传输。


### 值传递、指针传递、引用传递的区别和效率？
+ 值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象，或是大的结构体对象，将耗费一定的时间和空间。（传值）
+ 指针传递：同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为 4 字节的地址。（传值，传递的是地址值）
+ 引用传递：同样有上述数据的拷贝过程，但是针对的地址，相当于为该数据所在的地址起了一个别名
+ 从效率上说，指针传递和引用传递的效率要比值传递的效率要高，一般主张使用引用传递，代码逻辑上更加紧凑，清晰；

### 将引用作为函数参数的好处是什么？
1. 节省内存空间，引用作为一个别名，不需要暂用额外的内存空间，编译器会自动将其视为原始变量的别名，并将其替换为原始变量的地址
2. 提高程序执行效率，直接操作原始变量地址，避免变量复制拷贝操作，而且可以作为传出参数使用
3. 代码阅读性好

### 指针参数传递和引用参数传递有什么区别？底层原理是什么？
1. 没有很大的区别，引用底层就是常量指针。
2. 指针参数传递传过去了一个数值，这个数值是一个内存地址。引用传递传过去的实参的地址。

### 什么时候用指针当参数，什么时候用引用当参数，为什么？
1. 传递数组用指针
2. 传递类对象，用指针或者引用
3. 内置数据都行
4. 如果可以区分会不会修改传入的参数的值，可以用 const 标识，以提高程序运行效率

### 深拷贝和浅拷贝
+ 浅拷贝只复制指向某个对象的指针的值，而不复制指向的对象本身，新旧对象共享同一块内存。
+ 深拷贝会重新开辟空间，将指针指向的对象的内容递归的拷贝复制一份。

### 数组名和指针（数组首地址指针）区别？
+ 二者都可以通过增减偏移量来访问数组中的元素；
+ 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增自减的操作；
+ 当数组名当作形参传递给调用函数后，就退化成了一般指针了，也就有了自增自减的操作了。但sizeof运算符不能再得到原数组的大小了；

### 数组和指针的区别
1. 数组是在内存中开辟的一块连续的空间，而指针是一种数据类型，该数据类型的数值是是一块保存指定类型数据的内存的地址

### 野指针和悬空指针的区别？
+ 都是指向无效（无效是指“不安全不可控”的）内存区域的指针，访问行为将会导致为定义行为;
+ 野指针指的是没有初始化的指针；悬空指针是指向的区域已经被释放了的指针;
+ 解决方案：
    - 野指针：定义指针变量要及时初始化，要么置空；
    - 悬空指针：指针释放操作后要及时置空；

### 函数指针
+ 指向函数的指针，可以像一般函数一样用于调用函数，传递参数。
+ 作用就是想要在在同一函数中使用相同的形参在不同时间内传入不同的实参产生不一样的结果
+ 使用场景：排序函数中传入不同的比较算法，线程池

### 全局变量和局部变量有什么区别？
1. 生命周期不同
2. 作用域不同
3. 内存分配区域不同

### 全局变量和静态全局变量区别？
1. 作用域不同：全局变量作用域是整个源程序，静态全局变量作用域是当前文件作用域

### cout 和 printf 有什么区别？
1. printf 是 C 语言输出函数，cout 是 C++ 语言的输出流
2. printf 使用格式化字符串来输出数据，cout 使用插入运算符输出数据
3. cout 可以自动进行类型转换，printf 需要手动指定输出数据的类型
4. printf 是变参函数，没有类型检查不安全，cout 是通过运算符重载实现，安全
5. cout 输出方式更加安全，因为它不会出现格式化字符串中转义字符或格式化指示符类型错误的问题，并且参数的传递更加直观和易于维护

### ifdef、endif 有什么作用？
+ ifdef、endif 预处理指令，用于避免重复定义和包含，实现条件编译；
+ 使用 #define、#ifndef、#ifdef、#endif 避免头文件的重定义

### strcpy 、strncpy 、memcpy 的区别？
1. 复制内容不同。strcpy，strncpy 只能复制字符串，而 memcpy 复制的是一段内存区域的数据，这块内存区域可以是字符数组，整型，结构体，类
2. 复制的方法不同。strcpy 不需要指定长度，它遇到'\0'时自动结束，容易产生溢出；strncpy 复制指定数量的字符，而 memcpy 根据第三个参数决定复制的长度；
3. 用途不同。复制字符串时一般使用 strcpy，strncpy，复制其他类型时使用 memcpy；

### printf、sprintf、ssprintf 的区别
1. printf 将格式化的数据输出到标准输出流中，并返回输出的字符数
2. spritnf 将格式化的数据输出到字符串缓冲区中，并返回写入缓冲区的字符数
3. ssprintf 同 sprintf，但是它需要指定要写入缓冲区的最大字符数，避免缓冲区溢出

### strlen 和 sizeof 的区别？
1. sizeof 是运算符，在编译时就获得了结果；strlen 是字符处理的库函数；
2. sizeof 的参数可以是任何数据的类型或任何数据（sizeof参数不退化）；strlen 的参数只能是字符指针且结尾是 '\0' 的字符串；
3. 因为 sizeof 值在编译时就已经得到了，所以它不能用来得到动态分配存储空间的大小；

### extern"C" 的用法？
+ extern "C" 是 C++ 的一个关键字，用来指示编译器按照 C 语言的方式进行编译，实现 C/C++ 混编。
+ C++ 为了支持重载功能，C++ 编译器在编译阶段会对函数名进行“再次重命名”
    + 由原有的函数名和各个参数的数据类型构成一个新的函数名；
    + 但是 C 的编译器不支持重载，也就没有了这步额外的步骤；
    + 这个结果也就意味着在 C 和 C++ 进行混合编译时，会造成编译器在程序链接阶段无法找到函数具体的实现，导致链接失败。

### define 和 typedef、const、函数、内联函数四者的区别
+ define 是预编译指令，发生在预编译阶段，本质是文本替换，无类型检查
+ typedef 是重命名一个数据类型，发生在编译阶段，会有类型检查
+ const 是一个常量数据类型，编译会有类型检查，会分配内存，会将复杂的表达式计算出结果放入常量表中
+ 函数是调用时会执行函数调用流程，没有直接插入代码执行的快，有参数检查，数据类型返回等
+ 内联函数本质是个函数，在编译时进行替换，且会进行类型检查

### volatile 关键字
1. C++ 的一个类型修饰符，告诉编译器不再对指定变量的访问方式提供优化，即提供该变量的稳定访问。即每次使用该变量时必须从它所在的内存中读取地址。
2. 使用场景有：
    1. 中断服务程序：中断服务程序修改的供其他程序检测的变量需要加 volatile
    2. 多任务环境下：各个任务之间共享的标志应该加上 volatile
    3. 存储器映射的硬件寄存器：通常需要添加 volatile 说明，因为每次对它的读写可能都有不同意义

### mutable 关键字
1. C++ 一种类型修饰符，主要用来修饰成员变量。
2. 通知编译器该成员变量可以在 const 函数中被修改。常用于实现缓存或者计数等功能

### C++ 有哪些内存管理方式
+ RAII 技术
+ 智能指针
+ 容器类
+ 自定义资源管理类：可以根据具体需求实现资源的获取和释放逻辑

### 什么是隐式转换，如何消除隐式转换？
1. 什么是隐式转换
    + 隐式转化意思是不需要用户干预，编译器私下进行的类型转换行为。
    + 基础数据类型的隐式转换发生在小精度到大精度的转换中；比如 char=>int,int->long；自定义对象中子类对象可以隐式转换为父类对象；
2. 如何消除隐式转换
    + C++ 提供了explicit 关键字，在构造函数声明的时候加上可以禁止隐式转换；
    + 如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制。可以通过将构造函数声明为 explicit 加以制止专类转换，explicit 关键字只对一个参数的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，所以无需为这些构造函数指定 explicit

### 什么是对象复用？什么是零拷贝？
+ 对象复用：本质是设计模式中的享元模式，通过将对象存储到“对象池”中是先对对象的重复利用，避免多次重复创建对象的开销，节约系统资源；
+ 零拷贝：一种避免 CPU 将数据从一块存储拷贝到另一块存储的技术，可以减少数据拷贝和共享总线操作的次数；

### 指针和引用之间如何转换？
1. 指针转换是将指针类型的对象转换成引用类型对象，可以用在引用参数当中
2. 引用转换是将引用类型的对象转换成指针类型的对象，可以通过取地址符号获得指针

### 函数中有重载时，函数的匹配原则和顺序是什么？
1. 名字查找；
2. 确定候选函数
3. 寻找最佳匹配


-----------------------------------------


<!------------ Oriented Object C++ --------------------->


## 2、Oriented Object C++

### 对象模型
+ C++ 对象模型是 C++ 语言中实现面向对象编程的机制之一。
+ 它包含了语言中直接支持面向对象程序设计的部分，如构造函数，析构函数，多态，虚函数等等，以及对于各种支持的底层实现机制
+ 对象模型的底层实现机制并没有标准化，不同的编译器有一定的自由度来设计对象模型的实现细节

### 解释 C++ 三大特性
1. C++ 继承性
    + 继承是面向对象的三大特性之一，允许一个类继承另一个类的成员函数和成员变量
    + 通过派生的的机制来实现对已存在的类和模块的拓展，从而实现代码的服用
2. C++ 多态性
    + 通过虚函数，C++ 能实现相同对象在收到不同的消息或者同个对象收到相同消息产生不同的表现
    + C++ 有两种形式，一种是静态多态，一种是动态多态
        1. 静态多态指的是在编译时期就能确定函数的调用
        2. 动态多态指的是在程序实际运行时才能确定具体函数的调用
3. 封装
    + 一种将数据和方法结合在一起的机制，一边于控制对数据的访问。
    + 封装可以防止程序中的错误，同时也可以使代码更加易于维护和重用

### C++ 多态是如何实现的
1. C++ 编译器在解析源码中有类关键词 virtual 时，会给该类生成一个虚函数表，即一个指针，指向一个一维数组
    + 编译器会将每一个被 virtual 关键字修饰的函数地址添加到虚函数表中，即添加一个指向该类函数的虚函数地址指针
2. 该类被实例化时，该实例的内存中会存储一个指向该类的虚函数表的指针
3. 当示例调用虚函数时，程序会根据该实例的虚函数表指针找到该类的虚函数表，然后根据函数在虚函数表中的位置找到该虚函数地址，并且调用该虚函数

### 是什么是类的继承？
+ 类与类之间的关系：
    - 包含关系：一个类是另一个类的成员；
    - 使用关系：一个类使用另一个类的成员函数，实现方式是使用友元函数或者传递函数指针；
    - 继承关系：关系具有传递性；
+ 概念：一个类包含另一个类的属性和方法，继承的被称为子类或者派生类，被继承的被称为父类或者基类；
+ 特点：子类拥有父类的所有属性和方法，子类也可以定义的属性和方法，子类对象可以当作父类对象使用；
+ 访问控制：public、private、protected

### C++ 的组合和继承有什么区别和优缺点？
+ 继承：
    + 优点：子类可以重写父类的方法来方便地实现对父类函数进行扩展；
    + 缺点：
        1. 父类的内部细节对子类是可见的；
        2. 子类从父类继承的方法在编译时就确定下来了，所以无法在运行期改变从父类继承的方法的行为；
        3. 如果对父类的方法做了修改的话，则子类必须作出相应的修改，所以说子类和父类是一种高耦合，违背了面向对象的思想；
+ 组合：设计类时把组合的类加入到该类中作为自己的成员变量
    + 优点：
        1. 当前对象只能通过所包含的那个对象区调用其方法，所以所包含的对象的内部细节对当前对象是不可见的；
        2. 当前对象与包含的对象是一个低耦合关系，如果修改所包含对象的类中代码不需要修改当前对象类的代码；
        3. 当前对象可以在运行时动态的绑定所包含的对象，可以通过 set 方法给所包含的对象赋值；
    + 缺点：
        1. 容易产生过多的对象
        2. 为了组合多个对象，必须仔细对借口进行定义


### 如果想将某个类作为一个基类，为什么该类必须定义而非声明？
1. 派生类中包含并且可以使用它从基类继承而来的成员，为了使用这些成员，派生类必须知道他们是什么
2. 如果只是声明而非定义，编译器就无法确定基类的大小和布局，也无法确定派生类中基类成员的位置和大小，从而无法生成派生类的对象代码

### 关于 this 指针？
+ 概念：
    + this 指针是类的指针，指向对象的首地址；
    + this 指针只能在成员函数中使用，在全局函数、静态成员函数中无法使用；
    + this 指针只有在成员函数中定义才有意义，且存储位置因编译器不同而不同；
+ 作用：
    + 指向当前所在对象，通过它可以访问到当前对象的所有成员；
+ 使用： 
    + this 是一个常指针，使用方式等同于常指针；
+ 特点：
    + this 只能在成员函数中使用，全局函数、静态函数都不能使用 this。实际上成员函数默认第一个参数为 T* const this;
    + this 在成员函数开始前构造，在成员函数结束后清楚，生命周期等同于函数的参数。当调用一个类的成员函数时，编译器将类的指针作为函数 this 参数传递进去；
    + 编译器会对 this 作优化，因此 this 指针传递效率较高；
+ 创建时间
    - this 指针在成员函数开始执行前构造，在成员函数执行结束后清除；  
+ 存放地址  
    - this 存放位置会因为编译器的不同而不同，栈、寄存器、全局变量都有可能。
    - 在汇编级别里，一个值只会以三种形式存在，立即数，寄存器值，内存变量值。不是放在寄存器中就是放在内存中。
+ 汇编使用过程
    - 大多编译器是通过 ecx（计数寄存器）传递this指针；
    - 在调用之前，编译器会把对应的对象地址放到 eax 中，this 是通过函数参数的首参来传递的。
+ 访问对象
    - this 指针实际上就是对象的首地址，通过偏移量来访问类中的变量的；
+ 使用限制
    - this 指针只有在成员函数中有定义，获得一个对象无法知道该对象的this指针的位置，所以就算知道this指针的位置，也没法使用。

### 在成员函数中 delete this 会出现什么问题？对象还可以使用吗？
1. 会导致类对象内存空间释放，在此之后进行的任何成员函数调用，只要不涉及到 this 指针的内容都能够正常运行，一旦涉及到 this 指针，如操作数据成员，调用虚函数等，就会出现未定义错误
2. 当 this 指针删除后，对象无法再使用，因为对象的内存空间已经被释放了。

### 类析构函数中调用 delete this 会发生什么事情
1. 会导致堆栈溢出。delete this 会去调用类的析构函数，析构函数调用 delete this，形成无限递归，最终导致堆栈溢出。

### this 指针调用成员变量时，堆栈会发生变化吗?
1. 当在类的非静态成员函数中访问类的非静态成员，编译器会自动将对象的地址作为隐含参数传递给函数，这个隐含参数就是 this 指针。
2. 对于类中个成员的访问都是通过 this 指针去调用的。
3. 当 this 指针调用成员变量时，该变量会入栈

### public/protected/private 区别和访问、继承权限？
1. 访问权限
    + public 的变量和函数在类的内部外部都可以访问；
    + protected 的变量和函数只能在类的内部和其派生类中访问
    + private 修饰的元素只能在类的内部访问
2. 继承权限
    + public：基类公有成员和保护成员被派生类中继承且访问权限不变
    + protected：基类公有成员和保护成员被派生类中继承且访问权限都设置为 protected
    + private：基类公有成员和保护成员被派生类中继承且访问权限都设置为 private


### 类对象大小是如何计算？
+ 非静态成员的数据类型大小之和；
+ 编译器加入的额外成员变量（如指向虚函数表的指针）
+ 为了内存对齐优化加入的 padding。
+ 空类（无静态数据成员）的对象 size 为 1，当作为基类时，size 为 0；
+ 派生类继承的基类的成员变量

### C++ 有哪几种构造函数？
1. 构造函数种类
    + 默认构造函数
    + 初始化构造函数
    + 拷贝构造函数
    + 移动复制构造函数
    + 委托构造函数
    + 转换构造函数
2. 构造函数介绍
    + 默认构造函数和初始化构造函数在定义类的对象，完成对象的初始化工作；
    + 复制构造函数用于复制文本类的对象；
    + 转换构造函数用于将其他类型的变量，隐式转换为本类对象；

### 什么是拷贝构造函数，赋值构造函数，赋值操作符
+ 拷贝构造函数是一种特殊的构造函数，用来创建一个新对象并将其初始化为与现有对象相同的值
+ 赋值构造函数也是一种特殊的构造函数，用来将一个已经存在的对象的值复制给另一个已经存在的对象
+ 赋值操作符是一个二元运算符，用来将右侧操作数的值复制给左侧操作数
    + C++ 的类中可以重写该操作符，完成类的复制

### 什么是成员列表初始化？什么时候必须要用初始化成员列表？调用过程?
+ 概念：在类的构造函数中，不在函数体内对成员变量进行赋值，而是在构造函数的花括号前面使用冒号和初始化列表赋值；
+ 效率：用初始化列表会快一些的原因是，对于类型它少一次构造函数的调用过程，而在函数体内赋值则会多一次调用，对于内置数据类型没有差别；
+ 必须使用：
    - 初始化一个引用成员变量时；
    - 初始化一个 const 成员变量时；
    - 调用一个基类的构造函数，而基类构造函数拥有一组参数时；
    - 当调用一个成员类的构造函数，而它的构造函数有一组参数时；
+ 调用过程：编译器会一一操作初始化列表，以适当的声明顺序在构造函数之内安插初始化操作，并且在任何显示用户代码前。成员列表的初始化顺序是按照类中成员声明顺序决定的，不是初始化列表中排列顺序决定的；

### 拷贝构造函数介绍？
1. 拷贝构造函数是一种特殊的构造函数，用于创建一个新的对象，该对象是已有对象的副本
    + 拷贝构造函数的参数是一个常量引用，它指向要复制的对象
    + 拷贝构造函数的主要任务就是创建一个新对象，并将其初始化为现有对象的副本
2. 构造函数在以下情况中会被调用
    1. 当一个对象以值传递的方式传递给函数时，构造函数会被调用
    1. 当一个对象以值传递的方式从函数返回时，构造函数会被调用
    1. 当一个对象需要通过另一个对象进行初始化时，构造函数会被调用

### 移动构造函数
+ 移动构造函数是一种特殊的构造函数，用于创建一个新的对象，该对象是已有对象的右值引用
    + 在 C++ 11 中，移动构造函数是通过右值引用实现的
    + 当我们使用右值引用调用移动构造函数时，就会发生移动语义
    + 所谓的移动语义，就是将资源从一个对象转移到另一个对象，而不是复制资源，避免不要的内存分配和复制操作
+ 移动构造函数通常用于一下情况
    1. 当一个对象以右值引用的方式传递给函数
    2. 当一个对象以右值引用的方式从函数中返回
    3. 当一个对象通过另一个对象进行初始化时

### 拷贝初始化和直接初始化的区别？
1. 拷贝初始化调用拷贝构造函数，函数参数是拷贝对象的引用或者值
2. 直接初始化调用与实参匹配的构造函数

### 构造函数的几种关键字？
+ default:显示的要求编译器生成合成构造函数，防止在调用时相关构造函数类型没有定义而报错；
+ delete:删除构造函数、赋值运算符函数等；
+ =0 ： 定义纯虚函数；

### 类成员初始化方式有哪些，它们有什么区别？
1. 赋值初始化：在构造函数内部对成员变量一一初始化
2. 成员初始化列表：在构造函数的花括号前面使用冒号和初始化列表赋值
3. 它们之间的区别主要是分配内存时间和赋值时间的差别。前者是先分配空间后，再赋值，后者是在分配的空间同时赋值。后者少一次内存寻址的过程。

### 构造函数和析构函数的执行顺序是什么？
+ 一个派生类的构造函数执行顺序如下：
    1. 基类的构造函数按照继承的顺序从左向右依次调用
    2. 派生类的成员变量按照声明的顺序一次被构造
    3. 派生类的构造函数被吊用，执行派生类的构造逻辑
+ 一个派生类的析构函数执行顺序如下：
    1. 调用派生类的析构函数
    2. 调用成员对象类的析构函数
    3. 调用基类的析构函数

### 什么时候会调用类的析构函数
1. 对象声明周期结束时。如对象超出其作用域或者被 delete 运算符删除时
2. 类包含类时，外部类析沟函数被调用时，内部类的析构函数也会被调用
3. 指向子类的基类指针在被销毁时，会调用子类的析构函数

### 析构函数的作用？以及是如何起作用的？
1. 析构函数是一种特殊的成员函数，用于释放对象占用的资源
2. 析构函数没有参数，也没有返回值，而且不能重载，在一个类中只能有一个析构函数，当撤销对象时，编译器也会自动调用析构函数；
3. 每一个类中必须有一个析构函数，用户可以自定义析构函数，也可以是编译器自动生成的默认的析构函数，一般析构函数定义为类的公有属性

### 为什么析构函数一般写成虚函数？
+ 为了避免内存泄漏，当基类指针指向派生类对象时，如果删除该基类指针，就会调用指针指向的派生类析构函数，而派生类的析构函数又会去自动调用基类的析构函数，这样整个派生类的对象就完全被释放了；
+ 如果析构函数不声明为虚函数，则编译器实施静态绑定，这样整个派生类的对象完全被释放。在删除基类指针时，只会调用基类的析构函数而不调用派生类的析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏。
+ 在实现多态时，当用基类操作派生类时，在析构时防止只析构基类而不析构派生类的状况发生，所以要将基类的析构函数声明为虚函数。

### 为什么构造函数不能是虚函数
1. 构造函数是在创建对象时自动调用，不能通过父类指针或者引用区调用
2. 虚函数的调用依赖于虚函数表，而指向虚函数表的指针需要在构造函数中初始化
3. 所以构造函数无法定义为虚函数

### 父类的析构函数是否能定义为纯虚函数
1. 能定义为纯虚函数，但是需要给父类的纯虚构虚函数进行定义，原因是编译器必须要产生一个调用链。
2. 所以虽然父类的析构函数可以定义为纯虚函数，但是不提议，而且定义为纯虚函数也无实际意义。

### 在构造函数和析构函数中可以调用虚函数吗？
1. 可以调用，但是可能会导致一些问题出现，所以不提倡
2. 构造函数中调用虚函数，由于对象的成员变量没有被初始化，因此调用的虚函数都是基类的版本，而不是派生类的版本
3. 析构函数中调用虚函数，由于派生类的成员变量都已经被销毁，因此调用的虚函数也是基类的版本。

### 构造函数和析构函数中是否可以抛出异常
1. 可以抛出异常，但是这样做可能会有一些问题
2. 构造函数中抛出异常，但是会导致析构函数不能被调用，虽然对象本身已申请到的内存资源会被系统释放，但是还是有造成内存泄露的风险
3. 析构函数抛出异常会导致程序过早结束或出现不明确的行为。
4. 所以构造函数尽量不要抛出异常，析构函数不要抛出异常

### 构造函数，拷贝构造函数，赋值操作符之间的区别
+ 构造函数：一种特殊的类成员函数，创建对象时对类的数据成员进行初始化和内存分配。构造函数可以被重载，可以多个，可以带参数
+ 拷贝构造函数：一种特殊的构造函数，用同类型的另一个对象初始化新对象,使用传入对象的值生成一个新的对象的实例。可以被重载，注意内存泄露.
+ 赋值运算符：一种特殊的类成员函数，将一个对象的值复制给另一个对象。复制的对象是已经初始化过后的对象。
+ 值得注意的是，当类中指针变量时需要重写析构函数，拷贝构造函数，和赋值运算符

### 构造函数、析构函数、虚函数是否能声明为内联函数？
+ 语法上没有错误，因为 inline 只是一个建议，编译器不一定会真正内联；
+ 析构函数和构造函数声明为内联函数是没有意义的：
    - class 中的函数都是默认内联的，编译器也是选择性的 inline；
    - 编译器在构造函数和析构函数中添加额外的操作（申请/释放内存，构造/析构对象），导致构造函数和析构函数并不是看上去那么内联；
+ 虚函数的 inline 是看情况的：
    - 如果是指向派生类的指针调用被声明为 inline 的虚函数不会被内联展开，但是对象本身调用不复杂的虚函数时，会内联展开；

### 什么情况会自动生成默认构造函数？
1. 带有默认构造函数的类成员函数。
    - 如果一个类没有任何构造函数，但它含有一个成员对象，而后者有默认构造函数，那么编译器就为该为该类合成一个默认构造函数。该合成函数只有在构造函数真正被需要的时候才会发生；
    - 如果一个类中有多个成员类对象的话，那么该类的每一个构造函数必须调用每一个成员对象的默认构造函数并且必须按照类对象在该类中的声明顺序进行；
2. 带有默认构造函数的基类
    - 如果一个没有构造函数的派生类派生自一个带有默认构造函数基类，那么该派生类会合成一个古朴造函数调用上一层基类的默认构造函数；
3. 带有一个虚函数的类；
4. 带有一个虚基类的类；
5. 合成的默认构造函数中，只有基类子对象和成员类对象会被初始化。所有其他的非静态数据成员都不会被初始化。

### 抽象基类为什么不能创建对象？
+ 在面向对象程序设计中，很多情况下基类本身生成对象是不合理的，并且为了实现多态，需要在基类中定义虚函数。为了解决这个联动问题，就引入了纯虚函数；
+ 将函数定义为纯虚函数后，该类就被成为抽象类，在该类中就无法创建对象了。
+ 所以说不是抽象基类不能创建对象，而是我们定义一个不能创建对象的类，取名为抽象基类；


### 什么是 trivial destructor？
+ 默认的，由系统自动生成的析构函数；

### 重载、重写、隐藏的区别
+ 重载（overload）：在同一范围定义中，存在参数类型、数量和顺序不同，但是函数名相同的两个或者以上函数；他们的关系称之为重载；
+ 重写（override）：派生类中的函数覆盖基类的同名函数，要求基类函数和必须是虚函数，且必须与基类的虚函数有相同的参数个数，参数类型和返回值类型；
+ 隐藏（hide）：派生类的函数会隐藏其父类同名函数（只需要函数名相同）；


### 解释虚函数和纯虚函数
+ 用关键字 virtual 修饰的函数就是虚函数，虚函数用来实现 C++ 多态
+ 纯虚函数是虚函数后加 =0 声明，纯虚函数只有只有声明，实现是由继承的类来完成。纯虚函数用来抽象和规划修饰的函数接口的。

### 什么是虚函数表（virtual function table）？它在 C++ 中有什么作用？
+ 虚函数表是 C++ 实现多态的机制之一，它是一个指针数组，存储了一个类的虚函数地址。
+ 如果一个类中有虚函数，那么它就会自带虚函数表，它实例化的对象也会相应的含有一个指向虚函数表的指针，用于类对象在调用类虚函数表时的寻址
+ 当一个类被继承时，子类会继承父类的虚函数表，并且可以重写父类的虚函数。在运行时，如果子类对象调用了重写的虚函数，那么它回调用子类中的版本，而不是父类中的版本。

### 什么是 vtable 和 vptr？它们在 C++中有什么作用？
+ 虚函数表和虚函数是 C++ 实现多态的机制之一
+ 虚函数表是一个指针数组，存储量一个类的虚函数地址
+ 虚函数指针是带有虚函数表实例化对象拥有的指向虚函数表的指针，用来调用虚函数表中的虚函数。
    - 虚函数指针在内存结构中一般存储在类的对象的起始地址

### 静态函数能定义为虚函数吗？常函数呢？
1. 静态成员函数是不能定义为虚函数，因为访问虚函数需要通过 this 指针，而静态成员函数没有隐式 this 指针
2. 常函数可以是虚函数。

### 哪些函数不能定义为虚函数？
1. 友元函数，它不是类的成员函数；
2. 全局函数；
3. 静态成员函数（没有this指针）；
4. 构造函数、拷贝构造函数；


### 虚函数的代价？
+ 带有虚函数的类，每个类都会产生一个虚函数表，用来存储指向虚函数成员的指针；
+ 带有虚函数的类的每一个对象，都会有一个指向类虚表的指针，会增加对象的空间大小；
+ 不能再是内联函数，因为内联函数在编译阶段会被替代，而虚函数表示等待，在运行阶段才能确定到底采用哪个函数，虚函数不能是内联函数；

### 基类的虚函数表存储在内存的什么位置（哪个区）？虚表指针 vptr 的初始化位置？
+ 基类的虚函数表存储在内存的只读数据段，也就是内存模型中常量区；
+ vptr 虚表指针是在类在进行实例化时，构造函数的执行时进行初始化，存在对的前四象个字节；

### 虚拟继承
1. 虚拟继承是C++中用于实现虚基类的机制。通过虚拟继承，可以确保在多重继承中只有一个共享的虚基类实例。
2. 虚拟继承使用关键字"virtual"来声明基类，以指示这是一个虚基类。虚拟继承的主要目的是解决多重继承中的菱形继承问题和冗余数据问题。
    + 当一个派生类通过多个路径继承同一个基类时，如果不使用虚拟继承，每个路径都会在派生类对象中包含一份基类实例，导致数据冗余和访问冲突。
3. 通过使用虚拟继承，基类的实例只会在派生类对象中存在一次，而不会重复出现。这样可以确保共享的基类成员只有一个实例，避免了冗余数据和访问冲突的问题.

### 虚继承？
+ 为了解决多继承时命名冲突和冗余数据问题，产生了虚继承，使得派生类中只保留一份间接基类的成员；
+ 在继承方式前面加上 virtual 关键字就是虚继承；
+ 虚继承的目的就是为了让某个类做出声明，承诺愿意共享它的基类，其中这个被共享的基类就是虚基类。

### 虚函数内存结构，棱形继承的虚函数内存结构呢？

### 什么是动态绑定，它的使用场景是什么？
1. 动态绑定指的是在程序实际运行时根据对象的实际类型来选择调用的方法和函数。
2. 在 C++ 中，虚函数重写，switch 语句和 if 语句会使用到动态绑定

### 引用是否能实现动态绑定，为什么可以实现？
+ 可以实现，但仅限于在调用虚函数时。
+ 在访问虚函数时编译器会根据所绑定的对象类型决定调用哪个函数。

### 解释编译时（compile-time）和运行时（run-time）多态（polymorphism），它们有什么区别？
+ 编译时多态指的是编译器对源程序编译时就可以确定所调用的是哪个函数了
+ 运行时多态指的是在程序之前无法根据函数名和函数参数来确定应该调用哪个函数，必须在程序执行时根据具体的代码动态确定执行哪个函数
+ 编译时多态性是通过函数的重载和重载操作符实现；动态时编译主要是通过虚函数实现；

### 解释 C++ 中的静态多态（static polymorphism）和动态多态（dynamic polymorphism）。
+ 静态多态指的是在编译时间就能确定函数的调用地址，并生成代码，通常通过函数重载，模板等机制实现。优点是效率高，缺点是灵活性差，只能处理已知类型的对象
+ 动态多态是指在运行时根据基类的引用指向的对象来确定调用哪一个虚函数。动态多态通常是通过虚函数、继承等机制实现。优点是灵活性高，缺点是效率低。

### 静态类型和动态类型、静态绑定和动态绑定的介绍
+ 静态类型：对象在声明时采用的类型，在编译期既已确定；
+ 动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期才决定的；
+ 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于静态类型，发生在编译期；
+ 动态绑定：绑定的动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；

### 继承机制中对象直接如何转换？
1. 继承机制中对象之间的转换分为两种类型：向上类型转换和向下类型转换
2. 向上类型转换是指将派生类的指针或引用转换成基类的指针或引用。
    - 向上类型转转会自动进行，且向上类型转换是安全的
3. 向下类型转换是将基类的指针或引用转换派生类指针或引用
    - 向下类型转换不会自动类型，因为一个基类对应几个派生类，所以向下类型转换时不知道对应哪个派生类
    - 所以向下类型转换需要加动态类型识别技术，如 RTTI，用 dynamic_cast 进行向下转换


### 什么是 RAII 技术
+ RAII 是一种编程思想，它代表资源获取即初始化，是一种在 C++ 中管理资源的重要技术，这种思想和技术的目的可以确保在使用资源时，他们在不需要时能够被正确释放。
+ RAII 的实现方式是通过在对象构造函数中获取资源并在对象的析构函数中释放资源。这样当对象超出范围时，它的析构函数将会自动调用，从而释放资源。从而避免内存泄露和其他资源管理问题。
+ RAII 应用场景在内存管理，文件操作，线程同步等

### 介绍一下重载运算符？
1. 重载运算符只能重载已有的运算符；对于一个重载的运算符，其优先级和结合律与内置的一致才可以；不可以改变运算符操作个数；
2. 重载方式为两种：成员运算符和非成员运算符，成员运算符比非成员运算符少一个参数；下标运算符、箭头运算符必须是成员运算符；
3. 引入运算符重载是为了实现类的多态性；
4. 当重载的运算符是成员函数时，this 绑定在左侧运算符对象。成员运算符函数的参数数量比运算符对象的数量少一个；至少含有一个类类型的参数；
5. 从参数的个数推断到底定义的是哪种运算符，当运算符既是一元运算符又是二元运算符(+,-,*,&);
6. 下标运算符必须是成员函数，下标运算符通常以访问元素的引用作为返回值，同时最好定义下标运算符的常量版本和非常量版本；
7. 箭头运算符必须是类的成员，解引用通常也是类的成员；重载的箭头运算符必须返回类的指针；


### 静态成员和普通成员的区别是什么？
+ 生命周期：静态成员变量从类加载开始到类被卸载，一直存在；普通成员只有在类创建对象后才开始存在，对象结束生命周期结束；
+ 共享方式：静态成员变量是全类共享；普通成员变量是每个对象单独享有；
+ 定义位置：普通成员定义在栈或堆中，而静态成员定义在静态全局区；
+ 初始化位置：普通成员变量在类中初始化，静态成员在类外初始化；
+ 默认实参：可以使用静态成员变量作为默认实参；


<!--------------- Generic ------------------>

## 3、Generic

### 什么是模板（template）？它的优缺点？
+ 概念
    + 模板是 C++ 一种变成语言的特性，允许程序员编写通用代码，以便在不同数据类型上进行操作。
+ 优点：
    - 灵活性，可重用性，以及扩展性
    - 模板可以把同一个算法适用于不同类型的数据，在编译时确定具体的数据类型
    - 模板模拟多态要比 C++ 继承实现多态效率要高，无虚函数，无继承
+ 缺点
    - 模板代码通常要比非模板代码要更难阅读和理解
    - 模板代码可能会导致编译时间变慢
    - 模板代码可能会导致代码膨胀，从而增加可执行文件的大小

### 什么是元编程
+ 元编程是一种编程范式，它允许程序员便携通用代码，以便在不同数据类型上操作
+ 元编程中，程序本身是动态的，程序运行也是动态的。元编程将程序作为数据来对待，从而赋予变成语言更加强大的表达能力

### 元编程和模板的联系与区别
+ 联系
    + 两者都是 C++ 非常有用的特性，能够通过编写通用代码，达到代码复用的目的
+ 区别
    + 元编程更注重程序本身的动态性和灵活性，模板更注重通用代码的灵活性和可重用性

### [什么是模板特化](https://www.cnblogs.com/wanghao-boke/p/17750991.html)
+ 模板特化是指在模板的基础上，针对某些特定的值，提供一种特殊的实现方式，模板特化分为两种，类模板特化和函数模板特化
+ 类模板特化指的是在类模板上，针对某些特定的类型和值，提供一种特殊的实现方式。类模板特化分为全特化和偏特化两种。
    - 全特化是指将模板参数列表中的所有参数都确定化；
    - 偏特化是指模板参数列表的一部分参数确定化
+ 函数模板特化指的是在函数模板的基础上，针对某些特定的类型或值，提供一种特殊的实现方式。函数模板特化分为全特化和偏特化两种：
    - 全特化是指将函数模板中所有参数都确定化；
    - 偏特化是指将函数模板中的一部分参数确定化

### C++ 中的模板参数包（template parameter pack）是什么？它有什么作用？
+ 模板参数包是一种模板元编程技术，允许模板函数或者模板类接受可变数据的参数，这些参数被称为参数包。分为模板参数包和函数参数包
    - 模板参数包表示零个或多个模板参数
    - 函数参数包表示零个或多个函数参数。
+ 省略号用于指示一个模板参数包或函数参数包，在函数调用时，编译器会将这些参数打包成一个对象，以便在函数中使用

### 解释函数模板和类模板之间的区别
+ 函数模板和类模板都是 C++ 中的模板，区别是应用场景不同
+ 函数模板是一种可以用于多种不同类型的函数，而类模板则可以产生多个具有相同结构但是不同类型的类
+ 实例化也有所不同。模板函数在实例化时会根据传入的参数类型自动推导出类型，而类模板则需要显示地指定类型

### 什么是 SFINAE（Substitution Failure Is Not An Error）？
+ 在 C++ 中，当一个函数模板或者类模板实例化时，如果模板参数无法匹配，则编译器会尝试从其他可行的模板中选择一个，如果一个可选的模板都没有，那么编译则会报错。
+ 如果某个模板参数无法匹配是由于某种原因导致的编译错误，而不是模板本身的点问题，则编译不会报错，而是将模板从候选列表中删除，这种情况称之为 SFINAE
+ SFINAE 机制常用于模板元编程中，一边根据类型特征选择正确的函数或类模板。

### 什么是模板元编程（TMP）？它有什么应用场景
+ 模板元编程是一种 C++ 模板进行元编程的技术。他可以在编译时生成代码，而这些代码最终和普通代码一起编译执行。
+ 模板元编程的应用场景是：
    - 编译时计算
    - 补充类型系统
        - 模板提供了参数化的类型，给 C++ 补充自带的类型提供的方式，使得类型系统更加智能和完备
    - Domain Specific Language
        - 是一种针对特定应用领域进行设计的编程语言。与通用编程语言不同的是，DSL 更加专注于解决某个特定领域的问题，因此他们通常具有更高的抽象层次和更好的阅读性

### 解释 C++ 中的模板元编程（TMP）和泛型编程（generic programming）之间的区别
+ 泛型编程和模板元编程是两种不同的概念
    - 泛型编程主要是为了实现代码的重用和通用型
    - TMP 则是为了实现程序的自动生成和性能优化
+ 泛型编程是一种编程范式，目的是实现代码的重用。
    - 在泛型编程中，可以通过编程与数据类型无关的代码，从而实现代码的通用型。
    - 模板就是一种范式编程技术，可以通过它编写与数据类型无关的代码
+ 模板元编程是一种使用 C++ 模板来进行元编程的技术。
    - 元编程指的是在程序执行之前，通过编写程序来生成程序。在 TMP 中，可以使用模板来生成代码，从而实现程序的自动生成。
    - TMP 可以在编译期间进行计算，从而提高程序的性能


<!--------------- STL ------------------------>

## 4、STL

### C++ 中的 STL 是什么？它包含哪些常用的容器类和算法？
1. STL 是标准模板库，提供常用的基本数据结构和算法
2. 容器类的由 vector，list，queue，deque，set，map
3. 算法类的有 sort，find，copy，for_each



<!--------------- C++ 11 --------------------->

## 5、C++ 11 

### 函数对象
+ 顾名思义，就是对象可以像函数一样调用。一个重载 () 操作符的类的实例化对象可以像函数一样调用。
+ 优点
    - 一是该对象在多次调用中可以共享一个状态，如果是普通的话，需要一个全局变量实现该功能；
    - 二是函数对象可以有自己的特性，该特性在 STL 使用时很有用。

### lambda
+ C++ 引入的新特性，能够方便的定义和创建一个匿名函数，作用是帮助开发者在保持代码精简的同时不需要添加新的函数类
+ 捕获列表，参数列表，可选的修饰符，如 mutable，exception，返回值类型声明，结构体

### 异常
+ 异常指的是程序在执行过程中出了问题，无法继续执行下去的情况。比如除零操作，段错误，内存溢出等
+ C++ 提供 throw，try，catch 机制来处理程序执行过程中遇到了异常的情况。try 块中放置可能出现的异常的代码，catch 用来捕获异常，throw 用来抛出异常
+ C++ 提供了一系列的标准异常，定义在 <exception> 头文件中

### RTTI
+ 运行阶段类型识别，为了在程序运行时能确定某个对象的实际类型
+ RTTI 机制只适用于含有虚函数的类，主要是用在将多态指针转换成它指向的对象实际类型
+ C++ 有三个用来实现 RTTI 机制的元素，分别是 typeid，dynamic_cast，type_info
    + typeid：获取指针或引用所指的实际类型
    + dynamic_cast：安全地将基类指针或引用转换成派生类的指针和引用
    + type_info：存储了特定类型的对象信息

### C++ 左值和右值
1. 左值：表示可以获取地址的变量
2. 右值：表示无法获取地址的对象，有常量值、函数返回值、lambda 表达式等

### C++ 右值引用（rvalue reference）和左值引用（lvalue reference）
1. 左值引用：绑定一个有地址的对象，且不允许修改该对象，传统的 C++ 引用就是左值引用
2. 右值引用：绑定一个临时对象上去，即右值，且允许修改该临时对象。

### 右值引用？与左值引用有什么区别？
+ 绑定的对象不同
    - 右值引用是对不能取地址的值进行绑定，左值相反，只能绑定有地址的值，不能取地址的值只能绑定到常量引用去
+ 持续时间不同
    - 右值只能绑定到临时对象，所引用的对象将要销毁或该对象没有其他用户；而左值引用的变量都是持久性变量
+ 引用的目的不同
    - 右值引用为了支持移动构造，而左值引用是为了给变量起个别名，使用左值引用更安全

### C++11 中的移动语义（move semantics）是什么？它有什么作用？
+ 移动语义就是转移指定对象的内存所有权。能够在不需要拷贝操作的场合中执行数据转移。
+ 主要是为了解决 C++ 拷贝带来的资源消耗问题。通过移动语义，充分利用临时对象的构造来减少对象的构造和析构操作以达到提高效率的目的。

### 解释完美转发（perfect forwarding）。
+ 由万能引用 + 引用折叠 + std::forward() 来实现将函数模板中接受的参数的左右值属性和数值一同完美地传递给下一个调用函数

### 什么是 noexcept 关键字？它有什么作用？
+ 指定修饰的函数不会抛出异常
+ 编译器会在编译时期确定该函数是否会抛出异常，如果确实不会，编译器会对该函数进行优化，提升性能。
+ 如果修饰的函数在运行时抛出了异常，程序会终止，提升了程序的健壮性

### 解释 C++11 中的原子操作（atomic operation）和 std::atomic 类型。
1. 原子操作保证描述的操作是原子级别的，也就是同一时间只能有一个线程执行该操作
2. atomic 是 C++11 一种同步进制，它确保修饰的对象在被访问时是互斥的

### auto、decltype 和 decltype(auto) 的用法？
1. auto
    + 用于变量声明、函数返回值类型声明和模板参数声明
    + 用于变量初始化表达式的类型推导变量的类型，从而省略了显式类型声明
    + 用于函数返回值推导
    + 用于模板函数参数声明
2. decltype
    + 用于变量声明、表达式类型查询和函数返回值类型查询
    + 用于表达式推导出表达式的类型，并将其作为变量或者函数返回值类型的声明
    + 用于表达式类型查询
    + 用于函数返回值类型查询
3. decltype(auto): C++14 引入的关键字
    + 根据表达式推导处表达式的类型，并将其变量或函数返回值类型的声明
    + 用于函数返回值类型的推导

### fianl 和 override
+ final 和 override 关键字在 C++ 中对类继承和函数重写行为做了额外的限制
+ final 可以保护基类不被修改，防止滥用继承
+ override 关键字可以明确标识派生类对基类的虚函数进行重写，并在编译时进行类型检查


### 介绍智能指针和其作用
1. 概述
    + C++ 智能指针是一个之类，用来自动管理内存。它封装一个指针，并且提供了指针的内存管理方法
2. 类型
    1. unique_ptr：用于管理独占所有权的资源，它在确保不再需要时自动释放资源，并且不能共享所有权
    2. shared_ptr：用于管理共享所有权的资源，它可以跟踪有多少个指针共享同一个资源，并在不需要时自动释放资源
    3. weak_ptr：用于解决 shared_ptr 循环引用问题。它允许创建一个不增加引用计数的指针，便于观察 shared_ptr 指向的资源

<!------------------------- C++ 11 End --------------------->

<!--------------------- Code test Start--------------------------->
## 6、C++ Code test
### 什么是代码覆盖率（code coverage）
+ 是一种通过计算测试过程中被执行的源代码占全部源代码的比例，进而间接度量软件质量的方法。
    - 能在保证测试质量的同时，也潜在保证实际产品的质量。
+ 代码覆盖率测试一般细分为语句覆盖，判定覆盖，条件覆盖，条件判定组合覆盖，路径覆盖，多条件覆盖和修正条件覆盖等
    - 语句覆盖：度量被测代码中每个可执行语句是否被执行到
    - 判定覆盖：度量程序中的每一个判定的分支是否都被测试到
    - 条件覆盖：报告每一个子表达式的结果的是 true 和 false 是否被测试到
    - 修正条件覆盖：要求在一个程序中每一种输入输出至少得出现一次，在程序中的每一个条件必须产生所有可能的输出结果至少一次
        - 每一个判定中的每一个条件必须能够独立影响一个判断的输出
+ 代码覆盖率指标的设定需要考虑代码失效的成本，测试相关资源，可测行设计和开发迭代状态等
    - 一般而言 70%~80% 覆盖率比较合理

###  C++ 中的测试框架，例如 Google Test 和 Boost.Test。
+ [gtest](https://zhuanlan.zhihu.com/p/369466622)

### 在 C++ 中应该遵循哪些代码规范？

<!--------------------- Code test End--------------------------->