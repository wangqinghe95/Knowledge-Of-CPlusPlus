# Basic Knowledege for C/C++

<!------------ Basic C++ from C --------------------->
## Basic C && C++

### C 和 C++ 的区别
1. 设计思想或者说是应用场景的区别
    + C 是基于内存占用和执行效率的考虑使它更趋近于底层，特点是越精简越高效，注重逻辑实现，也就是面向过程。多用于操作系统和驱动内核。
    + C++ 诞生的目的之一就是抽象和精简 C 的实现过程，注重程序的整体设计。适合做大型软件。
2. 由设计思想的不同，由此引申出来的种种实现和细节的不同，如C++比C多出来的关键，C++多出来的虚函数，重载的概念和实现。面向对象设计的核心类，甚至再往上完全和 C 没有任何关系的范式编程，元编程。都是两者具体上的差别。

### C++ 中 const 关键字
1. C++ const 是一个关键字，用于来声明常量
2. 它可以修饰变量，指针，指针地址，函数参数，函数返回值，类成员函数，类对象等
3. 它的作用是防止修饰的对象被修改，有利于提高代码的可读性和可维护性，并减少错误的发生

### C++ 中指针和引用的区别
+ 指针是一个实体，需要分配内存；引用只是变量的别名，不需要分配内存空间；
+ 引用在定义时候必须进行初始化，并且不能改变；指针在定义的时候不一定要进行初始化，并且指向的空间可变；
+ 有多级指针，但是没有多级引用。只能有一级引用；
+ 指针和引用的自增运算结果不一样；（指针是指向下一个空间，引用是引用的变量值加 1 ）；
+ sizeof 引用得到的结果是引用所指向的变量（对象）的大小；sizeof 指针得到的指针本身的大小；
+ 使用指针前最后做类型检查，防止野指针的出现；
+ 引用底层是用指针实现的；
+ 作为参数时，传指针实际上是传值，传递的值是指针的地址；传引用的实质是传地址，传递的是变量的地址；

### 解释区间（range）和范围（span）。
+ 都表示一段连续的内存空间
+ 区间通常指的是左闭右开的区间。
+ 范围一般指的是左闭右闭的区间。

### 什么是强制内联（forced inline）？它与普通内联（normal inline）有什么区别？
+ 内联是 C++ 编辑器一种优化技术，它可以将函数的代码直接插到调用函数的地方去，从而避免了函数调用的开销。内联函数适用于代码比较少的函数，比如访问器函数，操作符重载函数等
+ 普通内联是由编辑器自主决定是否要进行内联优化，而强制内联是通过在函数声明前加上关键字 inline 和 __foreceinline 修饰符实现，强制内联会强制编译器对该函数进行内联优化，即使编译器认为这并不是最优选择
+ 需要注意的是强制内联可能会导致代码体积增大，从而影响程序的性能，所以应该谨慎使用强制内联，并在必要时进行性能测试和优化。

### static 关键字作用
+ static 修饰的变量存放在全局数据区的静态变量区中。这种变量的作用域受限在定义处的区域中，且该区域的变量生存周期是整个程序的运行周期
+ static 修饰的全局变量叫做静态全局变量
    - 只能本文件所见，不能被其他文件访问；
- static 修饰的局部变量被称为静态局部变量
    - 生存周期拉长到整个程序的生存周期，作用域是声明处的局部范围；
- static 修饰的类成员和类成员函数，被称为类的静态成员
    - 类的静态成员属于类本身，不属于类对象
    - 无需实例化就可以直接通过类名直接访问
- static 修饰函数，被称为静态函数
    - 只能本文件所见，不能被其他文件访问；

### 解释 C++ 中的强制类型转换（type casting）
+ static_cast：用于基础类型之间的转换
    - 如果用于基类和派生类之间的转换，那么在运行时是没有类型检查来保证转换的安全性的
+ dynamic_cast：主要用于类层次之间的上行转化或者下行转换
    - 上行转换时，效果等同于 static_cast
    - 下行转换时，dynamic_cast 有类型检查的功能
+ reinterpret_cast
    - 整数和指针之间相互转换，不安全，不推荐使用
+ const_cast
    - 用来修改表达式的 const 和 volatile 属性

<!------------ Oriented Object C++ --------------------->

## Oriented Object C++

### 对象模型
+ C++ 对象模型是 C++ 语言中实现面向对象编程的机制之一。
+ 它包含了语言中直接支持面向对象程序设计的部分，如构造函数，析构函数，多态，虚函数等等，以及对于各种支持的底层实现机制
+ 对象模型的底层实现机制并没有标准化，不同的编译器有一定的自由度来设计对象模型的实现细节

### 解释 C++ 多态性和继承性
1. C++ 继承性
+ 继承是面向对象的三大特性之一，允许一个类继承另一个类的成员函数和成员变量
+ 通过派生的的机制来实现对已存在的类和模块的拓展，从而实现代码的服用

2. C++ 多态性
+ 通过虚函数，C++ 能实现相同对象在收到不同的消息或者同个对象收到相同消息产生不同的表现
+ C++ 有两种形式，一种是静态多态，一种是动态多态
    1. 静态多态指的是在编译时期就能确定函数的调用
    2. 动态多态指的是在程序实际运行时才能确定具体函数的调用

### 解释虚函数和纯虚函数
+ 用关键字 virtual 修饰的函数就是虚函数，虚函数用来实现 C++ 多态
+ 纯虚函数是虚函数后加 =0 声明，纯虚函数只有只有声明，实现是由继承的类来完成。纯虚函数用来抽象和规划修饰的函数接口的。

### 什么是虚函数表（virtual function table）？它在 C++ 中有什么作用？
+ 虚函数表是 C++ 实现多态的机制之一，它是一个指针数组，存储了一个类的虚函数地址。
+ 如果一个类中有虚函数，那么它就会自带虚函数表，它实例化的对象也会相应的含有一个指向虚函数表的指针，用于类对象在调用类虚函数表时的寻址
+ 当一个类被继承时，子类会继承父类的虚函数表，并且可以重写父类的虚函数。在运行时，如果子类对象调用了重写的虚函数，那么它回调用子类中的版本，而不是父类中的版本。

### 什么是 vtable 和 vptr？它们在 C++中有什么作用？
+ 虚函数表和虚函数是 C++ 实现多态的机制之一
+ 虚函数表是一个指针数组，存储量一个类的虚函数地址
+ 虚函数指针是带有虚函数表实例化对象拥有的指向虚函数表的指针，用来调用虚函数表中的虚函数。
    - 虚函数指针在内存结构中一般存储在类的对象的起始地址

### 什么是动态绑定，它的使用场景是什么？
1. 动态绑定指的是在程序实际运行时根据对象的实际类型来选择调用的方法和函数。
2. 在 C++ 中，虚函数重写，switch 语句和 if 语句会使用到动态绑定

### 解释编译时（compile-time）和运行时（run-time）多态（polymorphism），它们有什么区别？
+ 编译时多态指的是编译器对源程序编译时就可以确定所调用的是哪个函数了
+ 运行时多态指的是在程序之前无法根据函数名和函数参数来确定应该调用哪个函数，必须在程序执行时根据具体的代码动态确定执行哪个函数
+ 编译时多态性是通过函数的重载和重载操作符实现；动态时编译主要是通过虚函数实现；

### 解释 C++ 中的静态多态（static polymorphism）和动态多态（dynamic polymorphism）。
+ 静态多态指的是在编译时间就能确定函数的调用地址，并生成代码，通常通过函数重载，模板等机制实现。优点是效率高，缺点是灵活性差，只能处理已知类型的对象
+ 动态多态是指在运行时根据基类的引用指向的对象来确定调用哪一个虚函数。动态多态通常是通过虚函数、继承等机制实现。优点是灵活性高，缺点是效率低。

### 什么是 RAII 技术
+ RAII 是一种编程思想，它代表资源获取即初始化，是一种在 C++ 中管理资源的重要技术，这种思想和技术的目的可以确保在使用资源时，他们在不需要时能够被正确释放。
+ RAII 的实现方式是通过在对象构造函数中获取资源并在对象的析构函数中释放资源。这样当对象超出范围时，它的析构函数将会自动调用，从而释放资源。从而避免内存泄露和其他资源管理问题。
+ RAII 应用场景在内存管理，文件操作，线程同步等

### C++ 有哪些内存管理方式
+ RAII 技术
+ 智能指针
+ 容器类
+ 自定义资源管理类：可以根据具体需求实现资源的获取和释放逻辑

### 介绍智能指针和其作用
1. 概述
    + C++ 智能指针是一个之类，用来自动管理内存。它封装一个指针，并且提供了指针的内存管理方法
2. 类型
    1. unique_ptr：用于管理独占所有权的资源，它在确保不再需要时自动释放资源，并且不能共享所有权
    2. shared_ptr：用于管理共享所有权的资源，它可以跟踪有多少个指针共享同一个资源，并在不需要时自动释放资源
    3. weak_ptr：用于解决 shared_ptr 循环引用问题。它允许创建一个不增加引用计数的指针，便于观察 shared_ptr 指向的资源

### 什么是拷贝构造函数，赋值构造函数，赋值操作符
+ 拷贝构造函数是一种特殊的构造函数，用来创建一个新对象并将其初始化为与现有对象相同的值
+ 赋值构造函数也是一种特殊的构造函数，用来将一个已经存在的对象的值复制给另一个已经存在的对象
+ 赋值操作符是一个二元运算符，用来将右侧操作数的值复制给左侧操作数
    + C++ 的类中可以重写该操作符，完成类的复制

<!--------------- Generic ------------------>
## Generic

### 什么是模板（template）？它的优缺点？
+ 概念
    + 模板是 C++ 一种变成语言的特性，允许程序员编写通用代码，以便在不同数据类型上进行操作。
+ 优点：
    - 灵活性，可重用性，以及扩展性
    - 模板可以把同一个算法适用于不同类型的数据，在编译时确定具体的数据类型
    - 模板模拟多态要比 C++ 继承实现多态效率要高，无虚函数，无继承
+ 缺点
    - 模板代码通常要比非模板代码要更难阅读和理解
    - 模板代码可能会导致编译时间变慢
    - 模板代码可能会导致代码膨胀，从而增加可执行文件的大小

### 什么是元编程
+ 元编程是一种编程范式，它允许程序员便携通用代码，以便在不同数据类型上操作
+ 元编程中，程序本身是动态的，程序运行也是动态的。元编程将程序作为数据来对待，从而赋予变成语言更加强大的表达能力

### 元编程和模板的联系与区别
+ 联系
    + 两者都是 C++ 非常有用的特性，能够通过编写通用代码，达到代码复用的目的
+ 区别
    + 元编程更注重程序本身的动态性和灵活性，模板更注重通用代码的灵活性和可重用性

### [什么是模板特化](https://www.cnblogs.com/wanghao-boke/p/17750991.html)
+ 模板特化是指在模板的基础上，针对某些特定的值，提供一种特殊的实现方式，模板特化分为两种，类模板特化和函数模板特化
+ 类模板特化指的是在类模板上，针对某些特定的类型和值，提供一种特殊的实现方式。类模板特化分为全特化和偏特化两种。
    - 全特化是指将模板参数列表中的所有参数都确定化；
    - 偏特化是指模板参数列表的一部分参数确定化
+ 函数模板特化指的是在函数模板的基础上，针对某些特定的类型或值，提供一种特殊的实现方式。函数模板特化分为全特化和偏特化两种：
    - 全特化是指将函数模板中所有参数都确定化；
    - 偏特化是指将函数模板中的一部分参数确定化

### C++ 中的模板参数包（template parameter pack）是什么？它有什么作用？
+ 模板参数包是一种模板元编程技术，允许模板函数或者模板类接受可变数据的参数，这些参数被称为参数包。分为模板参数包和函数参数包
    - 模板参数包表示零个或多个模板参数
    - 函数参数包表示零个或多个函数参数。
+ 省略号用于指示一个模板参数包或函数参数包，在函数调用时，编译器会将这些参数打包成一个对象，以便在函数中使用


### 解释函数模板和类模板之间的区别
+ 函数模板和类模板都是 C++ 中的模板，区别是应用场景不同
+ 函数模板是一种可以用于多种不同类型的函数，而类模板则可以产生多个具有相同结构但是不同类型的类
+ 实例化也有所不同。模板函数在实例化时会根据传入的参数类型自动推导出类型，而类模板则需要显示地指定类型

### 什么是 SFINAE（Substitution Failure Is Not An Error）？
+ 在 C++ 中，当一个函数模板或者类模板实例化时，如果模板参数无法匹配，则编译器会尝试从其他可行的模板中选择一个，如果一个可选的模板都没有，那么编译则会报错。
+ 如果某个模板参数无法匹配是由于某种原因导致的编译错误，而不是模板本身的点问题，则编译不会报错，而是将模板从候选列表中删除，这种情况称之为 SFINAE
+ SFINAE 机制常用于模板元编程中，一边根据类型特征选择正确的函数或类模板。

### 什么是模板元编程（TMP）？它有什么应用场景
+ 模板元编程是一种 C++ 模板进行元编程的技术。他可以在编译时生成代码，而这些代码最终和普通代码一起编译执行。
+ 模板元编程的应用场景是：
    - 编译时计算
    - 补充类型系统
        - 模板提供了参数化的类型，给 C++ 补充自带的类型提供的方式，使得类型系统更加智能和完备
    - Domain Specific Language
        - 是一种针对特定应用领域进行设计的编程语言。与通用编程语言不同的是，DSL 更加专注于解决某个特定领域的问题，因此他们通常具有更高的抽象层次和更好的阅读性

<!--------------- STL ------------------------>
## STL

### C++ 中的 STL 是什么？它包含哪些常用的容器类和算法？
1. STL 是标准模板库，提供常用的基本数据结构和算法
2. 容器类的由 vector，list，queue，deque，set，map
3. 算法类的有 sort，find，copy，for_each



<!--------------- C++ 11 --------------------->
## C++ 11 
### 函数对象
+ 顾名思义，就是对象可以像函数一样调用。一个重载 () 操作符的类的实例化对象可以像函数一样调用。
+ 优点
    - 一是该对象在多次调用中可以共享一个状态，如果是普通的话，需要一个全局变量实现该功能；
    - 二是函数对象可以有自己的特性，该特性在 STL 使用时很有用。

### lambda
+ C++ 引入的新特性，能够方便的定义和创建一个匿名函数，作用是帮助开发者在保持代码精简的同时不需要添加新的函数类
+ 捕获列表，参数列表，可选的修饰符，如 mutable，exception，返回值类型声明，结构体

### 异常
+ 异常指的是程序在执行过程中出了问题，无法继续执行下去的情况。比如除零操作，段错误，内存溢出等
+ C++ 提供 throw，try，catch 机制来处理程序执行过程中遇到了异常的情况。try 块中放置可能出现的异常的代码，catch 用来捕获异常，throw 用来抛出异常
+ C++ 提供了一系列的标准异常，定义在 <exception> 头文件中

### RTTI
+ 运行阶段类型识别，为了在程序运行时能确定某个对象的实际类型
+ RTTI 机制只适用于含有虚函数的类，主要是用在将多态指针转换成它指向的对象实际类型
+ C++ 有三个用来实现 RTTI 机制的元素，分别是 typeid，dynamic_cast，type_info
    + typeid：获取指针或引用所指的实际类型
    + dynamic_cast：安全地将基类指针或引用转换成派生类的指针和引用
    + type_info：存储了特定类型的对象信息

### 什么是右值引用（rvalue reference）？与左值引用（lvalue reference）有什么区别？
+ 右值引用是 C++ 11 引入的一种特殊的引用类型，它可以绑定到一个临时对象，也就是右值中，并允许修改该临时对象
+ 与之对应的左值引用，左值引用需要绑定到一个具有持久性对象上，即左值，并且不允许修改该对象
+ 区别：
    + 绑定的对象不同
        - 右值引用是对不能取地址的值进行绑定，左值相反，只能绑定有地址的值，不能取地址的值只能绑定到常量引用去
    + 持续时间不同
        - 右值只能绑定到临时对象，所引用的对象将要销毁或该对象没有其他用户；而左值引用的变量都是持久性变量
    + 引用的目的不同
        - 右值引用为了支持移动构造，而左值引用是为了给变量起个别名，使用左值引用更安全

### C++11 中的移动语义（move semantics）是什么？它有什么作用？
+ 移动语义就是转移指定对象的内存所有权。能够在不需要拷贝操作的场合中执行数据转移。
+ 主要是为了解决 C++ 拷贝带来的资源消耗问题。通过移动语义，充分利用临时对象的构造来减少对象的构造和析构操作以达到提高效率的目的。

### 解释完美转发（perfect forwarding）。
+ 由万能引用 + 引用折叠 + std::forward() 来实现将函数模板中接受的参数的左右值属性和数值一同完美地传递给下一个调用函数

### 什么是 noexcept 关键字？它有什么作用？
+ 指定修饰的函数不会抛出异常
+ 编译器会在编译时期确定该函数是否会抛出异常，如果确实不会，编译器会对该函数进行优化，提升性能。
+ 如果修饰的函数在运行时抛出了异常，程序会终止，提升了程序的健壮性

### 解释 C++11 中的原子操作（atomic operation）和 std::atomic 类型。
1. 原子操作保证描述的操作是原子级别的，也就是同一时间只能有一个线程执行该操作
2. atomic 是 C++11 一种同步进制，它确保修饰的对象在被访问时是互斥的