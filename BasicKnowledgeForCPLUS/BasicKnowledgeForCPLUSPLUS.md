# Basic Knowledege for C/C++

<!------------ Basic C++ from C --------------------->
## Basic C && C++

### C 和 C++ 的区别
1. 设计思想或者说是应用场景的区别
    + C 是基于内存占用和执行效率的考虑使它更趋近于底层，特点是越精简越高效，注重逻辑实现，也就是面向过程。多用于操作系统和驱动内核。
    + C++ 诞生的目的之一就是抽象和精简 C 的实现过程，注重程序的整体设计。适合做大型软件。
2. 由设计思想的不同，由此引申出来的种种实现和细节的不同，如C++比C多出来的关键，C++多出来的虚函数，重载的概念和实现。面向对象设计的核心类，甚至再往上完全和 C 没有任何关系的范式编程，元编程。都是两者具体上的差别。

### C++ 中 const 关键字
1. C++ const 是一个关键字，用于来声明常量
2. 它可以修饰变量，指针，指针地址，函数参数，函数返回值，类成员函数，类对象等
3. 它的作用是防止修饰的对象被修改，有利于提高代码的可读性和可维护性，并减少错误的发生

### C++ 中指针和引用的区别
+ 指针是一个实体，需要分配内存；引用只是变量的别名，不需要分配内存空间；
+ 引用在定义时候必须进行初始化，并且不能改变；指针在定义的时候不一定要进行初始化，并且指向的空间可变；
+ 有多级指针，但是没有多级引用。只能有一级引用；
+ 指针和引用的自增运算结果不一样；（指针是指向下一个空间，引用是引用的变量值加 1 ）；
+ sizeof 引用得到的结果是引用所指向的变量（对象）的大小；sizeof 指针得到的指针本身的大小；
+ 使用指针前最后做类型检查，防止野指针的出现；
+ 引用底层是用指针实现的；
+ 作为参数时，传指针实际上是传值，传递的值是指针的地址；传引用的实质是传地址，传递的是变量的地址；

<!------------ Oriented Object C++ --------------------->

## Oriented Object C++

### 解释 C++ 多态性和继承性
1. C++ 继承性
+ 继承是面向对象的三大特性之一，允许一个类继承另一个类的成员函数和成员变量
+ 通过派生的的机制来实现对已存在的类和模块的拓展，从而实现代码的服用

2. C++ 多态性
+ 通过虚函数，C++ 能实现相同对象在收到不同的消息或者同个对象收到相同消息产生不同的表现
+ C++ 有两种形式，一种是静态多态，一种是动态多态
    1. 静态多态指的是在编译时期就能确定函数的调用
    2. 动态多态指的是在程序实际运行时才能确定具体函数的调用

3. 解释虚函数和纯虚函数
+ 用关键字 virtual 修饰的函数就是虚函数，虚函数用来实现 C++ 多态
+ 纯虚函数是虚函数后加 =0 声明，纯虚函数只有只有声明，实现是由继承的类来完成。纯虚函数用来抽象和规划修饰的函数接口的。

### 什么是动态绑定，它的使用场景是什么？
1. 动态绑定指的是在程序实际运行时根据对象的实际类型来选择调用的方法和函数。
2. 在 C++ 中，虚函数重写，switch 语句和 if 语句会使用到动态绑定

### 解释编译时（compile-time）和运行时（run-time）多态（polymorphism），它们有什么区别？
+ 编译时多态指的是编译器对源程序编译时就可以确定所调用的是哪个函数了
+ 运行时多态指的是在程序之前无法根据函数名和函数参数来确定应该调用哪个函数，必须在程序执行时根据具体的代码动态确定执行哪个函数
+ 编译时多态性是通过函数的重载和重载操作符实现；动态时编译主要是通过虚函数实现；

### 什么是 RAII 技术
+ RAII 是一种编程思想，它代表资源获取即初始化，这种思想和技术的目的可以确保在使用资源时，他们在不需要时能够被正确释放。
+ RAII 的实现方式是通过在对象构造函数中获取资源并在对象的析构函数中释放资源。这样当对象超出范围时，它的析构函数将会自动调用，从而释放资源。从而避免内存泄露和其他资源管理问题。

### C++ 有哪些内存管理方式
+ RAII 技术
+ 智能指针
+ 容器类
+ 自定义资源管理类：可以根据具体需求实现资源的获取和释放逻辑

### 介绍智能指针和其作用
1. 概述
    + C++ 智能指针是一个之类，用来自动管理内存。它封装一个指针，并且提供了指针的内存管理方法
2. 类型
    1. unique_ptr：用于管理独占所有权的资源，它在确保不再需要时自动释放资源，并且不能共享所有权
    2. shared_ptr：用于管理共享所有权的资源，它可以跟踪有多少个指针共享同一个资源，并在不需要时自动释放资源
    3. weak_ptr：用于解决 shared_ptr 循环引用问题。它允许创建一个不增加引用计数的指针，便于观察 shared_ptr 指向的资源

### 什么是拷贝构造函数，赋值构造函数，赋值操作符
+ 拷贝构造函数是一种特殊的构造函数，用来创建一个新对象并将其初始化为与现有对象相同的值
+ 赋值构造函数也是一种特殊的构造函数，用来将一个已经存在的对象的值复制给另一个已经存在的对象
+ 赋值操作符是一个二元运算符，用来将右侧操作数的值复制给左侧操作数
    + C++ 的类中可以重写该操作符，完成类的复制

<!--------------- Generic ------------------>
## Generic

### 什么是模板（template）？它的优缺点？
+ 概念
    + 模板是 C++ 一种变成语言的特性，允许程序员编写通用代码，以便在不同数据类型上进行操作。
+ 优点：
    - 灵活性，可重用性，以及扩展性
    - 模板可以把同一个算法适用于不同类型的数据，在编译时确定具体的数据类型
    - 模板模拟多态要比 C++ 继承实现多态效率要高，无虚函数，无继承
+ 缺点
    - 模板代码通常要比非模板代码要更难阅读和理解
    - 模板代码可能会导致编译时间变慢
    - 模板代码可能会导致代码膨胀，从而增加可执行文件的大小

### 什么是元编程
+ 元编程是一种编程范式，它允许程序员便携通用代码，以便在不同数据类型上操作
+ 元编程中，程序本身是动态的，程序运行也是动态的。元编程将程序作为数据来对待，从而赋予变成语言更加强大的表达能力

### 元编程和模板的联系与区别
+ 联系
    + 两者都是 C++ 非常有用的特性，能够通过编写通用代码，达到代码复用的目的
+ 区别
    + 元编程更注重程序本身的动态性和灵活性，模板更注重通用代码的灵活性和可重用性

### [什么是模板特化](https://www.cnblogs.com/wanghao-boke/p/17750991.html)
+ 模板特化是指在模板的基础上，针对某些特定的值，提供一种特殊的实现方式，模板特化分为两种，类模板特化和函数模板特化
+ 类模板特化指的是在类模板上，针对某些特定的类型和值，提供一种特殊的实现方式。类模板特化分为全特化和偏特化两种。
    - 全特化是指将模板参数列表中的所有参数都确定化；
    - 偏特化是指模板参数列表的一部分参数确定化
+ 函数模板特化指的是在函数模板的基础上，针对某些特定的类型或值，提供一种特殊的实现方式。函数模板特化分为全特化和偏特化两种：
    - 全特化是指将函数模板中所有参数都确定化；
    - 偏特化是指将函数模板中的一部分参数确定化

### C++ 中的模板参数包（template parameter pack）是什么？它有什么作用？
+ 模板参数包是一种模板元编程技术，允许模板函数或者模板类接受可变数据的参数，这些参数被称为参数包。分为模板参数包和函数参数包
    - 模板参数包表示零个或多个模板参数
    - 函数参数包表示零个或多个函数参数。
+ 省略号用于指示一个模板参数包或函数参数包，在函数调用时，编译器会将这些参数打包成一个对象，以便在函数中使用


<!--------------- STL ------------------------>
## STL

### C++ 中的 STL 是什么？它包含哪些常用的容器类和算法？
1. STL 是标准模板库，提供常用的基本数据结构和算法
2. 容器类的由 vector，list，queue，deque，set，map
3. 算法类的有 sort，find，copy，for_each



<!--------------- C++ 11 --------------------->
## C++ 11 
### 函数对象
+ 顾名思义，就是对象可以像函数一样调用。一个重载 () 操作符的类的实例化对象可以像函数一样调用。
+ 优点一是该对象在多次调用中可以共享一个状态，如果是普通的话，需要一个全局变量实现该功能；二是函数对象可以有自己的特性，该特性在 STL 使用时很有用。

### lambda
+ C++ 引入的新特性，能够方便的定义和创建一个匿名函数，作用是帮助开发者在保持代码精简的同时不需要添加新的函数类
+ 捕获列表，参数列表，可选的修饰符，如 mutable，exception，返回值类型声明，结构体

### 异常
+ 异常指的是程序在执行过程中出了问题，无法继续执行下去的情况。比如除零操作，段错误，内存溢出等
+ C++ 提供 throw，try，catch 机制来处理程序执行过程中遇到了异常的情况。try 块中放置可能出现的异常的代码，catch 用来捕获异常，throw 用来抛出异常
+ C++ 提供了一系列的标准异常，定义在 <exception> 头文件中

### RTTI
+ 运行阶段类型识别，为了在程序运行时能确定某个对象的实际类型
+ RTTI 机制只适用于含有虚函数的类，主要是用在将多态指针转换成它指向的对象实际类型
+ C++ 有三个用来实现 RTTI 机制的元素，分别是 typeid，dynamic_cast，type_info
    + typeid：获取指针或引用所指的实际类型
    + dynamic_cast：安全地将基类指针或引用转换成派生类的指针和引用
    + type_info：存储了特定类型的对象信息

### 什么是右值引用（rvalue reference）？与左值引用（lvalue reference）有什么区别？
+ 右值引用是 C++ 11 引入的一种特殊的引用类型，它可以绑定到一个临时对象，也就是右值中，并允许修改该临时对象
+ 与之对应的左值引用，左值引用需要绑定到一个具有持久性对象上，即左值，并且不允许修改该对象
+ 区别：
    + 绑定的对象不同
        - 右值引用是对不能取地址的值进行绑定，左值相反，只能绑定有地址的值，不能取地址的值只能绑定到常量引用去
    + 持续时间不同
        - 右值只能绑定到临时对象，所引用的对象将要销毁或该对象没有其他用户；而左值引用的变量都是持久性变量
    + 引用的目的不同
        - 右值引用为了支持移动构造，而左值引用是为了给变量起个别名，使用左值引用更安全

### C++11 中的移动语义（move semantics）是什么？它有什么作用？
+ 移动语义就是转移指定对象的内存所有权。能够在不需要拷贝操作的场合中执行数据转移。
+ 主要是为了解决 C++ 拷贝带来的资源消耗问题。通过移动语义，充分利用临时对象的构造来减少对象的构造和析构操作以达到提高效率的目的。

### 解释完美转发（perfect forwarding）。
+ 由万能引用 + 引用折叠 + std::forward() 来实现将函数模板中接受的参数的左右值属性和数值一同完美地传递给下一个调用函数

### 什么是 noexcept 关键字？它有什么作用？
+ 指定修饰的函数不会抛出异常
+ 编译器会在编译时期确定该函数是否会抛出异常，如果确实不会，编译器会对该函数进行优化，提升性能。
+ 如果修饰的函数在运行时抛出了异常，程序会终止，提升了程序的健壮性