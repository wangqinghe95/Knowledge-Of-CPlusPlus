## 进程、线程、协程的区别和联系？
1. 调度：线程是调度的基本单位（程序计数器、状态码、通用寄存器、线程栈以及栈指针）；进程是拥有资源的基本单位（打开文件、堆、静态区、代码段）
2. 并发性：一个进程内多个线程可以并发；多个进程可以实现并发；
3. 拥有资源：线程不拥有系统资源，但一个进程的多个线程可以共享隶属于进程的资源；
4. 系统开销：线程创建销毁只需要处理 PC 值，状态码，通用寄存器，线程栈，以及栈指针；进程创建销毁都需要重新分配以及销毁 tash_struct 结构；

+ 进程是资源分配的基本单元，运行一个可执行程序创建一个或多个进程，进程就是运行起来的可执行程序；
+ 而线程是程序执行的基本单位，是轻量级的进程。每个进程都有一个唯一的主线程，而且是只能有一个，主线程和进程是相互依存的关系，主线程结束线程也会结束；一个进程下的所有线程共享堆、全局变量、静态变量、指针、引用、文件等。而独自占有栈。

---

## Linux 下同步机制？
1. 信号量：可用于进程间同步，也可以用于线程同步；
2. 互斥锁 + 条件变量：只能用于线程同步；

---

## 进程同步的四种方法？
1. 临界区：对临界区资源进行访问的那段代码成为临界区，为了互斥的访问临界资源，每个进程在进入临界区之前都需要先进行检查；
2. 同步与互斥：
    + 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行顺序；
    + 互斥：多个进程在同一时刻只有一个进程能进入临界区；
3. 信号量：
4. 管程：

### 进程通信的方式
1. 匿名管道（具有血缘关系的父子进程）
2. 管道
3. 信号
4. 信号量
5. 消息队列
6. 共享内存
7. 套接字

---

## 堆和栈的区别？

+ 管理方式不同：栈是由编译自动管理，堆是由程序员申请释放，容易产生内存泄漏
+ 空间大小不同：一般在32位操作系统下，堆最大能到 4GB,栈是 MB 级别大小
+ 是否会产生碎片：堆频繁使用new/delete会造成内存空间的不连续，从而造成大量的碎片，是程序效率降低
+ 生长方向不同：栈是从高地址向低地址方向增长，堆是低地址向高地址方向增长
+ 分配方式不同：堆都是动态分配的，但是栈既有静态分配，还有动态分配。静态分配是编译器完成，动态分配是由malloc函数完成，并且也是由编译器完成内存释放。
+ 分配效率不同：栈是由机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈的都有专门的指令执行；堆是由函数库提供，采用一定的算法去内存中寻找足够大小的空间。
+ 存储结构不同：栈存储的数据是先进后出，堆存储的数据方式是树
    
[C++内存分配方式详解](https://blog.csdn.net/u013007900/article/details/79338653)

---

## 介绍几种典型的锁（线程之间互斥）？
+ 读写锁
    - 多个读者可以同时进行读；
    - 写者必须互斥（只允许一个写者写，也不能读者写者同时进行）；
    - 写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）
+ 互斥锁
    - 一次只能一个线程拥有互斥锁，其他线程只有等待；
    - 互斥锁在抢锁失败的情况下主动放弃 CPU 进入睡眠状态直至锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁时涉及上下文的切换。互斥锁实际上的一种可能是先自旋一段时间，当自旋时间超过阈值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁的效果并不亚于自旋锁；
    - 互斥锁的一个明显缺点是他只有两种状态，锁定和非锁定；
+ 条件变量
    - 条件变量允许线程阻塞和等待另一个线程发送信号的方法弥补互斥锁的不足，它常与互斥锁一起使用，以免出现竞态条件。
    - 当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的线程改变了条件变量时，它将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说，互斥锁是线程互斥的机制，而条件变量则是同步机制；
+ 自旋锁
    - 如果进程和线程无法取得锁，进线程不会立刻放弃 CPU 时间片，而是一致循环尝试获取锁，直至获取为止。如果别的线程长时间占有锁那么自旋锁就是在浪费 CPU 做无用功，而自旋锁一般应用于加锁时间很短的场景，此时的效率会比较高；

---

## 如何用代码判断大小端存储？

## 一个进程能创建多少线程，和什么有关？

## 多进程的创建步骤：

## 进程空间：
    + 一个进程地址中会有一个栈空间、堆空间、Data空间存放已经初始化的全局变量和静态变量、BSS存放未初始化的变量、代码区；
    + 进程运行时，会根据运行的顺序将对应的代码从进程的虚拟地址加载到物理地址中执行；