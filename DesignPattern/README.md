# 设计模式

## 软件设计原则
1. 开闭原则
    + 软件实体应当对扩展开放，对修改关闭
2. 里氏替换原则
    + 子类可以拓展父类的功能，尽量不要重写父类的方法
3. 依赖倒置原则
    + 面向接口编程，不要面向实现编程
4. 单一职责原则
    + 一个类应该有且仅有一个引起它变化的原因，否则类就应该被拆分
5. 接口隔离原则
    + 客户端不应该被迫依赖它不适应的方法。一个类对另一个类的依赖应该建立在最小的接口上
6. 迪米特原则
    + 如果两个软件实体无需直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。降低类的耦合度，提高模块的相对独立性
7. 合成复用原则
    + 在软件复用时，尽量先使用组合或者聚合等关联关系来实现，其次再考虑使用继承关系实现

## 简单工厂模式
1. 描述：工厂类拥有一个工厂方法，根据传入的不同参数，返回不同的实例
    + 工厂角色负责创建所有实例的内部逻辑
    + 抽象产品角色是所有要创建的所有对象的父类，负责描述所有实例的公共接口
    + 具体产品角色是创建目标，所有创建的对象都是该角色的某个具体类的实例。
2. 实现
    + 根据已经实现的抽象产品类和具体产品类，在工厂类中，根据传入的参数，返回不同的具体产品的类
    
## 策略模式
1. 描述
    + 定义一系列的算法，将他们一一封装起来，并且使他们可相互替换。
2. 实现
    + 抽象算法类在使用类的构造函数中被注册，使用过程中，可以直接先将具体类的实例化在实用类构造时直接作为构造参数传入。

## 装饰模式
1. 描述：
    + 用来给对象增加某些特性或者对被修饰对象进行某些修改
2. 实现
    + 装饰器类继承抽象的对象类，并且具体的装饰器类包含抽象的对象类。
    + 值得注意的是，是装饰的具体类需要一层一层嵌套的，最终嵌套到使用的对象类。并且最终显示使用需要最外层的装饰类来调用
    
## 代理模式
1. 描述：
    + 为其他对象提供一种代理以控制这个对象的访问
2. 实现：
    + 代理类中有一个访问对象类的指针，通过调用代理类的相关接口去使用对象类中的功能

## 工厂模式
1. 描述
    + 工厂类拥有一个工厂方法（create），接受了一个参数，通过不同的参数实例化不同的产品类。
2. 角色
    + 抽象工厂类：工厂方法模式的核心类，提供创建具体产品的接口，由具体工厂类实现
    + 具体工厂类：继承抽象工厂，实现创建对应具体产品对象的方式
    + 抽象产品类：具体产品继承的父类
    + 具体产品类：具体工厂所创建的对象
2. 实现
    + 一个抽象工厂类，有所有产品的共有的抽象接口
    + 抽象产品类，继承抽象工厂类，具体实现抽象接口
    + 具体工厂类，包含一个抽象的创建工厂接口
    + 具体产品类，实现抽象的创建工厂接口，具体返回对应的抽象产品类对象或者指针

## 模板方法模式
1. 描述
    + 将算法封装到父类中，具体实现放到子类中
2. 实现
    + 一个父类中，定义了算法调用的接口，以及算法的抽象封装接口
    + 定义子类继承父类，并且在子类中重写算法的具体实现
    + 调用中，一个父类指针指向子类的实体，然后指针调用算法的使用接口

## 外观模式

## 建造者模式

## 观察者模式
+ 定义对象之间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都可以得到通知并更新

## 抽象工厂模式

## 状态模式

## 适配器模式

## 备忘录模式

## 组合模式

## 迭代器模式

## 单例模式
1. 定义
    + 一个类只允许一个实例存在的模式叫单例模式
2. 适用对象
    + 需要生成唯一序列的环境
    + 需要频繁实例化然后销毁的对象
    + 创建对象时耗时过多或者耗资源过多，但又经常用到的对象
    + 方便资源相互通信的环境
    + 如操作系统的回收站，网站的计数器，服务程序的日志模块，web 读取配置文件的模块
3. 实现方式
    + 将类构造方法定义为私有方法，这样就不能通过调用该类的构造方法来实例化该类的独享，只能通过该类提供的静态方法获得该类的唯一实例
    + 在该类中体提供一个静态方法，当我们调用这个方法时，如果类持有的引用不为空就返回这个引用，如果类持有的引用为空就创建该类的实例化对象并将实例的引用赋予该类持有的引用
4. 优缺点
    + 优点
        1. 在内存中只有一个对象，节省内存空间
        2. 避免频繁的创建销毁对象，提高性能
        3. 避免对共享资源的多重占用，简化访问
        4. 为整个系统提供一个全局访问点
    + 缺点
        1. 不适用于变化频繁的对象
        2. 滥用单例会导致其他问题，如将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多出现连接池溢出
        3. 如果实例化对象长时间不使用，会被系统认为是垃圾而被回收

## 桥接模式

## 命令模式

## 责任链模式

## 中介者模式

## 享元模式