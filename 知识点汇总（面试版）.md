# C++ 知识面试版
## 基础知识
1. C 和 C++ 区别？
2. C++ 中从代码到可执行文件中间经历的过程？
3. main 函数执行前和执行后的代码是什么？
4. C++ 程序内存分布？
5. C++ 的 struct 和 C 的 struct 的区别？
6. 形参和实参的区别？
7. 结构体内存对齐问题？
8. const 用法？
9. static 用法？
10. 指针和引用的区别？
11. extern "C" 的用法？
12. define 和 typedef 、const、inline、函数的区别？
13. 变量声明和定义的区别？
14. 什么是内存泄漏，如果检查和避免？
15. 函数调用压栈过程？
16. 函数指针和回调函数？
17. 数组和指针的区别？
18. #define、#ifndef、#ifdef、#endif？
19. 介绍面对对象的三大特性？
20. 动态编译和静态编译？
21. 深拷贝和浅拷贝的区别？

## 关键字
1. malloc 和 free 底层实现过程？
2. new/delete 和 malloc/free 的区别？
3. final 和 override 关键字？
4. auto、decltype 和 decltype(auto) 的用法？
5. C++ 四种强制转换 reinterpret_cast/const_cast/static_cast/dynamic_cast 用法？
6. volatile、mutable 关键字的作用？

## 重载、虚函数
1. C++ 中重载、重写（覆盖）、和隐藏的区别？
2. 什么是虚函数？虚函数和纯虚函数的区别？
3. 哪些函数不能定义为虚函数？
4. 虚函数实现？
5. 基类的虚函数表存储在内存中的什么位置？虚表指针初始化后放在哪里？
6. 静态类型和动态类型，动态绑定和静态绑定；
7. 函数中有重载时，函数的匹配原则和顺序是什么？
8. 什么是隐式转换，如何消除隐式转换？

---

## 类
+ 空类的大小？
+ 类的对象存储空间大小如何计算的？
+ 类对象大小受到哪些因素影响？
+ 编译器会为空类默认添加什么函数？
+ 什么是成员列表初始化？什么时候必须用到初始化成员列表？初始化成员调用过程？
+ C++ 有哪几种构造函数？
+ 什么时候调用拷贝构造函数？
+ 什么是移动构造函数？
+ 类成员的初始化方式有几种，它们有什么区别？
+ 拷贝初始化和直接初始化的区别是什么？
+ 类什么时候会析构？
+ 析构函数的作用，以及是什么时候其作用的？
+ 为什么析构函数一般写成虚函数？
+ 为什么构造函数不能是虚函数？
+ 构造函数和析构函数可以调用虚函数吗？
+ 构造函数和析构函数的执行顺序是什么？他们内部都做了什么？
+ 父类的析构函数是否要设置为纯虚函数？
+ 析构函数和构造函数可否抛出异常？
+ C++ 多态是如何实现的？
+ 构造函数、析构函数、虚函数能否声明为内联函数？
+ 如何阻止一个类被实例化？
+ 如何禁止程序自动生成拷贝构造函数？
+ 关于 this 指针？
+ 什么情况会自动生成默认构造函数？
+ 什么时候合成构造函数？
+ 什么时候需要合成拷贝构造函数？
+ 什么是虚继承？
+ 成员初始化列表在什么时候用到，它的调用过程是什么？
+ 一个类中全部构造函数的扩展过程？
+ 如何禁止程序自动生成拷贝构造函数？

---

# C 和 C++ 区别？
1. C 和 C++ 最大的区别是在于应用场景和设计思想上的区别
2. 出于对内存使用和执行效率的考虑，C 的特点是高效、精简；多用于操作系统和内核驱动；C++ 设计之初的目的就是为了把 C 繁杂的实现过程抽象为对象并且进行实例化管理；所以C++更适合做大型软件；概括的说 C 注重逻辑实现，C++ 注重程序的整体设计；
3. 设计思想的不同最终导致了现在 C++ 比 C 多了很多语法、关键字的不同以及类继承重载虚函数特性甚至是模板STL这些东西；

---

# C++ 中从代码到可执行文件中间经历的过程？
1. 预处理阶段：处理以 # 号开头的预处理命令，生成 .i 或者 .ii 文件；
2. 编译阶段：对预编译阶段生成的文件进行词法分析、语法分析、语义分析和优化之后，生成汇编文件；
3. 汇编阶段：把汇编代码翻译生成机器码文件，生成 .obj 或者 .o 文件；
4. 链接阶段：将生成的 .obj 文件和 .o 文件和相关的文件关联起来，生成可执行程序；

---

# main 函数执行前和执行后的代码是什么？
+ main 函数执行之前主要是初始化系统资源：
    1. 设置栈指针；
    2. 初始化静态变量和全局变量，即 .data 段内容；
    3. 给未初始化的全部变量赋初值，即 .bss 段内容；
    4. 全局对象的初始化，全局对象会在 main 之前调用构造函数；
    5. 将 main 函数的参数 argc, argv 等传递给 mian 函数；
+ main 函数之后：
    1. 全局对象的析构函数：
    2. 调用 atexit 注册的函数：

---

# C++ 程序内存分布？
+ 用户空间内存从高到低依次为 7 种不同的内存段：
    0. 内核空间：
    1. 栈段：包括局部变量和函数调用的上下文；
    2. 文件映射段：包括动态库、共享内存等；
    3. 堆段：包括动态分配的的内存，从低地址开始向上增长；
    4. 全局/静态存储区（.bss和.data）：包括未初始化和已初始化的全局变量和静态变量；
    5. 常量存储区(.rodata)：存放常量；
    6. 程序文件段（.text）：包括二进制可执行代码；

**补充：** 在 C 中会将未初始化的数据放在 .bss 数据段中，已初始化的数据放到 .data 中， C++ 中就不做区分了；
---

# C++ 的 struct 和 C 的 struct 的区别？
+ C 语言中 
    1. struct 是用户自定义数据类型，里面没有权限限制，
    2. 只是一些变量的集合体，可以封装数据但不能隐藏数据，而且成员不能是函数；
    3. 在一个结构标记声明后，必须在结构标记前加 struct 才能做结构类型名；
+ C++ 中：
    1. 是抽象数据类型，支持成员函数定义，能继承，能实现多态；
    2. 有访问权限，可以和 class 一样有成员函数， 成员默认访问说明符为 public；
    3. 结构体标记可以直接作为结构体类型名使用；

---

# 形参和实参的区别？
1. 形参变量只有在被调用的时候才会被分配内存单元，在调用结束后会立刻释放内存单元，因此形参只能在函数内部有效；
2. 实参可以是常量、变量、表达式、函数等，无论实参是何种类型的值，在进行函数调用时，它们都必须是确定的值，以便把这些值传递给形参，因此应预先用赋值、输入等方式使形参获得确定的值；
3. 实参和形参必须在数量上、类型上和顺序上保持一致，否则会发生“类型不匹配”错误；
4. 函数调用时数据传送的方向是单向的，即只能把实参的值传递给形参，而不能把形参的值反向传递给实参，因此在函数调用的过程中，形参的值发生了改变不会影响到实参；
5. 当形参和实参都不是指针类型时，形参和实参是不同的变量，它们在内存中处于不同的位置；形参会将实参的值复制一份，在函数调用结束后形参被释放，而实参不会发生改变；

---

# 结构体内存对齐问题？
1. 结构体中的每个成员的相对结构体首地址的偏移量是对齐参数的整数倍，首位元素是对齐参数的 0 倍；
2. 结构体变量所占空间大小是对齐参数的整数倍，如有需要则在最后一个成员末尾填充字节达到要求；
3. 获取结构体成员相对于解结构体开头的字节偏移量：
    (unsigned long)(&(type.Member)) - (unsigned long)(&(type))

---

# const 用法？
1. const 修饰变量、数组、指针、函数参数、函数返回值、引用都是将修饰对象声明为只读属性，不允许修改 const 所修饰的对象；
2. const 修饰类成员函数、类的作用都是限制在成员函数中对类成员变量的修改；

+ 常量指针：const 修饰 常量的指针：int const *p/const int *p, *p 值不可变；
+ 指针常量：const 修饰 的指针指向常量：int *const p, p 值不可改变；

---

# static 用法？
+ 不考虑类时：
    1. 修饰全局变量或者函数的作用是隐藏：全局变量和函数对其他文件不可见；
    2. 修饰局部变量的作用是改变局部变量的生存期：作用域是局部内，但是生命周期等同于全局变量的生命周期；
+ 考虑类时：
    1. 修饰成员变量：该变量只与类关联，不与类的对象关联，该类的所有对象共用该变量；
    2. 修饰成员函数：该函数没有 this 指针，无法访问类中的非 static 成员和变量；不能被声明为 const、虚函数、volatile；可以被非 static 成员函数任意访问；

---

# 指针和引用的区别？
1. 是否需要分配内存：指针是一个实体，需要分配内存；引用是一个变量别名，无需分配内存；
2. 是否需要初始化：引用在定义的时候必须进行初始化，并且不能改变；指针在定义的时候不一定需要进行初始化，并且指向的空间可变；
3. 是否能有多级：有多级指针，但是引用只能是一级；
4. 自增结果不同：指针自增是指向下一个空间，引用自增是引用的变量值加一；
5. sizeof 结果不同：sizeof 指针得到的指针本身大小；sizeof 引用结果是引用对象的大小；
6. 安全性不同：使用指针需要做类型检查，防止野指针出现；引用不需要；
7. 实现不同：引用的底层是指针实现的；
8. 参数传递的实质不同：指针传递时实际上传递的值，即指针指向的地址；传引用实际上传递的是地址，传递的是变量的地址；

---

# extern "C" 的用法？
+ 作用是为了实现 C/C++ 混编；
+ C++ 编译器为了实现重载功能，编译器在编译阶段会对函数重命名，以原有函数名和各个参数的数据类型构成一个新的函数，而 C 的编译器没有这步额外的步骤，这样就会导致 C 和 C++ 代码进行混编的时候，出现编译器在程序连接阶段找不到对应的 C 函数，造成链接失败。
+ extern "C" 会提示编译器被修饰的代码按照 C 语言方式进行编译，这样就避免了 C++ 编译器找不到 C 函数导致链接失败的错误了；

---

# define 和 typedef 、const、inline、函数的区别？
+ define：
    1. 用于定义及书写复杂的内容，是个关键字；
    2. 发生在预处理阶段，属于文本插入替换；
    3. 宏不是语句，句尾不需要加分号；
    4. define 只做替换，不做类型检查和计算，也不求解，容易出现错误，一般加上一个大括号包含住所有内容；
    5. 本身不会分配内存，替换时会在内存中产生多份相同的备份；
+ typedef：
    1. 用于定义类型别名，属于编译的一部分；
    2. 会进行类型检查，且在句尾加分号标识语句结束；
    3. typedef char *p_char 和 define p_char char* 差别很大；
+ const:
    1. 作用域编译时期和运行时期；
    2. const 常量有数据类型，编译器会对其做类型检查；
    3. 在程序运行时只有一份备份，且可以执行常量折叠，能将复杂的表达式计算出结果放到常量表中；
+ inline：
    1. 是函数。在编译期进行替换
    2. 类型检查，更安全；
+ 函数：
    1. 在运行时需要跳转到具体调用函数中；
    2. 有返回值，且具有类型，会进行类型检查；

---

# 变量声明和定义的区别？
1. 声明仅仅是告诉编译器变量的位置，并不分配空间；定义是要在定义的地方为其分配存储空间；
2. 相同变量可以在多处声明，但是只能在一处定义；

---

# 什么是内存泄漏，如果检查和避免？
+ 指的是由于疏忽或者错误造成了程序未能释放掉不在使用的内存的情况；内存泄漏并不说内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误失去了对该段内存的控制，因而造成了内存的浪费；
+ 内存泄漏分类：
    1. 堆内存泄漏：程序运行中根据需要通过通过动态分配内存函数从堆中分配一块内存，在使用完成后没有没有释放掉，导致了该块内存在程序运行期间无法继续使用，此时就产生了堆内存泄漏；
    2. 系统资源泄漏：程序使用系统分配的资源，如SOCKET、Bitmap、handle 等没有相应的释放掉，造成了系统资源的浪费，严重可导致系统性能下降，运行不稳定；
    3. 没有将基类的析构函数定义为虚函数。当基类指针指向子类对象时，当基类的析构函数不是虚函数时，那么子类的析构函数不会被调用，子类资源没有正确释放，此时就造成了内存泄漏了。
    
---

# 函数调用压栈过程？
+ 编译器会将当前程序的运行状态，调用函数的返回地址，调用函数的参数从右向左，调用函数中定义变量依次压栈；

---

# 函数指针和回调函数？
+ 函数指针是指向函数的特殊指针，是有一个返回值类型，一个指针再加一个参数列表构成，这个指针就是函数指针；
+ 函数指针就是指向一个函数的地址，通过函数指针可以访问到该函数，此时通过函数指针访问到的函数就叫做回调函数；
+ 回调函数的主要作用是为了分离代码，降低程序的耦合性；

---

# 数组和指针的区别？
1. 概念：数组是用于存储多个相同类型数据的集合；指针是一个变量，存储的一个地址值；
2. 赋值不同：同类型指针可以相互赋值，数组只能逐个的拷贝和赋值；
3. 存储方式不同:数组在内存中是连续存放的；指针在内存中就是一个 4 或 8 字节大小的变量；
4. sizeof 结果不同：sizeof 数组名得到的整个数组所占空间大小，sizeof(数组名)/sizeof(数据类型)得到的数组大小；sizeof 指针大小在 32bit 系统下是 4，64bit 下是 8；

---

# #define、#ifndef、#ifdef、#endif？
1. 实现条件编译的需求；
2. 避免了头文件的重复定义；

---

# 介绍面对对象的三大特性？
+ 把对象的服务和属性结合成一个独立的单元，并尽可能的隐藏内部的实现细节；
+ 继承：特殊类拥有一般的属性和服务，通过继承可以利用已有的数据结构去构造新的数据结构；
+ 多态：指的是同一操作作用于不同对象产生的不同响应；简单的概括为：一个接口多种实现；

---

# 动态编译和静态编译？
+ 静态编译：编译器在编译可执行文件时，把需要用到的对应的动态链接库的部分提取出来，连接到可执行到可执行文件中，使得可执行文件在运行时不需要依赖动态连接库；
+ 动态编译：动态编译的可执行文件需要附带一个动态连接库，在执行时需要调用对应动态连接库的命令。优点是一方面缩小了可执行文件的体积，另一方面加快了编译速度，节省了系统资源。缺点一是无论程序大小，都需要附带一个相对庞大的连接库，二是移植性差，如果其他计算机没有对应的运行库，那么动态编译的可执行文件就无法运行；

---

# 深拷贝和浅拷贝的区别？
+ 浅拷贝只是拷贝一个指针的值，并没有开辟一个新地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误；
+ 深拷贝不仅是拷贝值，还会开辟一块新的空间去存放新的值，即使原先的对象被释放掉，释放内存也不会影响深拷贝的值。

---

## 关键字
# malloc 和 free 底层实现过程？
+ malloc 是从堆中申请内存。操作系统中有一个记录空闲内存地址的链表，操作系统收到程序的申请时，会遍历该链表，然后找到第一个空间大于所申请空间的堆节点，然后把该节点从链表中删除，并把该节点的空间分配给程序；
+ free 过程与 malloc 过程正好相反，可以直接将要删除的空间重新插入到记录空间内存地址的链表值中即可。
---

# new/delete 和 malloc/free 的区别？
+ 类型不同：new/delete 是关键字，需要编译器支持；malloc/free 是库函数，需要头文件支持；
+ 参数不同：new 申请内存分配时无需指定内存块大小，编译器会根据类型信息自行计算。而 malloc 则需要显示地指出所需内存的大小；
+ 返回结果不同：new 内存申请成功后返回时对象类型的指针；malloc 返回的是 void*，需要通过强制类型转换将 void* 转换成需要的类型；
+ 内存分配失败返回结果不同：new 内存返回失败会抛出异常，malloc 内存分配失败返回 NULL；
+ 申请用户自定义类过程不同：new 会调用 operator new 函数，申请足够的内存，然后调用该类型的构造函数，进行初始化成员变量，最后返回自定义类型指针，delete 会先调用析构函数，然后再调用 operator delete 函数释放内存。malloc/free 只能实现动态的申请和释放内存，无法强制要求对其做自定义类型对象构造和析构函数。

---

# final 和 override 关键字？
+ override 指定了子类的这个虚函数是重写父类的，如果该函数父类没有或者没有被声明为虚函数，是要被报错的。
+ final 阻止某个类被继承或者某个虚函数被重写；

---

# auto、decltype 和 decltype(auto) 的用法？
+ auto： C++ 新标准引入 auto 说明符，用它就能让编译器替我们去分析表达式所属类型。auto 让编译器通过初始值进行类型推演，从而获得定义变量的类型，auto 必须要有初始值
+ decltype：选择并返回操作数的数据类型，在此过程中，编译器只是分析表达式并得到它的类型，并不去计算实际的表达式的值。
+ decltype(auto):C++14 新增的类型指示符，可以用来生命变量以及指示函数返回类型。在使用时会将"="号左边的表达式替换调 auto，再根据 decltype 的语法规则来确定类型；

---

# C++ 四种强制转换 reinterpret_cast/const_cast/static_cast/dynamic_cast 用法？
+ reinterpret_cast：用于类型之间进行强制转换；
+ const_cast：用来修改类型的 const 和 volatile 属性；
+ static_cast：派生类指针或引用转换成基类；
+ dynamic_cast：基类向派生类转换比较安全，反之不安全，但是转换失败会返回 nullptr，以此来做判断

---

# volatile、mutable 关键字的作用？
+ volatile：提醒编译器它后面所定义的变量随时都有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。
+ mutable：为了突破 const 限制设置的。可以用来修饰一个类的成员变量。被 mutable 修饰的变量，将永远处于可变的状态。即使 const 函数也可以改变这个变量的值；
---


## 重载、虚函数

# C++ 中重载、重写（覆盖）、和隐藏的区别？
+ 重载（overload）：在同一范围定义中，存在参数类型、数量和顺序不同，但是函数名相同的两个或者以上函数；他们的关系称之为重载；
+ 重写（override）：派生类中的函数覆盖基类的同名函数，要求基类函数和必须是虚函数，且必须与基类的虚函数有相同的参数个数，参数类型和返回值类型；
+ 隐藏（hide）：派生类的函数会隐藏其父类同名函数（只需要函数名相同）；

---

# 什么是虚函数？虚函数和纯虚函数的区别？
+ 虚函数是 C++ 用于实现多态的机制定义的函数，实现通过基类指针访问派生类的需求；
+ 虚函数和纯虚函数的区别：
    - 纯虚函数没有具体函数体，并且是用 “=0” 来表示
    - 含有纯虚函数的类不能实例化，并且继承的子类也必须实现继承的纯虚函数后才能实例化
    - 纯虚函数在虚函数表中的值为 0 

---

# 哪些函数不能定义为虚函数？
1. 友元函数，它不是类的成员函数；
2. 全局函数；
3. 静态成员函数（没有this指针）；
4. 构造函数、拷贝构造函数；

---

# 虚函数实现？
1. 虚函数是依靠虚指针 vptr 和虚函数表 vtable 来实现；
2. vptr 在类的构造函数中创建生成，并且只能使用 this 指针来访问，因为它 this 指针就是类的一个成员，并且虚函数指针指向的地址就是虚函数表；
3. 虚函数的调用顺序是： this->vptr->vtable->virtual function;

---

# 基类的虚函数表存储在内存中的什么位置？虚表指针初始化后放在哪里？
+ 基类的虚函数表存储在内存的只读数据段，也就是内存模型中常量区；
+ vptr 虚表指针是在类在进行实例化时，构造函数的执行时进行初始化，存在对象的前四个字节；

---

# 静态类型和动态类型，动态绑定和静态绑定；
+ 静态类型：对象在声明时采用的类型，在编译期既已确定；
+ 动态类型：通常是指一个指针或引用目前所指对象的类型，是在运行期才决定的；
+ 静态绑定：绑定的是静态类型，所对应的函数或属性依赖于静态类型，发生在编译期；
+ 动态绑定：绑定的动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；

**总结：**非虚函数一般都是静态绑定，而虚函数都是动态绑定；

---

# 函数中有重载时，函数的匹配原则和顺序是什么？
1. 名字查找；
2. 确定候选函数
3. 寻找最佳匹配

---

# 什么是隐式转换，如何消除隐式转换？
1. 隐式转化意思是不需要用户干预，编译器私下进行的类型转换行为。
2. 基础数据类型的隐式转换发生在小精度到大精度的转换中；比如 char=>int,int->long；自定义对象中子类对象可以隐式转换为父类对象；
3. C++ 提供了explicit 关键字，在构造函数声明的时候加上可以禁止隐式转换；
4. 如果构造函数只接受一个参数，则它实际上定义了转换为此类类型的隐式转换机制。可以通过将构造函数声明为 explicit 加以制止专类转换，explicit 关键字只对一个参数的构造函数有效，需要多个实参的构造函数不能用于执行隐式转换，所以无需为这些构造函数指定 explicit

---

## 类
# 空类的大小？
+ C++ 空类大小不为0，不同编译器设置不一样，vs设置为 1；
+ C++ 标准指出，不允许一个对象（包括类对象）的大小为 0，不同的对象不能具有相同的地址；
+ 带有虚函数的类大小不为 1，因为会有一个 vptr 指向虚函数表，具体大小根据指针大小确定；
+ C++ 中要求对于类的每个实例都要有唯一的地址，那么编译器自动为空类分配一个字节大小，这样就可以保证每个实例都有一个独一无二的内存地址；

---

# 类的对象存储空间大小如何计算的？
+ 非静态成员的数据类型大小之和；
+ 编译器加入的额外成员变量（如指向虚函数表的指针）
+ 为了边缘对齐优化加入的 padding。
+ 空类（无静态数据成员）的对象 size 为 1，当作为基类时，size 为 0；

---

# 类对象大小受到哪些因素影响？
1. 类的非静态成员变量大小，静态成员不占据类的空间，成员函数也不占据类的空间大小；
2. 内存对齐另外分配的空间大小，类中的数据也是需要进行内存对齐操作的；
3. 虚函数的话，会在类对象插入 vptr 指针，加上指针大小；
4. 当该类是某类的派生类，那么派生类继承的基类部分数据成员也会存在在派生类中的空间中，对派生类的类对象大小进行扩展；

---

# 编译器会为空类默认添加什么函数？
+ 默认构造函数；
+ 默认拷贝构造函数；
+ 默认析构函数；
+ 重载赋值运算符函数；

---

# 什么是成员列表初始化？
+ 在类的构造函数中，不在函数体内对成员变量进行赋值，而是在构造函数的花括号前面使用冒号和初始化列表赋值；
+ 必须使用的场景：
    - 初始化一个引用成员变量时；
    - 初始化一个 const 成员变量时；
    - 调用一个基类的构造函数，而基类构造函数拥有一组参数时；
    - 当调用一个成员类的构造函数，而它的构造函数有一组参数时；
+ 调用过程：编译器会一一操作初始化列表，以适当的声明顺序在构造函数之内安插初始化操作，并且在任何显示用户代码前。成员列表的初始化顺序是按照类中成员声明顺序决定的，不是初始化列表中排列顺序决定的；

---

# C++ 有哪几种构造函数？
+ 默认构造函数
+ 初始化构造函数
+ 拷贝构造函数
+ 移动复制构造函数
+ 委托构造函数
+ 转换构造函数

---

# 什么时候调用拷贝构造函数？
+ 用一个类的实例化区初始化另外一个对象的时候；
+ 函数的参数时类的对象时（非引用传递）
+ 函数的返回值是函数体内局部对象的类的对象时，此时虽然返回了 NVR（Named return Value）优化，但是由于返回方式是值传递，所以会在返回值的地方发生拷贝构造函数--- linux g++ 中不会发生；

---

# 什么是移动构造函数？
+ 使用一个对象初始化另一个对象后，如果该对象不再使用后，重复使用该对象的地址空间，避免新的空间重复分配，降低构造的构造成本，这是移动构造函数的设计初衷；

---

# 类成员的初始化方式有几种，它们有什么区别？
+ 赋值初始化：通过在函数体内进行赋值初始化；初始化列表：在冒号后使用初始化列表进行初始化；
+ 两者区别在于：函数体内进行初始化是在所有的数据成员被分配内存后才进行的，列表初始化是给数据成员分配内存空间时就进行初始化，也就是说分配一个数据成员，只要冒号后面有此数据成员的赋值表达式（此表达式必须是括号赋值表达式），那么分配了内存空间后在进入函数体之前给数据成员赋值，也就是说初始化这个数据成员时函数体还未执行。

---

# 拷贝初始化和直接初始化的区别是什么？
+ 当用于类类型对象时，初始化的拷贝形式和直接形式有所不同：
    - 直接初始化直接调用与实参匹配的构造函数，拷贝拷贝初始化总是调用拷贝构造函数。
    - 拷贝初始化首先使用制定构造函数创建一个临时对象，然后用拷贝构造函数将那个临时对象拷贝到正在创建的对象。
+ 为了提高效率，允许编译器跳过创建临时对象这一步，直接调用构造函数构造要创建的对象，这样就完全等价于直接初始化了，但是要区别两种情况：
    - 当拷贝构造函数为 private 时，拷贝初始化会出错；
    - 使用 explicit 修饰构造函数时，如果构造函数存在隐式转换，编译时会报错；

---

# 类什么时候会析构？
+ 对象声明周期结束，被销毁时；
+ delete 指向对象的指针时，或者 delete 指向对象的基类类型指针，而其基类析构函数是虚函数时；
+ 类包含类时，外部类析沟函数被调用时，内部类的析构函数也会被调用；

---

# 析构函数的作用，以及是什么时候其作用的？
+ 作用：用于撤销对象的一些特殊任务的处理，可以是释放对象分配的内存。
+ 作用时间：
    1. 销毁对象时将调用析构函数；
    2. 显性的调用析构函数；
    3. 对象的作用域最后调用；

---

# 为什么析构函数一般写成虚函数？
+ 为了避免内存泄漏，当基类指针指向派生类对象时，如果删除该基类指针，就会调用指针指向的派生类析构函数，而派生类的析构函数又会去自动调用基类的析构函数，这样整个派生类的对象就完全被释放了；
+ 如果析构函数不声明为虚函数，则编译器实施静态绑定，这样整个派生类的对象完全被释放。在删除基类指针时，只会调用基类的析构函数而不调用派生类的析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏。
+ 在实现多态时，当用基类操作派生类时，在析构时防止只析构基类而不析构派生类的状况发生，所以要将基类的析构函数声明为虚函数。

---

# 为什么构造函数不能是虚函数？
+ 创一个对象时，需要确定对象的类型，而虚函数的是在运行时动态确认其类型的。在构造一个对象时，由于一个对象还没有创建成功，编译器无法知道对象的实际类型；
+ 虚函数的调用需要虚函数表指针 vptr，而该指针存放在对象的内存空间中，若构造函数声明为虚函数，那么由于对象还未创建，没有内存空间，更没有虚函数表 vtable 地址来调用虚构造函数；
+ 虚函数的作用在于通过父类的指针或者引用它的时候能够变成调用子类的成员函数，而构造函数是在创建对象时自动调用，不可能通过父类或者引用去调用，因此规定构造函数不能是虚函数。

---

# 构造函数和析构函数可以调用虚函数吗？
+ 在 C++ 中，提倡不在构造函数和析构函数中调用虚函数；
+ 构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身定义类型定义的版本；
+ 因为父类对象会在子类之前进行构造，此时子类部分的数据还未初始化，此时调用子类的虚函数是不安全的，故而 C++ 不会进行动态联编；
+ 析构函数是用来销毁一个对象的，在销毁一个对象时，先调用子类的析构函数，在调用子类的析构函数，所以在调用基类的析构函数时，派生类对象数据成员已经被销毁了，这个时候再调用子类的虚函数已经没有意义了

---

# 构造函数和析构函数的执行顺序是什么？他们内部都做了什么？
+ 构造函数顺序
    1. 基类构造函数。如果有多个基类，则构造函数调用顺序是某个类在类派生表中的顺序，而不是它们在成员初始化表中的顺序。
    2. 成员类对象构造函数，如果有多个成员类对象则构造函数的调用顺序是对象在类中被声明的顺序，而不是它们出现在成员初始化表中的顺序。
    3. 派生类的构造
+ 析构函数顺序
    1. 调用派生类的析构函数；
    2. 调用成员类对象的析构函数；
    3. 调用基类的析构函数；

---

# 父类的析构函数是否要设置为纯虚函数？
+ 可以设置，但是不建议。纯虚析构函数一定得定义，因此每个派生类的析构函数会被编译器加以扩张，以静态调用的方式调用其每一个虚基类以及上一层的析构函数，因此缺乏任何一个基类析构函数的定义，都会导致链接失败，所以最好不要把析构函数定义为纯虚析构函数。

---

# 析构函数和构造函数可否抛出异常？
+ 构造函数可以抛出异常，但是必须保证抛出异常之前把系统资源释放掉，保证内存不被泄漏；
+ 析构函数的执行不应该抛出异常，因为异常从析构函数抛出，并且没有在本地捕捉，这就意味着析构函数执行不全，有内存泄漏风险；

---

# C++ 多态是如何实现的？
1. 编译器在发生基类中有虚函数时，会自动为每个含有虚函数的类生成一个虚表，该表时一个一维数组，虚表中保存了虚函数的入口地址；
2. 编译器会在每个对象的前四个字节保存一个虚表指针，即 vptr,指向对象所属类的虚表。在构造时根据对象的类型区初始化虚指针 vptr，从而让 vptr 指向正确的虚表，从而在调用虚函数时，能找到正确的函数；
3. 所谓的合适时机就是在派生类定义对象时，程序会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时编译器只能找到父类，并为父类对象初始化虚表指针，令它指向父类的虚表，当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表；
4. 当派生类没有对基类的虚函数重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加到后面；
5. 这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写的情况进行动态的调用，从而实现多态性。

---

# 构造函数、析构函数、虚函数能否声明为内联函数？
+ 语法上没有错误，inline只是对编译器的一个建议；
+ 构造函数和析构函数声明为内联函数没有意义，原因有二：
    1. 类中的函数默认都是内联的，声明与否本身就非必要；
    2. 编译器在构造函数和析构函数中会添加额外的步骤，如申请/释放内存，构造/析构函数,导致构造函数和析构函数代码不符合内联函数的要求；
+ 虚函数是否内联看具体情况：如果是动态运行的代码肯定就不会去展开了，但是静态运行的代码并且代码量不大的或，是可以被展开的。

---

# 如何阻止一个类被实例化？
1. 把类定义为抽象类
2. 将构造函数声明为 private；

---

#  如何禁止程序自动生成拷贝构造函数？
+ 为了阻止编译器默认生成拷贝构造函数和拷贝复制函数，我们需要手动去重写这两个函数，某些情况下，为了避免调用拷贝构造函数和拷贝赋值函数，我们需要把他们设置为 private，防止被调用；
+ 类的成员函数和友元函数还是可以调用 private 函数，如果这个 private 只声明不定义，则会产生一个链接错误；
+ 针对上述两种情况，我们可以定义一个 base 类，在 base 类中将拷贝构造函数和拷贝赋值函数设置成 private，那么派生类中编译器就不会自动生成这两个函数，且由于 base 类中该函数是私有的，因此派生类将阻止编译器执行相关的操作；

---

# 关于 this 指针？
+ 概念：
    + this 指针是类的指针，指向对象的首地址；
    + this 指针只能在成员函数中使用，在全局函数、静态成员函数中无法使用；
    + this 指针只有在成员函数中定义才有意义，且存储位置因编译器不同而不同；
+ 作用：
    + 指向当前所在对象，通过它可以访问到当前对象的所有成员；
+ 使用： this 是一个常指针，使用方式等同于常指针；
+ 特点：
    + this 只能在成员函数中使用，全局函数、静态函数都不能使用 this。实际上成员函数默认第一个参数为 T* const this;
    + this 在成员函数开始前构造，在成员函数结束后清楚，生命周期等同于函数的参数。当调用一个类的成员函数时，编译器将类的指针作为函数 this 参数传递进去；
    + 编译器会对 this 作优化，因此 this 指针传递效率较高；

- this 指针何时创建的？
    - this 指针在成员函数开始执行前构造，在成员函数执行结束后清除；    
- this 指针存放在哪里？堆、栈、全局变量、还是其他？
    - this 存放位置会因为编译器的不同而不同，栈、寄存器、全局变量都有可能。在汇编级别里，一个值只会以三种形式存在，立即数，寄存器值，内存变量值。不是放在寄存器中就是放在内存中。
- this 指针是如何传递类中的函数的？绑定还是函数参数的首参数就是 this 指针？那么 this 指针是如何找到“类实例后函数的”？
    - 大多编译器是通过 ecx（计数寄存器）传递this指针；
    - 在调用之前，编译器会把对应的对象地址放到 eax 中，this 是通过函数参数的首参来传递的。
- this 指针是如何访问类中的变量的？
    - this 指针实际上就是对象的首地址，通过偏移量来访问类中的变量的；
- 只有获得一个对象后，才能通过对象使用 this 指针。如果我们知道一个对象 this 指针的位置，可以直接使用吗？
    - this 指针只有在成员函数中有定义，获得一个对象无法知道该对象的this指针的位置，所以就算知道this指针的位置，也没法使用。
- 每个类编译后，是否创建一个类中函数表保存函数指针，以便用来调试函数？
    - 不会，只有虚函数才会创建函数表。通过 this 指针，用来指向不同的对象，从而确保不同对象之间调用相同的函数可以互不干扰；

---

# 什么情况会自动生成默认构造函数？
1. 带有默认构造函数的类成员函数时；
2. 带有默认构造函数的基类时；
3. 带有一个虚函数的类时；
4. 带有一个虚基类的类时；

+ 合成的默认构造函数中，只有基类子对象和成员类对象会被初始化

---

# 什么时候合成构造函数？
1. 如果一个类没有任何构造函数，但他含有一个默认构造函数的成员对象；
2. 没有任何构造函数的类派生自一个带有默认构造函数的基类时；
3. 含有虚函数的类时；
4. 含有一个虚基类时；

+ 并不是任何没有构造函数的类都会合成一个构造函数；
+ 编译器合成出来的构造函数并不会显示的设定类中的每一个成员变量；

---

#  一个类中全部构造函数的扩展过程？
1. 记录在成员初始化列表中的数据成员初始化操作会被放在构造函数的函数体内，并与成员的声明顺序为顺序；
2. 如果一个成员并没有出现在成员初始化列表中，但它有一个默认构造函数，那么这个默认构造函数必须被调用；
3. 如果类中有虚表，那么它必须被设定初值；
4. 所有上一层的基类构造函数必须被调用；
5. 所有虚基类的构造函数必须被调用；

---

# 如何禁止程序自动生成拷贝构造函数？
+ 为了阻止编译器默认生成拷贝构造函数和拷贝复制函数，我们需要手动去重写这两个函数，某些情况下，为了避免调用拷贝构造函数和拷贝赋值函数，我们需要把他们设置为 private，防止被调用；
+ 类的成员函数和友元函数还是可以调用 private 函数，如果这个 private 只声明不定义，则会产生一个链接错误；
+ 针对上述两种情况，我们可以定义一个 base 类，在 base 类中将拷贝构造函数和拷贝赋值函数设置成 private，那么派生类中编译器就不会自动生成这两个函数，且由于 base 类中该函数是私有的，因此派生类将阻止编译器执行相关的操作；

---


# 什么时候需要合成拷贝构造函数？
1. 以一个对象作为另一个对象的初始时，比如当一个对象用等号做显示的初始化操作时，当对象被当作参数交给某个变量时，当函数传回一个类对象时；
2. 如果一个类没有拷贝构造函数，但是有一个含有拷贝构造函数的类类型成员变量时；
3. 当一个类没有拷贝构造函数，但是该类继承含有拷贝构造函数的基类时；
4. 当一个类没有拷贝构造函数，但是该类声明或继承了虚函数时；
5. 当一个类没有拷贝构造函数，但是该类含有虚基类时；

---

# 什么是虚继承？
+ 为了解决多继承时命名冲突和冗余数据问题，产生了虚继承，使得派生类中只保留一份间接基类的成员；
+ 在继承方式前面加上 virtual 关键字就是虚继承；
+ 虚继承的目的就是为了让某个类做出声明，承诺愿意共享它的基类，其中这个被共享的基类就是虚基类。

---

# 成员初始化列表在什么时候用到，它的调用过程是什么？
1. 当初始化一个引用成员变量时；
2. 初始化一个 const 成员时；
3. 当调用一个基类的构造函数，而构造函数拥有一组参数时；
4. 当调用一个成员类的构造函数，而它拥有一组参数时；

+ 调用过程：编译器会一一操作初始化列表，以适当的顺序在构造函数之内安插初始化操作，并且在任何显示用户代码前，列表中项目顺序是由类中的成员声明顺序决定的，而不是初始化列表中的排列顺序决定的；

---











