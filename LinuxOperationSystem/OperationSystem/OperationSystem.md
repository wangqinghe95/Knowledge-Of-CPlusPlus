# Linux Operation System
<!------------System Function------------------>
## System Function

## Basic Conception
### 什么是异步编程（asynchronous programming）？C++ 中如何实现异步编程？
+ 异步编程是一种编程模型，它允许程序在执行某些操作时不需要被阻塞等待该操作的完成，而是在等待完成操作时继续执行其他任务。
    - 这种模型通常用于处理等待 I/O 操作或其他长时间运行的任务的情况，以避免出现程序出现阻塞或者卡顿的现象。
+ C++ 中主要是使用多线程和多进程完成异步编程。

### 什么是异步 IO（asynchronous IO）？它在 C++ 中如何实现？
+ 概念
    + 异步 I/O 是一种 I/O 操作模式，允许程序在等待 I/O 操作时继续执行其他任务，而不是阻塞等待 I/O 完成，C++ 中，异步 I/O 是通过多线程或者协程来实现的
+ 实现
    + C++ 11 引入 std::sync, std::future, std::promise 和 std::packaged_task 等异步操作工具类
    + C++ 20 引入协程特性

### C++ 中有哪些常见的并发编程模型，例如共享内存、消息传递等？
+ 多进程、多线程、异步模式

## 协程
+ 概念
    + 协程是一种能在函数中挂起和回复执行的计算机组件。在 C++ 中，协程是一种轻量级的线程，他可以在单个线程中实现并发
+ 引用场景
    + 在 I/O 密集型任务中，磁盘读写，网络读写，硬件读写
    + 这些操作在阻塞的时候会阻塞线程

<!------------Process And Thread Start------------------>

## Process And Thread
### Thread
#### 什么是线程（thread）？C++ 中如何创建和管理线程？
+ 线程是操作系统能够进行运算调度的最小单位，它被包含在进程中，是进程中的实际运行单位。一个线程是进程中一个单一顺序的控制流，一个进程可以并发多个线程执行不同的任务。
+ C++ 使用 thread 模板类来创建线程，使用 mutex，lock_guard，unique_lock 来解决多线程资源竞争问题。

#### 什么是互斥锁和条件变量
1. 互斥锁一种访问保护机制，用来确保多线程在访问共享资源时能互斥的进行
2. 条件变量是一种利用全局变量来控制多线程有序的访问共享资源的机制
3. 两则相互配合共同实现多线程有序互斥的访问共享资源，典型问题是生产者和消费者

#### 什么是死锁（deadlock）？如何避免死锁？
+ 指两个或者两个以上的进程在执行过程中，由于资源的竞争而造成的一种阻塞的现象，在无外界条件的下进程都无法继续执行下去，此时系统被称为处于死锁。
+ 死锁产生有 4 个必要条件，互斥条件，请求与保持条件，不剥夺条件，循环等待条件，破坏其中一个必要条件
+ 银行家算法是一种死锁避免方法，系统在分配资源之前先计算此次分配是否会导致当前系统进入不安全状态

#### 什么是信号（signal）？在 C++ 中如何处理信号？
+ 信号是一种通信机制，是软件层次上对中断的一种模拟，可以用在进程和线程之间异步通信
+ 信号处理有三种处理方式，默认，忽略，自定义处理

#### 解释 C++ 中的多线程同步机制
1. C++ 中线程同步机制有互斥锁、条件变量、读写锁，信号
2. 互斥锁
    + 通过加锁的方式控制多个线程以独占性的方式访问共享资源，避免数据竞争和死锁
3. 条件变量
    + 利用全局变量来控制多线程有序的访问共享资源
    + 与互斥锁配合实现多线程有序、互斥的使用共享资源
4. 读写锁
    + 一种特殊的互斥锁，允许多个读线程同时访问共享资源，但同一时间只允许一个写线程使用共享资源
5. 信号
    + 多线程一种同步机制之一，在软件上层面上模拟中断，将对信号的异步信号处理转换成同步处理。

#### 解释多线程中的线程安全（thread safety）和竞态条件（race condition）
+ 线程安全指的是在多线程的进程中，不会因为多个线程同时访问共享资源而出现死锁或者程序出现意外的情况。
+ 竞态条件指的程序运行顺序的改变会影响最终结果就称存在竞态条件

### Process
#### 什么是多进程（multiprocessing）？与多线程相比有哪些区别？
+ 进程是应用程序在计算机上的一次执行活动，多进程就是操作系统同时执行多个应用程序。
+ 一个进程是由一个或者多个线程组成，线程是进程中实际的运行单元。多线程就是一个进程中多个线程在执行任务。
+ 多进程相较于多线程，更加的独立，主要表现在内存空间中。多线程公用一个进程的内存空间，多进程有自己的内存空间。

<!------------Process And Thread End------------------>

<!------------Opeartion System------------------>

## Opeartion System

### 解释内存泄漏（memory leak）及其危害？如何处理内存泄漏问题？
+ 定义
    - 内存泄露指的是程序中已动态分配的堆内存由于某些原因未正确释放或无法释放，造成系统内存的浪费和性能下降。
+ 危害
    - 内存泄露会导致程序在长时间运行情况下运行卡顿，性能下降，无故崩溃，outofmemory 等错误
+ 原因
    - 堆内存泄露：主要是通过 malloc/realloc/new 等方法从堆中分配一块内存后没有调用对应的 free 和 delete 释放掉
    - 系统资源泄露：程序使用系统分配的资源，比如 bitmap，handle，socket 没有使用对应的函数释放掉
+ 解决方法
    - 编译程序时添加添加编译参数 -fsanitize=address 能在程序运行时检查出内存泄漏，堆溢出，栈溢出，全局溢出，空指针等可能会引起程序 crush 的风险
    - 使用智能指针
    - 使用内存泄露检查工具

### C++ 进程的内存布局
+ C++ 进程的内存布局，内存地址从低到高依次是
    1. 代码段
    2. 文本段
    3. 数据段
    4. 堆区
    5. 栈区

### printf 函数执行过程
1. [程序从加载到执行的过程](./ProcessOfProgramFromLoad2Execuate.md)

### C++ main 函数执行前后做了什么
+ main 函数执行之前，注意是为了初始化系统相关资源：
    + 设置栈指针；
    + 初始化静态 static 变量和 global 全局变量，即 .data 段的内容；
    + 将未初始化部分的全局变量赋初始值，即 .bss 内容（数值型 short、int、long 为 0，bool 型为 false、指针为 null 等等）
    + 静态对象，全局对象初始化，在 main 之前调用构造函数，这是可能执行前的一些代码；
    + 动态库的初始化：设置运行环境，配置标准输入输出等
    + 将 main 函数参数 argc、argv 等传递给 main 函数，然后才真正运行 main 函数；
+ main 函数执行之后：
    + 全局对象和静态对象的析构函数；
    + 动态运行库的清理
+ 在 main 函数之前和之后执行自定义函数的方式
    1. 定义一个全局或者静态对象
    2. 使用 attribute(constructor) 和 attribute((destructor)) 在 main 之前和之后执行
    3. 注册 atexit 函数在 main 函数之后执行

### 函数调用压栈过程
1. 参数如栈：将参数从右向左一次压入系统栈
2. 返回地址入栈：将当前代码区调用指令的下一条指令压入栈中，供函数返回时继续执行
3. 代码区跳转：处理器从当前代码区跳转到被调用函数的入口处
4. 局部变量和临时变量入栈：被调用函数内部定义的局部变量和临时变量在栈中分配
5. 函数出栈：当函数执行完毕后，处理器从当前代码区跳转到调用函数的位置，同时将被调用函数的返回值压入栈中

### C++ 如何将临时变量返回给调用函数的
1. 创建临时对象：会函数内部创建一个临时对象，并将该临时对象存存储在 eax 寄存器中
2. 返回临时对象：将临时对象作为返回值返回给调用函数
3. 销毁临时对象：函数返回后，系统自动销毁临时对象

### 程序在执行 int main(int argc, char *argv[]) 时的内存结构？
+ main 函数是程序的入口点
+ 当程序执行时，操作系统会为程序分配一块内存空间，用于存储程序的代码，数据和运行时栈信息。
+ 当程序开始执行时，操作系统会讲 main 函数的 argc 和 argv 压入栈中，然后跳转到 main 函数的入口地址开始执行
+ argc 是参数个数，每个参数都是 char 类型输入，依次存储在 *argc[] 数组中

### 结构体内存对齐
1. 结构体变量的起始地址必须是其最宽基本类型成员大小的倍数
2. 结构体每个成员相对于结构体起始地址的偏移量必须是其类型大小的整数倍
3. 结构体的总大小必须是其最宽类型成员大小的倍数

### 结构体内部成员相对偏移量计算
+ `(unsigned long)(&([type].[member2])) - (unsigned long)(&([type].[member1]))`

### 什么是内存池，如何实现？
+ 一次性向操作系统申请一大堆内存，在此之上构建需要的对象，用完之后统一返还给操作系统。
+ 这样做最大的好处是避免了频繁的 new/delete 开销和带来的内存碎片问题。