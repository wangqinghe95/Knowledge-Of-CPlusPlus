# 软件设计原则
1. 开闭原则
    + 软件实体应当对扩展开放，对修改关闭
2. 里氏替换原则
    + 子类可以拓展父类的功能，尽量不要重写父类的方法
3. 依赖倒置原则
    + 面向接口编程，不要面向实现编程
4. 单一职责原则
    + 一个类应该有且仅有一个引起它变化的原因，否则类就应该被拆分
5. 接口隔离原则
    + 客户端不应该被迫依赖它不适应的方法。一个类对另一个类的依赖应该建立在最小的接口上
6. 迪米特原则
    + 如果两个软件实体无需直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。降低类的耦合度，提高模块的相对独立性
7. 合成复用原则
    + 在软件复用时，尽量先使用组合或者聚合等关联关系来实现，其次再考虑使用继承关系实现

# 简单工厂模式
1. 描述：根据传入的不同参数，返回不同的实例
    + 工厂角色负责创建所有实例的内部逻辑
    + 抽象产品角色是所有要创建的所有对象的父类，负责描述所有实例的公共接口
    + 具体产品角色是创建目标，所有创建的对象都是该角色的某个具体类的实例。
2. 实现
    + 根据已经实现的抽象产品类和具体产品类，在工厂类中，根据传入的参数，返回不同的具体产品的类
    
# 策略模式
1. 描述
    + 定义一系列的算法，将他们一一封装起来，并且使他们可相互替换。
2. 实现
    + 抽象算法类在使用类的构造函数中被注册，使用过程中，可以直接先将具体类的实例化在实用类构造时直接作为构造参数传入。

# 装饰模式
1. 描述：
    + 用来给对象增加某些特性或者对被修饰对象进行某些修改
2. 实现
    + 装饰器类继承抽象的对象类，并且具体的装饰器类包含抽象的对象类。
    + 值得注意的是，是装饰的具体类需要一层一层嵌套的，最终嵌套到使用的对象类。并且最终显示使用需要最外层的装饰类来调用
    
# 代理模式
1. 描述：
    + 为其他对象提供一种代理以控制这个对象的访问
2. 实现：
    + 代理类中有一个访问对象类的指针，通过调用代理类的相关接口去使用对象类中的功能

# 工厂模式

# 模板方法模式

# 外观模式

# 建造者模式

# 观察者模式

# 抽象工厂模式

# 状态模式

# 适配器模式

# 备忘录模式

# 组合模式