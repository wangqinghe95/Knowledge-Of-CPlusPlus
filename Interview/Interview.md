# 20200924
# C++知识点
## C/C++语言
1. 谈谈你对C和C++的编程差异理解
	+ 他们最重要的是设计思想和应用场景的不同；
	+ 出于对内存和执行效率的考虑，C 的优点是精简和高效，多用于操作系统和内核驱动；而 C++ 设计之初的目的就是想把 C 繁杂的实现过程抽象成类，并且进行实例化管理，适合做大型软件。总结就是 C 更注重逻辑实现, C++ 更适合程序的整体设计。
	+ C++ 和 C 的基础语法是没有特别差异，但是 C++ 会有多很多特性，比如引用，new/delete，auto/decltype，重载虚函数，还有面向对象部分的类，继承，对象的内容。还有范式编程，异常机制，元编程，STL标准库这些特性。

---

2. static关键字在C语言和C++中各自有哪些不同用法？
	+ static 主要分为修饰全局变量，局部变量，函数，C++的成员函数和成员变量；
	+ 修饰全局变量改变的是该变量的可见范围，从原来所有文件可见状态变成只有当前文件可见；
	+ 修改局部变量和函数改变的是修饰对象的生存周期，从原来函数的生存周期变成整个程序的生存周期；
	+ 修饰成员函数和成员变量，修饰的函数和变量是被整个类的对象所共有。静态成员函数中不包含this指针。

	+ static 修饰的变量放在全局区，修饰的函数
	+ 修饰的成员函数不能和 const（放在函数后） 一起使用，是因为 const 修饰的函数需要一个隐藏的 const this* 指针

---

3. union是什么，有什么用？
	+ 共用体，也叫联合体。在一个联合体内可以定义多种不同的数据类型，这些数据共享同一段内存。union 所占的内存长度等于最长的成员的内存长度且是能被所有被包含的基础数据类型整除。目的是为了节省内存地址。

---

4. volatile关键字是做什么用的？
	+ 编译器不在对 volatile 修饰的对象做优化。直接从对象所在的内存地址中去读该值。

---

5. 函数调用过程在汇编层面如何进行？
	+ 函数的调用过程为压栈，跳转，执行代码，返回：
		1. 压栈：返回地址压栈，函数参数压栈；
		2. 跳转：跳转到函数所在代码处执行；
		3. 执行：执行函数代码；
		4. 返回：平衡堆栈，找出之前的返回地址，跳转回之前的调用点之后，完成函数调用。

---

6. 面向对象有哪些基本特性？
	1. 封装：把对象的服务和属性结合成一个独立的服务单元，并尽可能的隐藏其内部细节。
	2. 继承：特殊类拥有一般类的服务和属性。通过继承利用已有的数据结构去构造新的数据结构。
	3. 多态：同一操作作用于不同对象产生不同的效果，可以简单的概括为一个接口多个实现。

---

7. 多态是如何实现的？
	1. C++ 编译器为每个含有虚函数的类提供一个虚函数表，虚表用来记录虚函数地址，即虚表中的指针指向虚函数地址。当子类重写父类的虚函数时，子类继承的虚函数表地址相应位置会被修改为子类的虚函数地址。这样父类指针就可以调用子类重写的虚函数，从而实现多态。

---

8、编程实现一个单例模式
+ 单例要点：
	1. 全局只有一个实例，static特性，并且禁止用户自己声明并且定义实例（把构造函数设定为private）；
	2. 线程安全；
	3. 禁止赋值和拷贝；
	4. 用户通过接口获取实例；

+ 代码：InterviewCodeA.cpp

---

9. 影响C++对象大小的因素
	+ 所有非静态成员变量的大小
	+ 字节对齐和字节填充
	+ 虚函数指针
	+ 派生类继承的基类数据的数据成员

注：空类（无静态数据成员）对象大小为1，当作为基类时，大小为0.

Question：（64bit Operate System）
+	Q: 一个对象只有一个int型成员变量，sizeof的大小是多少？
-	A：4
+	Q：一个对象有一个int型和一个char型成员变量，sizeof的大小是多少？
-	Q：8（字节对齐）
+	Q：一个对象只有一个int型成员变量和一个虚函数，sizeof的大小是多少？
-	A：16（字节对齐，虚函数指针，8位）

---

12. 智能指针的原理？
	1. 原理：智能指针实际上是一个对普通指针封装的一个类。将动态分配的资源交给一个类对象去管理，当这个类的生命周期结束时自动调用析构函数释放资源。
		+ shared_ptr：使用引用计数器允许多个智能指针指向同一个对象。引用计数器为 0 时，自动释放释放资源达到防止资源泄漏的目的。
		+ unique_ptr：只允许一个智能指针指向一个对象。不支持普通的拷贝和赋值操作。可以转移一个 unique_ptr 指针的对象，move 移动拷贝构造函数。
		+ weak_ptr：弱指针，主要是解决 shared_ptr 产生的环形引用的问题。weak_ptr 只引用不计数，它指向的内存可能是无效的，使用前最后检查一些它是否为空。

---

13. vector容量满了会发生什么？
	+ 会重新申请一块大小为当前内存大小 1.5 倍的内存，然后再将当前的数据拷贝到新的内存中，再释放旧的内存空间。

	+ resize 和 reserve 的区别：
		+ vector 有容量（capacity）和长度（size）的区别。
		+ capacity 是预分配的空间，size 是当前数组已使用的长度大小。
		+ reserve 调整的是数组容量大小；resize 调整的是已使用的空间大小。

---

14. map和unordered_map各自如何实现？
	+ map 实现原理是红黑树，内部元素有序；增删查的时间复杂度都是 logn 级别的；缺点是空间占用率较大；
	+ unordered_map：使用hash表实现的；查找的时间复杂度是 O(1)；缺点是建立hash表比较耗费时间；

---

15. 右值引用是什么，move是为了解决什么问题？
	+ 是对临时变量的一种引用方法，在初始化完成之后，仍然可以改变临时对象的值；
	+ move 是将对象的所有权从一个对象转移到另一个对象，没有内存搬迁或者拷贝；主要是为了解决拷贝构造函数的一些额外消耗；

---

16. 构造函数能不能抛出异常？析构函数呢？
	1. 构造函数可以抛出异常，但是抛出异常后会导致析构函数无法被调用，但是对象申请到的内存资源会被系统释放；因为析构函数不能被调用所以有内存泄漏的风险；总结就是构造函数可以抛出异常，但是必须保证在构造函数抛出异常之前，把系统资源释放掉；
	2. 析构函数不能抛出异常。虽然C++并不禁止析构函数抛出异常，但是这样会导致程序过早结束或者出现不明确的行为。

---

17. C++中哪几种类型转换，区别是什么？
	1. reinterpret_cast:类型之间的转换
	2. const_cast:用于修改类型的 const 和 validate 属性；
	3. static_cast：派生类指针或引用转换为基类
	4. dynamic_cast: 基类指针或引用转换成派生类

（代码补充）
---

18. 从源代码到可执行程序，中间的过程是什么样的？
	1. 预编译：处理 # 号开头的预处理命令
	2. 编译：生成汇编文件
	3. 汇编：生成重定向文件
	4. 链接：将可重定向文件做静态链接和动态链接处理
	5. 可执行程序：生成可执行文件
	
---

# 0x02：数据结构与算法部分
1. 二叉树的四种遍历方式
	+ 前序遍历、中序遍历、后序遍历、层次遍历

---

2. 哈希表工作原理，如何解决哈希冲突？
	+ 工作原理：hash表是一个可以根据关键码值直接访问的数据结构，其原理是通过将关键码值映射到表中的特定位置。其中映射函数叫做散列函数，存放记录数组叫做散列表。采用散列技术将数据存储在一块连续的的存储空间中。
	+ 解决冲突的方法：
		1. 线性探测法：当发生冲突时，继续向后遍历，直到找到一个空位来存放当前数据；
		2. 开链法：每个 hash 表的表格维护一个链表，将每个映射过来的数据直接插入到链表尾部；
		3. 再散列：发生冲突后使用另一种映射函数重新计算一个新的地址，直到不再冲突为止；
		4. 二次探测：发生冲突后，按照步长的平方距离继续寻找空位；

---

3. 编程实现一个二分查找
	+ 代码：InterviewCodeA.cpp
---

4. 常用的排序算法，各自的平均时间复杂度是什么？

	+ 冒泡排序：O(N^2)
	+ 插入排序：O(N^2)
	+ 选择排序：O(N^2)
	+ 希尔排序：O(NlogN)
	+ 快速排序：O(NlogN)
	+ 堆排序：	O(NlogN)
	+ 归并排序：O(NlogN)

	+ 代码：InterviewCodeA.cpp
---

5. 1-2走台阶问题，递归和动态规划两种解题方法
	+ 代码：InterviewCodeA.cpp
---

6. 一个一维数组，先单调递增，后单调递减，如何找到这个拐点？
+ 思路1：二分法-拐点的定义是局部最大，意思是要大于左侧和右侧。通过二分法来找
```
int getBreakPoint(vector<int> &arr) {
    int left = 0;
    int right = arr.size() - 1;
    while (left < right) {
        int mid = (left + right) / 2;
        if (mid > 0 && arr[mid] > arr[mid-1]) {
            left = mid;
        }
        if (mid < arr.size() - 1 && arr[mid] > arr[mid+1]) {
            right = mid;
        }
    }
    return left;
}
```
+ 思路2：从左侧到右侧遍历，拐点值要大于左侧且右侧的值。
+ 如果是严格的先增后减，就不会有最大值在第一位和最后一位的情况了
```
	for (int i = 1; i < arr.size()-1; ++i) {
		if (arr[i] > arr[i-1] && arr[i] > arr[i+1]) {
			return arr[i];
		}
	}
```
---

7. 如何设计一个算法，快速判断一个IP地址有没有在系统中出现过？
+ 使用位图存储，0号位代表 0.0.0.0; 1 代表 0.0.0.1, 128(2^8)代表 0.0.0.127,256 代表 0.0.0.255, 2^32 可以代表 255.255.255.255
+ 一共 2^32 次方的 bitmap，需要约 512MB 大小的内存空间，查询O(1),插入O(n)

---
8. 设计一个线程安全的队列。
+ 对队列和线程的互斥量和条件变量进行封装，对于队列的插入、删除、查询的操作都进行加锁设置，保证多线程操作该队列数据时是串行操作；

---

0x03：操作系统
1. 进程和线程的区别？
	+ 最本质的区别：进程是操作系统分配资源的最小单位，而线程是处理器任务调度和执行的最小单位；
	+ 系统开销的区别：
	+ 包含关系：
	+ 内存分配：
	+ 执行条件：

---

2. 进程地址空间里面有什么东西？
	+ 栈、堆、全局常量区、代码区；

---

3. 线程的栈里面有哪些东西？
	+ 程序计数器、栈指针；

---
4. fork的原理是什么？
	+ 将父进程的所有数据都复制一遍，然后fork函数会返回两次，一次是父进程的 pid， pid > 0。一次是子进程，pid = 0；当然，如果 fork 失败，则会返回 -1；调用者根据返回的 pid 来判断是父进程还是子进程去处理对应的代码逻辑；

---

5. 进程间通信有哪些方式？
	+ 管道：有名管道和无名管道
	+ 共享内存：
	+ 消息队列
	+ socket 套接字
	+ 信号
	+ 信号量

---

6、共享内存的原理是什么？
	+ 原理：两个进程地址通过页表映射到同一块物理地址中，这样一个进程对于该地址进行的数据操作都可以被另外一个进程可见，这样就达到了进程通信的效果；
	+ 优点：进程间传输数据最快的方式。没有数据拷贝的动作，两个进程可以直接对其进行读写数据的操作，并且对读写的数据类型没有限制；
	+ 缺点：在服务进程写入数据结束之前，没有机制阻止另外一个进程对其进行读写，所以通常需要搭配信号量来完成共享内存同步访问控制；

---
7. 原子操作的原理是什么？
	+ 原子操作是不可被中断的一个或者一些列操作；
	+ 实现方式：
		1. 总线锁：处理器提供一个LOCK信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被暂时阻塞，那么处理器可以独占共享内存；总线锁将CPU和内存之间的通信给锁住了，其他处理器不能处理其他内存的数据，导致开销过大；
		2. 缓存锁：在同一时刻保证对某个内存地址的操作是原子性即可。有两种情况不支持缓存锁：1、当操作的数据不能被缓存到处理器内部或者操作的数据跨多个缓存行时，处理器会调用总线锁；2、有些处理器不支持缓存锁；

---

8. I/O多路复用有哪些模型？
	+ 当多个客户端和服务端通信时，如果服务端阻塞在其中一个客户的 read(sockfd1、...),当另一个客户的数据到达 sockfd2时，服务端就无法及时处理，此时就需要用到 IO 多路复用。即同时监视 n 个客户，当其中有一个发来数据时就从 select 阻塞中返回，然后调用 read 读取收到数据的 sockfd，然后又返回到 select 阻塞。这样就解决了阻塞在一个消息无法处理其他请求的问题。即解决的是对多个 I/O 监听时，一个 I/O 阻塞会影响其他 I/O 处理的问题；
	+ select/poll/epoll

---

9. epoll高性能的原因有哪些？
	1. epoll 通过将注册时间添加到 epoll 句柄的方式保证了每个 fd 在整个过程中只会被拷贝一次，避免了每次拷贝的开销；
	2. epoll 通过回调的方式，将每个就绪设备的 fd 添加到就绪链表中。epoll_wait 监听就绪链表是否为空。节省了大量的轮询查询文件描述符是否就绪的时间和资源；
	3. 

---
10. 谈一谈signal机制
	+ 概念：用信号来进行进程之间传递消息的方法；
	+ 产生方式：
		1. 键盘产生
		2. 硬件产生
		3. 系统函数产生
		4. 某种软件条件达到产生
	+ 处理方式：
		1. 默认处理方式
		2. 自定义处理函数
		3. 忽略

---

11. 什么是系统调用，执行系统调用的过程是什么？
	+ 操作系统为用户编程提供的函数和方法；
	+ 首先代码中传递系统调用参数，然后由陷入指令负责将用户态转换内核态，并将返回地址压栈备用；然后CPU执行相应的内核服务程序，最后返回用户态；

---

12. 写时拷贝是什么，底层实现原理？
	+ 在 linux 系统中，调用 fork 函数创建子进程时并不会直接将父进程所占的内存也复制一份，而是和父进程使用相同的内存，当子进程或父进程对内存页进行修改时才会进行复制；这就是很著名的写时拷贝；
	+ 使用引用计数器的方法，在开辟的空间最前方的空间存储该计数器，复制和拷贝构造函数会使得计数器的值+1，析构或者写时拷贝时计数器会-1. 当修改数据时，会先判断计数器的引用是否为0，如果为 0 可以直接使用内存空间，否则触发写时拷贝，计数器 -1，拷贝一份数据出来修改，然后新的内存计数器置 0；如果是析构时如果计数器的引用数为 0，则直接释放内存地址，否则就 -1；
---

# 0x04：计算机网络
1. 四层模型是哪四层，各自负责什么功能？
	+ 应用层：FTP、Telent
	+ 传输层：TCP、UDP
	+ 网络层：IP、ICMP、IGMP
	+ 链路层：设备驱动以及接口卡

+ 负责的功能：
	1. 链路层：包括操作系统中的设备驱动、计算机中对应的网络接口卡
	2. 网络层：（互联网层）处理分组在网络中的活动，路由选择等；
	3. 运输层：主要为两台主机上的应用提供端到端的通信；
	4. 应用层：处理应用程序的细节

---

2. ping命令是什么原理？
	+ ping 命令发送一个 ICMP（Internet Control Messages Protocol：因特网控制报文协议），利用网络地址上网络 IP 地址的唯一性，给目标地址发送一个数据包，通过对方回复的数据包来确定两台机器是否联通，时延多少；

---

3. traceroute是什么原理？
	+ traceroute 是一种常规的网络分析工具，用来定位到目标主机之间的所有路由；
	+ 源主机向目的主机发送 IP 数据报，并按照顺序将 TTL 的值从 1 开始增长到 N（N代表到达目的主机的路由转发次数），这样就会使得当 TTL 值为 0 的节点丢弃数据包并返回出错信息。源主机根据接收到的错误信息，确定到达目标主机路径上的所有节点的 IP，以及对应的耗时；

---

4. 什么是ARP欺骗？
	+ ARP 欺骗是针对以太网地址解析协议的一种攻击方式。这种攻击可让攻击者获取局域网上的数据包甚至可篡改数据包，且可让网络上特定计算机或者所有计算机无法正常连线；
	+ ARP 欺骗是由攻击者发送假的 ARP 数据包到网络上，尤其是到网关上去。其目的是要让送至特定 IP 地址的流量被错误的送到攻击者取代的地方。因此攻击者可将这些流量另作处理后、转送到真正的网关，或者篡改后再传送。

---

5. 集线器、交换机、路由器的区别？
	+ 			路由器		交换机		集线器
	+ 工作层次： 网络层		数据链路层	 物理层
	+ 转发依据： IP地址		Mac地址		 无
	+ 功能：	连接不同网路 连接局域中的网络
	+ 宽带影响：共享宽带	独享宽带	共享
	+ 数据传输：有目的的传输 有目的的传输 广播
	+ 传输模式：全双工		全双工或半双工	半双工

---

6. 什么是MTU？为什么是这个大小？
	+ MTU：（Maximun Transmission Unit)，网络最大传输单元，通常被设置为 1500 字节大小；
	+ 早期以太网采用的是共享链路的工作方式，为了保证 CSMA/CD（载波多路复用/冲突检测），规定了以太网帧在[64,1518]字节。64 是为了保证最极端的冲突能够被检测到，1518 是为了防止过长的帧传输时间过长而占用共享链路太长时间导致其他业务阻塞。
	+ 以太网的最大数据帧是 1518 字节，去掉帧头 14 字节，帧尾 CRC 校验部分 4 字节，那么剩下能承接上层的 IP 报文最大就只有 1500 字节，这就数字就是以太网默认的 MTU 值。

---

7. TCP三次握手和四次挥手机制

---

8. TCP的第三次握手可以携带数据吗？
	+ 可以携带，因为客户端已经是 established 状态了。

---

9. TCP可靠性由哪些机制保证？
	1. 序列号
	2. 校验和
	3. 确认应答信号
	4. 重发控制
	5. 连接管理控制
	6. 窗口控制
	7. 流量控制
	8. 拥塞控制

---

10. 超时重传如何进行？

---

11. DNS解析过程如何进行？
	1. 浏览器得到一个域名后，会从浏览器缓存，计算机本机host文件找对应的 IP 地址；
	2. 没有命中的话去找本地域名解析器；
	3. 如果没有命中的话，会发请求到根域名服务器，根域名服务器会返回一个顶级域名服务器的 IP 地址；
	4. 浏览器会向顶级域名服务器发送解析请求，如果顶级域名服务器也没有对应的映射关系的话，会返回一个管理该域的下一级DNS的ip地址，浏览器拿着这个IP地址继续去请求；直到找到或者完全找不到为止；

---

12. HTTP中有哪些Method，POST和PUT什么区别？
	+ GET、HEAD、PUT、POST、DELETE、OPTIONS、CONNECT、TRACE、PATCH
	+ POST：向指定资源提交数据，进行处理请求。数据被包含在请求体中；
	+ PUT：从客户端向服务器端提交的数据取代指定文档中的内容；

---

13. HTTP1.0和1.1有什么区别？
	1. 长连接：
	2. host字段
	3. 缓存处理
	4. 带宽优化以及网络连接使用
	5. 新增一些错误通知状态码

---

14. HTTPS安全性的原理
	+ HTTPS 是基于 HTTP 的上层添加了一个 TSL 安全层，对数据的加密等操作都是在这个安全层进行处理的。其底层应用还是 HTTP。
	+ HTTPS 通信先是使用了非对称加密的进行密钥协商，协商出一个对称加密的密钥，之后的通信则采用这个对称密钥进行对称加密的密文传输。

---

15. 什么是反向代理？nginx负载均衡有哪些策略？

---

16、从输入网址到网页内容展示出来，发生了哪些事？
	+ DNS 解析：
	+ 三次握手：
	+ 发送 HTTP 请求：
	+ 服务器处理请求并返回 HTTP 报文：
	+ 浏览器介绍请求并渲染网页：
	+ 断开连接：TCP四次挥手；

---

# 0x05：数据库
1、什么是数据库索引？
2、MySQL数据库索引有哪些实现方式？
3、B+树和哈希索引各自的应用场景？
4、什么是回表？
5、什么是事务？事务的基本特性？
6、分库分表有哪些方案？有什么区别？
7、什么是缓存击穿、缓存雪崩、缓存穿透？
8、Redis单线程为什么很快？
9、Redis怎么实现消息队列？
10、Redis有哪些持久化方式？各自实现原理？
11、ElasticSearch基本原理？