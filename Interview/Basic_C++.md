# Basic C++

## 概述
1. C/C++ 的区别
    + 设计上区别，设计 C 的目的就是为了管理计算机的系统资源，所以语言精简，高效，自由。设计 C++ 的目的就是在兼顾程序执行效率的同时，注重程序的整体设计。也有抽象和精简 C 语言的实现过程这个目的。
    + 底层设计的不同最终导致了上层实现的不同，从 C++ 多出来的一些关键字，多出来的面向对象的特性，封装，多态，继承。再到后面就和 C 分道扬镳的特性，元编程，范式编程等等。都是两者设计不同衍生出来的差异。
  
## 关键字
1. const 的作用
   + 阻止修饰的对象被修改。
   + 可以修饰变量，指针，指针地址，函数参数，函数返回值，类成员函数，类对象等
2. static 的作用
   1. 修饰变量，变量会被存储到静态变量区，其生存周期与程序的运行周期一致，作用域会被限制到声明的范围，全局静态变量只能被本文件访问，局部静态变量只能被当前函数访问，类成员变量可以被所有该类对象访问，但是属于某个类实例。
   2. 修饰类成员函数和类成员函数，属于该类本身，无需实例化可以直接使用类名访问
   3. 修饰普通的全局函数，作用域限制在本文件中
3. NULL 和 nullptr 区别
   1. NULL 表示整数零，而 nullptr 表示空指针
   2. 早期版本的 NULL 会存在整数零和空指针的歧义。所以 C++ 11 版本引入 nullptr 消除这种歧义。
4. struct 和 class 的区别
   + C++ 中，只有默认的权限不同，前者默认公有属性，后者默认私有属性
   + C 中的 struct 只是用户自定义数据类型，是一些变量的集合；C++ 的 struct 是抽象数据类型，能够支持成员函数，设置访问权限，继承等。


## 运算符
1. C++ 有哪些强制转换运算符？
   1. static_cast：执行非动态转换，没有运行时类检查保证的安全性。可以用于基类指针转换成派生类指针。
      + 和 C 的强制转换相比更安全，编译器会进行编译检查，如果转换类型不合法会报错
      + 更直观，转换前后的类型显示的在代码体现，利于阅读。
   2. const_cast：修改类型的 const 和 volatile 属性。目标类型必须于原类型相同，主要操作对象的 const 属性
   3. dynamic_cast：运行时执行转换，验证转换的有效性。如果转换失败，则表达式判定为 null。主要用于类的指针，类的引用或 void* 转换。
   4. reinterpret_cast：将某种指针转换成其他类型指针。也可以将指针转换为整数或者反而为之。
   5. 派生类指针转换成基类指针时会产生编译错误，就算使用强转，指向基类的派生指针访问的函数依然是派生类的函数。

## 基础语法
1. 强制内联是什么，和普通内联有什么区别
   1. 内联是 C++ 一种优化技术，可以将代码行数较少的函数直接插入到函数调用的地方去，节省了函数调用的开销。比如访问器函数，操作符重载函数等
   2. 内联一般是由编译器决定，但是 C++ 提供了一个关键字 inline 和修饰符 __forceinline，能够强制要求编译器执行内联操作，即使这个步骤在编译器看来不是最优选择，这就是强制内联。

## 指针引用相关

1. C++ 指针和引用的区别
   + 引用会在编译时被解释成常指针，可以理解引用是常指针的一种更安全的封装
   + 它们会在使用的语法上有一些区别，比如引用是一种别名，需要初始化，没有多级引用
2. 值传递、指针传递、引用传递的区别和效率？
   + 值传递是将值赋值一份到函数中，指针传递和引用传递将变量的地址传到函数中。
   + 内置数据结构的值复制消耗不大，但是自定义数据结构在复制值时会大的多。地址本质上是一个 int 类型的值，32 bit 或 64 bit，代价要小的多
   + 值传递在函数中修改不会对原始值产生影响，但是指针传递和引用传递对地址指向的内容做了修改以后会对外部造成影响。
3. 将引用作为函数参数的好处是什么？
   + 一是函数调用的代价小，本质上是复制一个地址过去，二是内部对变量做的处理可以同步到函数外部，三是方便使用更安全，这点是针对指针传递的比较
4. 指针参数传递和引用参数传递有什么区别？底层原理是什么？
   + 没有很大的区别，因为引用本质上也是一个指针，编译器会在编译阶段将引用解释成常指针。
   + 两种参数传递的本质就是将参数的地址传入到函数中使用。
5. 什么时候用指针当参数，什么时候用引用当参数，为什么？
   + 如果要传递一个 C 风格的数组到函数中，则使用指针，因为数组名就是数组首地址
   + 其他情况都尽量使用引用做参数。
6. 数组名和数组首地址指针区别？
   + // Todo
   + 数组名可以理解为指向数组的常指针。不能做自增自减操作
7. 数组和指针的区别
   + 数组是在内存中开辟的一块连续的空间，而指针是一个内置数据类型，保存了一个整数值，该整数值是一个内存地址值，指向一个内存的地址。
8. 野指针和悬空指针的区别？
   + 



## 内存分配相关
1. malloc() 和 free() 的实现原理
   1. 基于内存池实现，程序预先向操作系统申请一定大小的内存，分隔成大小相等的若干个内存块，当有 malloc 来申请时，选择一个满足要求的内存块，标记成已使用，分配给申请者。free 释放时将该内存块标记为可分配即可
   2. 基于堆实现。堆保存的是若干个大小不等的内存块，当有程序申请内存时，操作系统会选择一个满足要求的内存块分配出去，然后标记为已使用，回收时标记为未使用即可。
2. malloc()、realloc()、calloc() 的区别
   1. malloc 申请指定字节的内存区域空间，内存的初始值未知，需要初始化。
   2. realloc 为传入的指针重新分配指定大小的内存，原有内容保持不变。
   3. calloc 申请指定个数的指定大小的内存空间，已经初始化为 0。
3. new/delete 和 malloc/free 的区别？
   + new/delete 是内存分配和释放的关键字，底层实现是对 malloc/free 库函数的封装。
   + new/delete 会对申请的自定义数据类型之后调用类的构造函数或析构函数做类的初始化或者资源释放额外操作。
4. C++ new 的类型
   + plain new：普通的 new，申请内存失败返回一个 std::bad_alloc 错误
   + nothrow new：申请内存失败后不抛出异常，直接返回一个 NULL
   + placement new：在已经申请好的内存上面重新构造对象或者对象数组。
5. 深拷贝和浅拷贝的区别？
   + 浅拷贝是拷贝了指针的值，也就是新旧两个指针指向的内存地址是同一个。
   + 深拷贝是指另开辟了一块内存空间，就指针指向的内容重新复制了一遍。

## 其他
1. 区间和范围的区别？
   + 都表示有一段连续的内存范围，前者是左闭右开的内存，而后者表示左闭右闭的范围
2. 判断两个结构体是否相等？
   + 变量一一比较，指针比较指针指向的内容
3. 形参和实参的区别
   + 形参是函数接收参数的类型定义，实参是一个有实际内存的参数。