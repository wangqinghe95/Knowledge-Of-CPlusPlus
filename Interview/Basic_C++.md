# Basic C++

## 概述
1. C/C++ 的区别
    + 设计上区别，设计 C 的目的就是为了管理计算机的系统资源，所以语言精简，高效，自由。设计 C++ 的目的就是在兼顾程序执行效率的同时，注重程序的整体设计。也有抽象和精简 C 语言的实现过程这个目的。
    + 底层设计的不同最终导致了上层实现的不同，从 C++ 多出来的一些关键字，多出来的面向对象的特性，封装，多态，继承。再到后面就和 C 分道扬镳的特性，元编程，范式编程等等。都是两者设计不同衍生出来的差异。
  
## 关键字
1. const 的作用
   + 阻止修饰的对象被修改。
   + 可以修饰变量，指针，指针地址，函数参数，函数返回值，类成员函数，类对象等
2. static 的作用
   1. 修饰变量，变量会被存储到静态变量区，其生存周期与程序的运行周期一致，作用域会被限制到声明的范围，全局静态变量只能被本文件访问，局部静态变量只能被当前函数访问，类成员变量可以被所有该类对象访问，但是属于某个类实例。
   2. 修饰类成员函数和类成员函数，属于该类本身，无需实例化可以直接使用类名访问
   3. 修饰普通的全局函数，作用域限制在本文件中
3. NULL 和 nullptr 区别
   1. NULL 表示整数零，而 nullptr 表示空指针
   2. 早期版本的 NULL 会存在整数零和空指针的歧义。所以 C++ 11 版本引入 nullptr 消除这种歧义。

## 运算符
1. C++ 有哪些强制转换运算符？
   1. static_cast：执行非动态转换，没有运行时类检查保证的安全性。可以用于基类指针转换成派生类指针。
      + 和 C 的强制转换相比更安全，编译器会进行编译检查，如果转换类型不合法会报错
      + 更直观，转换前后的类型显示的在代码体现，利于阅读。
   2. const_cast：修改类型的 const 和 volatile 属性。目标类型必须于原类型相同，主要操作对象的 const 属性
   3. dynamic_cast：运行时执行转换，验证转换的有效性。如果转换失败，则表达式判定为 null。主要用于类的指针，类的引用或 void* 转换。
   4. reinterpret_cast：将某种指针转换成其他类型指针。也可以将指针转换为整数或者反而为之。
   5. 派生类指针转换成基类指针时会产生编译错误，就算使用强转，指向基类的派生指针访问的函数依然是派生类的函数。

## 基础语法
1. C++ 指针和引用的区别
   + 引用会在编译时被解释成常指针，可以理解引用是常指针的一种更安全的封装
   + 它们会在使用的语法上有一些区别，比如引用是一种别名，需要初始化，没有多级引用
2. 强制内联是什么，和普通内联有什么区别
   1. 内联是 C++ 一种优化技术，可以将代码行数较少的函数直接插入到函数调用的地方去，节省了函数调用的开销。比如访问器函数，操作符重载函数等
   2. 内联一般是由编译器决定，但是 C++ 提供了一个关键字 inline 和修饰符 __forceinline，能够强制要求编译器执行内联操作，即使这个步骤在编译器看来不是最优选择，这就是强制内联。

## 内存分配相关
1. malloc() 和 free() 的实现原理
   1. 基于内存池实现，程序预先向操作系统申请一定大小的内存，分隔成大小相等的若干个内存块，当有 malloc 来申请时，选择一个满足要求的内存块，标记成已使用，分配给申请者。free 释放时将该内存块标记为可分配即可
   2. 基于堆实现。堆保存的是若干个大小不等的内存块，当有程序申请内存时，操作系统会选择一个满足要求的内存块分配出去，然后标记为已使用，回收时标记为未使用即可。
2. malloc()、realloc()、calloc() 的区别
   1. malloc 申请指定字节的内存区域空间，内存的初始值未知，需要初始化。
   2. realloc 为传入的指针重新分配指定大小的内存，原有内容保持不变。
   3. calloc 申请指定个数的指定大小的内存空间，已经初始化为 0。
3. new/delete 和 malloc/free 的区别？

## 其他
1. 区间和范围的区别？
   + 都表示有一段连续的内存范围，前者是左闭右开的内存，而后者表示左闭右闭的范围