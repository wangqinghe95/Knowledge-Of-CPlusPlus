# Basic C++

## 概述
1. C/C++ 的区别
    + 设计上区别，设计 C 的目的就是为了管理计算机的系统资源，所以语言精简，高效，自由。设计 C++ 的目的就是在兼顾程序执行效率的同时，注重程序的整体设计。也有抽象和精简 C 语言的实现过程这个目的。
    + 底层设计的不同最终导致了上层实现的不同，从 C++ 多出来的一些关键字，多出来的面向对象的特性，封装，多态，继承。再到后面就和 C 分道扬镳的特性，元编程，范式编程等等。都是两者设计不同衍生出来的差异。

## 基础语法
1. 强制内联是什么，和普通内联有什么区别
   1. 内联是 C++ 一种优化技术，可以将代码行数较少的函数直接插入到函数调用的地方去，节省了函数调用的开销。比如访问器函数，操作符重载函数等
   2. 内联一般是由编译器决定，但是 C++ 提供了一个关键字 inline 和修饰符 __forceinline，能够强制要求编译器执行内联操作，即使这个步骤在编译器看来不是最优选择，这就是强制内联。
2. 全局变量，全局静态变量以及局部变量的区别？
   + 全局变量的生存周期是整个程序的生存周期，作用域是整个程序
   + 全局静态变量的生存周期是整个程序的生存周期，作用域是当前文件
   + 局部变量是生存周期是函数运行时，作用域是当前函数
3. cout 和 printf 有什么区别？
   + cout 是一个将数据发送到标准输出设备的类，它有着 C++ 面向对象的特点，比如类型检查，重载 << 符号输出所有类型数据类型等。
   + printf 是一个库函数，通过格式化字符串输出不同类型的数据。
4. ifdef、endif 有什么作用？
   + 预处理命令，避免代码重复定义，实现条件编译
5. define 和 typedef、const、函数、inline 五者的区别
   1. define 是一个预处理指令的宏命令，在编译时期进行简单的文本替换，不进行类型检查
   2. typedef 为现有的数据类型创建一个别名，基本数据类型，指针类型，结构体类型，函数指针类型都行
   3. const 用于常数声明，具有类型安全性
   4. inline 是一个函数，用于优化频繁调用的短小函数，编译时替换且会进行类型检查
   5. 函数一个代码执行的流程块，有参数类型检查，返回值等
6. 什么是隐式转换，如何消除隐式转换？
   1. 隐式转换是不需要用户明确指定的情况下，编译器自动进行类型转换的行为。基本数据类型之间的隐式转换，小精度到大精度，子类对象转换成父类对象，显示构造函数的隐式转换，即构造函数只接受一个参数，它实际上定义了转换为此类类型的隐式转换机制
   2. 在代码中显示的使用类型转换运算符，避免隐式转换，比如 static_cast 等关键字。使用 explicit 制止构造函数隐式类型转换。
7. 函数中有重载时，函数的匹配原则和顺序是什么？
   1. 编译器会根据实参类型、数量和顺序等信息来匹配对应的函数，当存在多个可行的而匹配时，会按照一定的规则来确定调用哪个函数。如完全匹配，派生类类型匹配，标准转换匹配，类型提升匹配，算术类型转换实现匹配，类类型转换实现匹配。
   2. 如果存在二义性，即多个函数都没有在任一一个参数上比其他函数好，就会报错。
8. C++ 类型安全？
   1. 类型安全是指编程语言的特性，确保程序在运行时不会访问未授权的内存区域，也不会将数据解释成错误的类型。
   2. C++ 提供了一些机制来保证类型安全，比如编译器的类型检查，类型显示和隐式转换。

## 关键字
1. const 的作用
   + 阻止修饰的对象被修改。
   + 可以修饰变量，指针，指针地址，函数参数，函数返回值，类成员函数，类对象等
2. static 的作用
   1. 修饰变量，变量会被存储到静态变量区，其生存周期与程序的运行周期一致，作用域会被限制到声明的范围，全局静态变量只能被本文件访问，局部静态变量只能被当前函数访问，类成员变量可以被所有该类对象访问，但是属于某个类实例。
   2. 修饰类成员函数和类成员函数，属于该类本身，无需实例化可以直接使用类名访问
   3. 修饰普通的全局函数，作用域限制在本文件中
3. NULL 和 nullptr 区别
   1. NULL 表示整数零，而 nullptr 表示空指针
   2. 早期版本的 NULL 会存在整数零和空指针的歧义。所以 C++ 11 版本引入 nullptr 消除这种歧义。
4. struct 和 class 的区别
   + C++ 中，只有默认的权限不同，前者默认公有属性，后者默认私有属性
   + C 中的 struct 只是用户自定义数据类型，是一些变量的集合；C++ 的 struct 是抽象数据类型，能够支持成员函数，设置访问权限，继承等。
5. extern 关键字作用
   1. 引用不在同一个文件的变量和函数，实现在不同文件之间共享变量和函数的功能
   2. extern "C" 用于指定 C 语言的命名和调用约定，以便在 C++ 中正确实现调用其他 C 语言代码。
6. volatile 关键字
   1. 用于修饰可能被未知因素更改的变量，对该该关键字修饰的变量，编译器对该变量的访问不再进行优化，保证了对特殊地址的稳定访问。
   2. 在多线程环境中确保共享变量的正确性和稳定性。
7. mutable 关键字
   1. 允许在 const 函数中修改被声明为 mutable 的成员变量，从而在特定情况下突破 const 的限制。
   2. 常用于实现缓存或者计数等功能

## 库函数
1. strcpy 、strncpy 、memcpy 的区别？
   1. strcpy 拷贝字符串，遇到 '\0' 终止，如果出现溢出。
   2. strncpy 拷贝指定数量的字符串，有个拷贝字符个数的参数。
   3. memcpy 拷贝指定长度的内存区域内容。
2. printf、sprintf、ssprintf 的区别
   1. printf() 将格式化的数据输出到标准输出流中，一般都是控制台
   2. sprintf() 将格式化的数据输出到指定字符缓冲区中，比如一个指针指向的内容地址
   3. ssprintf() 作用同 sprintf()，但是会指定输入字符的大小，防止缓冲区溢出。
3. strlen 和 sizeof 的区别？
   1. strlen 是一个库函数，用于计算以空字符为结尾的字符串的长度。
   2. sizeof 是一个编译器的运算符，计算数据类型或变量的大小。包括基本数据类型，指针类型，和复合数据类型，如结构体和联合体。

## 指针引用相关

1. C++ 指针和引用的区别
   + 引用会在编译时被解释成常指针，可以理解引用是常指针的一种更安全的封装
   + 它们会在使用的语法上有一些区别，比如引用是一种别名，需要初始化，没有多级引用
2. 值传递、指针传递、引用传递的区别和效率？
   + 值传递是将值赋值一份到函数中，指针传递和引用传递将变量的地址传到函数中。
   + 内置数据结构的值复制消耗不大，但是自定义数据结构在复制值时会大的多。地址本质上是一个 int 类型的值，32 bit 或 64 bit，代价要小的多
   + 值传递在函数中修改不会对原始值产生影响，但是指针传递和引用传递对地址指向的内容做了修改以后会对外部造成影响。
3. 将引用作为函数参数的好处是什么？
   + 一是函数调用的代价小，本质上是复制一个地址过去，二是内部对变量做的处理可以同步到函数外部，三是方便使用更安全，这点是针对指针传递的比较
4. 指针参数传递和引用参数传递有什么区别？底层原理是什么？
   + 没有很大的区别，因为引用本质上也是一个指针，编译器会在编译阶段将引用解释成常指针。
   + 两种参数传递的本质就是将参数的地址传入到函数中使用。
5. 什么时候用指针当参数，什么时候用引用当参数，为什么？
   + 如果要传递一个 C 风格的数组到函数中，则使用指针，因为数组名就是数组首地址
   + 其他情况都尽量使用引用做参数。
6. 数组名和数组首地址指针区别？
   + 数组名是指向数组首元素的常指针，不允许更改，不能做自增自减操作。
   + 数组首地址指针是指向数组首地址的指针，是一个变量。
7. 数组和指针的区别
   + 数组是在内存中开辟的一块连续的空间，而指针是一个内置数据类型，保存了一个整数值，该整数值是一个内存地址值，指向一个内存的地址。
8. 野指针和悬空指针的区别？
   + 野指针是没有初始化的指针，悬空指针是指针指向的区域已经被释放了。两者都是指向无效内存区域的指针，访问可能会导致未定义的行为。
9. 函数指针是什么？
   + 一个指针指向一个函数的地址。既可以使用该指针调用指向的函数，又可以作为函数参数在函数中传递。
10. 指针和引用之间如何转换？
   + 指针转引用，在指针变量前加上 * 号然后赋值给引用类型即可，一般用于引用参数中。
   + 引用转指针，只需要在引用变量前加 & 符合复制给指针类型即可。

## 内存分配相关
1. malloc() 和 free() 的实现原理
   1. 基于内存池实现，程序预先向操作系统申请一定大小的内存，分隔成大小相等的若干个内存块，当有 malloc 来申请时，选择一个满足要求的内存块，标记成已使用，分配给申请者。free 释放时将该内存块标记为可分配即可
   2. 基于堆实现。堆保存的是若干个大小不等的内存块，当有程序申请内存时，操作系统会选择一个满足要求的内存块分配出去，然后标记为已使用，回收时标记为未使用即可。
2. malloc()、realloc()、calloc() 的区别
   1. malloc 申请指定字节的内存区域空间，内存的初始值未知，需要初始化。
   2. realloc 为传入的指针重新分配指定大小的内存，原有内容保持不变。
   3. calloc 申请指定个数的指定大小的内存空间，已经初始化为 0。
3. new/delete 和 malloc/free 的区别？
   + new/delete 是内存分配和释放的关键字，底层实现是对 malloc/free 库函数的封装。
   + new/delete 会对申请的自定义数据类型之后调用类的构造函数或析构函数做类的初始化或者资源释放额外操作。
4. C++ new 的类型
   + plain new：普通的 new，申请内存失败返回一个 std::bad_alloc 错误
   + nothrow new：申请内存失败后不抛出异常，直接返回一个 NULL
   + placement new：在已经申请好的内存上面重新构造对象或者对象数组。
5. 深拷贝和浅拷贝的区别？
   + 浅拷贝是拷贝了指针的值，也就是新旧两个指针指向的内存地址是同一个。
   + 深拷贝是指另开辟了一块内存空间，就指针指向的内容重新复制了一遍。
6. C++ 有哪些内存管理方式
   1. 智能指针，RAII，容器和标准库，new/delete

## 其他
1. 区间和范围的区别？
   + 都表示有一段连续的内存范围，前者是左闭右开的内存，而后者表示左闭右闭的范围
2. 判断两个结构体是否相等？
   + 变量一一比较，指针比较指针指向的内容
3. 形参和实参的区别
   + 形参是函数接收参数的类型定义，实参是一个有实际内存的参数。
4. 什么是对象复用？什么是零拷贝？
   1. 对象复用是设计模式中的享元模式，通过将对象存储到“对象池”中实现对对象的重复使用，这样可以避免多次创建重复对象的开销，节省系统资源。
   2. 零拷贝是一种避免 CPU 将数据从一块内存拷贝到另一块内存中。通过各种零拷贝技术可以减少不必要的数据拷贝，提供程序性能。
5. C++ 有哪些强制转换运算符？
   1. static_cast：执行非动态转换，没有运行时类检查保证的安全性。可以用于基类指针转换成派生类指针。
      + 和 C 的强制转换相比更安全，编译器会进行编译检查，如果转换类型不合法会报错
      + 更直观，转换前后的类型显示的在代码体现，利于阅读。
   2. const_cast：修改类型的 const 和 volatile 属性。目标类型必须于原类型相同，主要操作对象的 const 属性
   3. dynamic_cast：运行时执行转换，验证转换的有效性。如果转换失败，则表达式判定为 null。主要用于类的指针，类的引用或 void* 转换。
   4. reinterpret_cast：将某种指针转换成其他类型指针。也可以将指针转换为整数或者反而为之。
   5. 派生类指针转换成基类指针时会产生编译错误，就算使用强转，指向基类的派生指针访问的函数依然是派生类的函数。
6. swap 实现
   1. 算术法，异或法，模板法

## 面向对象