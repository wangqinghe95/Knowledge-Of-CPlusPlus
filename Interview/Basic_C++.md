# Basic C++

## 概述

1. C/C++ 的区别
    + 设计上区别，设计 C 的目的就是为了管理计算机的系统资源，所以语言精简，高效，自由。设计 C++ 的目的就是在兼顾程序执行效率的同时，注重程序的整体设计。也有抽象和精简 C 语言的实现过程这个目的。
    + 底层设计的不同最终导致了上层实现的不同，从 C++ 多出来的一些关键字，多出来的面向对象的特性，封装，多态，继承。再到后面就和 C 分道扬镳的特性，元编程，范式编程等等。都是两者设计不同衍生出来的差异。

## 基础语法

1. 强制内联是什么，和普通内联有什么区别
   1. 内联是 C++ 一种优化技术，可以将代码行数较少的函数直接插入到函数调用的地方去，节省了函数调用的开销。比如访问器函数，操作符重载函数等
   2. 内联一般是由编译器决定，但是 C++ 提供了一个关键字 inline 和修饰符 __forceinline，能够强制要求编译器执行内联操作，即使这个步骤在编译器看来不是最优选择，这就是强制内联。
2. 全局变量，全局静态变量以及局部变量的区别？
   + 全局变量的生存周期是整个程序的生存周期，作用域是整个程序
   + 全局静态变量的生存周期是整个程序的生存周期，作用域是当前文件
   + 局部变量是生存周期是函数运行时，作用域是当前函数
3. cout 和 printf 有什么区别？
   + cout 是一个将数据发送到标准输出设备的类，它有着 C++ 面向对象的特点，比如类型检查，重载 << 符号输出所有类型数据类型等。
   + printf 是一个库函数，通过格式化字符串输出不同类型的数据。
4. ifdef、endif 有什么作用？
   + 预处理命令，避免代码重复定义，实现条件编译
5. define 和 typedef、const、函数、inline 五者的区别
   1. define 是一个预处理指令的宏命令，在编译时期进行简单的文本替换，不进行类型检查
   2. typedef 为现有的数据类型创建一个别名，基本数据类型，指针类型，结构体类型，函数指针类型都行
   3. const 用于常数声明，具有类型安全性
   4. inline 是一个函数，用于优化频繁调用的短小函数，编译时替换且会进行类型检查
   5. 函数一个代码执行的流程块，有参数类型检查，返回值等
6. 什么是隐式转换，如何消除隐式转换？
   1. 隐式转换是不需要用户明确指定的情况下，编译器自动进行类型转换的行为。基本数据类型之间的隐式转换，小精度到大精度，子类对象转换成父类对象，显示构造函数的隐式转换，即构造函数只接受一个参数，它实际上定义了转换为此类类型的隐式转换机制
   2. 在代码中显示的使用类型转换运算符，避免隐式转换，比如 static_cast 等关键字。使用 explicit 制止构造函数隐式类型转换。
7. 函数中有重载时，函数的匹配原则和顺序是什么？
   1. 编译器会根据实参类型、数量和顺序等信息来匹配对应的函数，当存在多个可行的而匹配时，会按照一定的规则来确定调用哪个函数。如完全匹配，派生类类型匹配，标准转换匹配，类型提升匹配，算术类型转换实现匹配，类类型转换实现匹配。
   2. 如果存在二义性，即多个函数都没有在任一一个参数上比其他函数好，就会报错。
8. C++ 类型安全？
   1. 类型安全是指编程语言的特性，确保程序在运行时不会访问未授权的内存区域，也不会将数据解释成错误的类型。
   2. C++ 提供了一些机制来保证类型安全，比如编译器的类型检查，类型显示和隐式转换。

## 关键字

1. const 的作用
   + 阻止修饰的对象被修改。
   + 可以修饰变量，指针，指针地址，函数参数，函数返回值，类成员函数，类对象等
2. static 的作用
   1. 修饰变量，变量会被存储到静态变量区，其生存周期与程序的运行周期一致，作用域会被限制到声明的范围，全局静态变量只能被本文件访问，局部静态变量只能被当前函数访问，类成员变量可以被所有该类对象访问，但是属于某个类实例。
   2. 修饰类成员函数和类成员函数，属于该类本身，无需实例化可以直接使用类名访问
   3. 修饰普通的全局函数，作用域限制在本文件中
3. NULL 和 nullptr 区别
   1. NULL 表示整数零，而 nullptr 表示空指针
   2. 早期版本的 NULL 会存在整数零和空指针的歧义。所以 C++ 11 版本引入 nullptr 消除这种歧义。
4. struct 和 class 的区别
   + C++ 中，只有默认的权限不同，前者默认公有属性，后者默认私有属性
   + C 中的 struct 只是用户自定义数据类型，是一些变量的集合；C++ 的 struct 是抽象数据类型，能够支持成员函数，设置访问权限，继承等。
5. extern 关键字作用
   1. 引用不在同一个文件的变量和函数，实现在不同文件之间共享变量和函数的功能
   2. extern "C" 用于指定 C 语言的命名和调用约定，以便在 C++ 中正确实现调用其他 C 语言代码。
6. volatile 关键字
   1. 用于修饰可能被未知因素更改的变量，对该该关键字修饰的变量，编译器对该变量的访问不再进行优化，保证了对特殊地址的稳定访问。
   2. 在多线程环境中确保共享变量的正确性和稳定性。
7. mutable 关键字
   1. 允许在 const 函数中修改被声明为 mutable 的成员变量，从而在特定情况下突破 const 的限制。
   2. 常用于实现缓存或者计数等功能

## 库函数

1. strcpy 、strncpy 、memcpy 的区别？
   1. strcpy 拷贝字符串，遇到 '\0' 终止，如果出现溢出。
   2. strncpy 拷贝指定数量的字符串，有个拷贝字符个数的参数。
   3. memcpy 拷贝指定长度的内存区域内容。
2. printf、sprintf、ssprintf 的区别
   1. printf() 将格式化的数据输出到标准输出流中，一般都是控制台
   2. sprintf() 将格式化的数据输出到指定字符缓冲区中，比如一个指针指向的内容地址
   3. ssprintf() 作用同 sprintf()，但是会指定输入字符的大小，防止缓冲区溢出。
3. strlen 和 sizeof 的区别？
   1. strlen 是一个库函数，用于计算以空字符为结尾的字符串的长度。
   2. sizeof 是一个编译器的运算符，计算数据类型或变量的大小。包括基本数据类型，指针类型，和复合数据类型，如结构体和联合体。

## 指针引用相关

1. C++ 指针和引用的区别
   + 引用会在编译时被解释成常指针，可以理解引用是常指针的一种更安全的封装
   + 它们会在使用的语法上有一些区别，比如引用是一种别名，需要初始化，没有多级引用
2. 值传递、指针传递、引用传递的区别和效率？
   + 值传递是将值赋值一份到函数中，指针传递和引用传递将变量的地址传到函数中。
   + 内置数据结构的值复制消耗不大，但是自定义数据结构在复制值时会大的多。地址本质上是一个 int 类型的值，32 bit 或 64 bit，代价要小的多
   + 值传递在函数中修改不会对原始值产生影响，但是指针传递和引用传递对地址指向的内容做了修改以后会对外部造成影响。
3. 将引用作为函数参数的好处是什么？
   + 一是函数调用的代价小，本质上是复制一个地址过去，二是内部对变量做的处理可以同步到函数外部，三是方便使用更安全，这点是针对指针传递的比较
4. 指针参数传递和引用参数传递有什么区别？底层原理是什么？
   + 没有很大的区别，因为引用本质上也是一个指针，编译器会在编译阶段将引用解释成常指针。
   + 两种参数传递的本质就是将参数的地址传入到函数中使用。
5. 什么时候用指针当参数，什么时候用引用当参数，为什么？
   + 如果要传递一个 C 风格的数组到函数中，则使用指针，因为数组名就是数组首地址
   + 其他情况都尽量使用引用做参数。
6. 数组名和数组首地址指针区别？
   + 数组名是指向数组首元素的常指针，不允许更改，不能做自增自减操作。
   + 数组首地址指针是指向数组首地址的指针，是一个变量。
7. 数组和指针的区别
   + 数组是在内存中开辟的一块连续的空间，而指针是一个内置数据类型，保存了一个整数值，该整数值是一个内存地址值，指向一个内存的地址。
8. 野指针和悬空指针的区别？
   + 野指针是没有初始化的指针，悬空指针是指针指向的区域已经被释放了。两者都是指向无效内存区域的指针，访问可能会导致未定义的行为。
9. 函数指针是什么？
   + 一个指针指向一个函数的地址。既可以使用该指针调用指向的函数，又可以作为函数参数在函数中传递。
10. 指针和引用之间如何转换？
   + 指针转引用，在指针变量前加上 * 号然后赋值给引用类型即可，一般用于引用参数中；
   + 引用转指针，只需要在引用变量前加 & 符合复制给指针类型即可。

## 内存分配相关

1. malloc() 和 free() 的实现原理
   1. 基于内存池实现，程序预先向操作系统申请一定大小的内存，分隔成大小相等的若干个内存块，当有 malloc 来申请时，选择一个满足要求的内存块，标记成已使用，分配给申请者。free 释放时将该内存块标记为可分配即可
   2. 基于堆实现。堆保存的是若干个大小不等的内存块，当有程序申请内存时，操作系统会选择一个满足要求的内存块分配出去，然后标记为已使用，回收时标记为未使用即可。
2. malloc()、realloc()、calloc() 的区别
   1. malloc 申请指定字节的内存区域空间，内存的初始值未知，需要初始化。
   2. realloc 为传入的指针重新分配指定大小的内存，原有内容保持不变。
   3. calloc 申请指定个数的指定大小的内存空间，已经初始化为 0。
3. new/delete 和 malloc/free 的区别？
   + new/delete 是内存分配和释放的关键字，底层实现是对 malloc/free 库函数的封装。
   + new/delete 会对申请的自定义数据类型之后调用类的构造函数或析构函数做类的初始化或者资源释放额外操作。
4. C++ new 的类型
   + plain new：普通的 new，申请内存失败返回一个 std::bad_alloc 错误
   + nothrow new：申请内存失败后不抛出异常，直接返回一个 NULL
   + placement new：在已经申请好的内存上面重新构造对象或者对象数组。
5. 深拷贝和浅拷贝的区别？
   + 浅拷贝是拷贝了指针的值，也就是新旧两个指针指向的内存地址是同一个。
   + 深拷贝是指另开辟了一块内存空间，就指针指向的内容重新复制了一遍。
6. C++ 有哪些内存管理方式
   1. 智能指针，RAII，容器和标准库，new/delete

## 其他

1. 区间和范围的区别？
   + 都表示有一段连续的内存范围，前者是左闭右开的内存，而后者表示左闭右闭的范围
2. 判断两个结构体是否相等？
   + 变量一一比较，指针比较指针指向的内容
3. 形参和实参的区别
   + 形参是函数接收参数的类型定义，实参是一个有实际内存的参数。
4. 什么是对象复用？什么是零拷贝？
   1. 对象复用是设计模式中的享元模式，通过将对象存储到“对象池”中实现对对象的重复使用，这样可以避免多次创建重复对象的开销，节省系统资源。
   2. 零拷贝是一种避免 CPU 将数据从一块内存拷贝到另一块内存中。通过各种零拷贝技术可以减少不必要的数据拷贝，提供程序性能。
5. C++ 有哪些强制转换运算符？
   1. static_cast：执行非动态转换，没有运行时类检查保证的安全性。可以用于基类指针转换成派生类指针。
      + 和 C 的强制转换相比更安全，编译器会进行编译检查，如果转换类型不合法会报错
      + 更直观，转换前后的类型显示的在代码体现，利于阅读。
   2. const_cast：修改类型的 const 和 volatile 属性。目标类型必须于原类型相同，主要操作对象的 const 属性
   3. dynamic_cast：运行时执行转换，验证转换的有效性。如果转换失败，则表达式判定为 null。主要用于类的指针，类的引用或 void* 转换。
   4. reinterpret_cast：将某种指针转换成其他类型指针。也可以将指针转换为整数或者反而为之。
   5. 派生类指针转换成基类指针时会产生编译错误，就算使用强转，指向基类的派生指针访问的函数依然是派生类的函数。
6. swap 实现
   1. 算术法，异或法，模板法

## 面向对象

1. 对象模型
   1. 是将现实世界的问题领域通过面向对象的方式进行抽象和建模，形成一种模型表示。它通常是由类、对象、属性等元素组成，用于描述实体之间的关系、结构和行为。
2. C++ 三大特性
   1. 封装、继承、多态。

### 多态相关

1. 多态实现原理
   1. C++ 编译器识别到一个类中有 virtual 关键字或者继承的父类有虚函数表时后，会给该类生成一个虚函数表，即添加一个隐藏指针，指向该对象的虚函数表，即一个数组，存储了该类所有虚函数的地址。
   2. 虚函数指针在会在对象创建时被初始化，指向正确的虚函数表。

### 继承相关

1. 什么是类的继承
   1. 类与类之间有继承、组合、聚合、依赖、泛化五种关系，其中继承是指使用一个已有的类来定义一个新类，新类可以拥有旧类中的属性和方法，实现代码的重用，提供效率的执行。
2. 类的组合和继承各有什么优缺点？
   1. 继承优点是代码重用性好，可扩展性高，缺点是紧耦合，破坏了封装特性
   2. 组合优点是松耦合，可扩展性好，符合封装特性，缺点是不支持动态继承，整体类不能自动获得和局部类同样的接口。
   3. 根据实际情况选择继承或者组合，优先使用组合。
3. 如果想将某个类作为一个基类，为什么该类必须定义而非声明？
   1. 因为派生类需要从基类中继承基类的成员变量，成员函数，需要知道基类的大小和布局，这些都需要对基类做完定义后才能确定。

### this 指针

1. 类的 this 指针
   1. this 指针是一个特殊的隐含指针，指向对象的首地址。
   2. 在调用类的成员函数时，编译系统会先将对象的首地址赋值给 this 指针，将 this 指针作为隐含参数传入到成员函数中，然后调用成员函数。
   3. 在成员函数中访问成员变量或成员函数就是使用 this 指针，this 指针本质是对象的首地址，通过偏移量访问成员变量或成员函数
   4. this 生成于成员函数开始前，销毁于成员函数执行后。生成周期等同于函数参数
2. 在构造函数中 delete this 指针会发生什么？
   1. this 指向的是对象的首地址，delete this 就是调用类的析构函数并释放该对象的内存空间。
   2. 所有涉及到 this 指针的操作都会变得不可控，比如访问成员变量和函数，虚函数等
3. 在成员函数中 delete this 会出现什么问题？对象还可以使用吗？
   1. delete this 之后，所有涉及 this 的操作都会出现不可预期的问题。之后就不能再使用 this 指针了，即不能再调用该对象的任何成员变量，虚函数，成员函数了。
4. 类析构函数中调用 delete this 会发生什么事情
   1. delete this 先调用该类的析构函数，再释放指针所指向的内存空间。会形成无限循环。
5. 成员函数中 memset(this, 0, sizeof(this)) 会发生什么？
   1. 该对象的所有的成员变量被置空，如果遇到自定义类型，比如 std::string, std::vector 对象，会造成非法数据错误。因为 memset 操作会破坏这些对象内部分配的内存。
   2. 虚函数无法再被调用，成员变量在对上申请了内存，发生内存泄露。
6. this 指针调用成员变量时，堆栈会发生变化吗?
   1. 有变量被调用进栈，堆栈肯定会发生变化。

### 类对象

1. public/protected/private 继承权限？
   1. public 变量和函数可以被类的内外部访问
   2. protected 变量和函数只能被类的内部和派生类函数访问
   3. private 只能在类的内部被访问呢
2. public/protected/private 继承权限？
   1. public 继承基类 protected/public 数据和函数，访问权限不变
   2. protected 继承基类 protected/public 数据和函数，访问权限设置为 protected
   3. private 继承基类 protected/public 数据和函数，访问权限设置为 private
3. 类对象大小如何计算？
   1. 非静态成员数据类型大小之和 + 字节对齐 padding + 虚函数表指针 + 派生类继承的基类成员变量内存和
   2. 空类对象为 1，基类可以为 0
4. 编译器会为一个空类默认添加哪些函数？
   1. 构造函数，拷贝构造函数，析构函数，拷贝赋值运算符，取地址运算符，和取地址运算符 const
5. 什么是成员列表初始化？什么时候必须要用初始化成员列表？调用过程?
   1. 在类中构造函数中，直接在构造函数体之前使用冒号加括号的方式对成员变量赋初始值
   2. 当成员变量含有引用， const 成员变量，调用基类构造函数而该构造函数拥有一组参数时，调用一个成员类的构造函数而该构造函数有一组参数时
   3. C++ 编译器会按照变量声明的顺序申请内存之后直接将成员列表中的值填充到对应的内存空间中。
6. 类成员初始化方式有哪些，它们有什么区别？
   1. 声明时初始化，初始化列表，构造函数初始化，三者的顺序依次进行。
   2. 声明时初始化由 C++11 之后的版本支持，三种初始化方式时机后者会覆盖前者。
7. 成员初始化列表会在什么时候用到？
   1. 初始化一个引用成员变量，const 成员变量，调用一个拥有一组参数的基类构造函数或者成员类构造函数
8.

### 虚函数相关

1. 虚函数

### 构造函数和析构函数

1. C++ 有哪几种构造函数？
   1. 默认构造函数，普通构造函数，拷贝构造函数，移动构造函数，转换构造函数，委托构造函数
2. 构造函数有几种关键字？
   1. default：显示地要求编译器自动生成该函数的默认实现；
   2. delete：阻止编译器合成对应的默认函数；
   3. = 0：定义纯虚函数；
3. 拷贝构造函数介绍
   1. 拷贝构造函数的函数参数是一个常量引用，也就是说使用一个已存在的对象创建当前对象。
   2. 当一个对象以值传递的方式做函数参数和函数返回值时，以及一个对象需要另一个对象初始化时拷贝构造函数会被调用
4. 拷贝构造函数参数为什么必须是引用？
   1. 如果参数是值，那么就需要调用拷贝构造函数创建一个副本，这样就形成了拷贝构造函数调用拷贝构造函数的递归，最终导致栈溢出。
5. 移动构造函数介绍
   1. 移动构造函数使用一个已存在的对象创建当前对象，函数参数是一个右值引用。构造函数之后，旧对象资源会被移动给新对象使用，建议不要再使用旧资源。
   2. 移动构造函数是由 C++11 的 move 实现的。
   3. 当一个对象以右值引用的方式作为函数参数或者函数返回值时
6. 什么是拷贝构造函数，赋值构造函数，赋值操作符
   1. 拷贝构造函数是使用一个现有对象构造一个新的对象
   2. 赋值构造函数是使用一个现有对象去给另一个已经存在的对象重新赋值
   3. 赋值操作符是一个二元运算符，用于将右侧操作数的值复制给左侧操作数。
7. 拷贝初始化和直接初始化的区别？
   1. 拷贝初始化直接调用拷贝构造函数，函数参数是拷贝对象的引用或者值
   2. 直接初始化调用与实参匹配的构造函数
8. 构造函数和析构函数的执行顺序是什么？
   1. 派生类的构造函数执行顺序：继承的基类按照从左向右依次调用它们的构造函数，派生类的成员变量构造函数按照声明顺序依次调用，派生类自身的构造函数
   2. 派生类的析构函数执行顺序与构造函数调用顺序相反；
9. 一个类中的全部构造函数的扩展过程是什么？
   1. 调用基类的构造函数，初始化虚函数指针和虚表，声明初始化，成员类的构造函数，初始化列表，类自身构造函数
10. 什么时候会调用类的析构函数？
   1. 对象声明周期结束时，超出其作用域或者被 delete 删除时
   2. 被包含的类的析构函数调用时
   3. 指向子类的基类指针在被销毁时，子类的析构函数会被调用
11. 析构函数的作用？以及是如何起作用的？
   1. 释放对象占用的资源。在对象需要被销毁的时候调用析构函数。
12. 为什么析构函数一般写成虚函数？
   1. 为了防止内存泄漏。基类指针或者引用指向一个派生类对象，当需要释放掉这个基类指针时，如果析构函数不写成虚函数，那么基类指针就只会调用基类的析构函数，而不会去释放派生类申请的资源，会导致子类发生内存泄漏。
13. 为什么构造函数不能是虚函数
   1. 虚函数指针的初始化时机是在构造函数内部。
14. 父类的析构函数是否能定义为纯虚函数
   1. 可以被定义为纯虚函数。但是父类的析构函数被定义为纯虚函数，那父类的析构函数内部依然需要做实现，为父类资源释放做处理。
15. 在构造函数和析构函数中可以调用虚函数吗？
   1. 都可以，但是没有意义。
   2. 因为构造函数中类的成员变量都还没有完全初始化完，所以可能发生不可预期的结果；另外就算成功调用，也只是调用当前正在构建的类的虚函数，不会有动态绑定或者多态行为。析构函数中调用虚函数同理，因为派生类的对象已经释放。
16. 构造函数和析构函数中是否可以抛出异常？
   1. 能抛出，但是可能会造成一些问题。
   2. 构造函数中抛出异常会导致析构函数无法继续被执行，已经申请的资源无法释放，产生内存泄漏，所以尽量不要抛出异常。
   3. 析构函数抛出异常可能会导致资源泄漏，还可能会导致程序立刻终止。
17. 
